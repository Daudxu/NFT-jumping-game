var Mu=(e,t,n)=>{if(!t.has(e))throw TypeError("Cannot "+n)};var co=(e,t,n)=>(Mu(e,t,"read from private field"),n?n.call(e):t.get(e)),Ja=(e,t,n)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,n)},Za=(e,t,n,i)=>(Mu(e,t,"write to private field"),i?i.call(e,n):t.set(e,n),n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);new MutationObserver(r=>{for(const s of r)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function n(r){const s={};return r.integrity&&(s.integrity=r.integrity),r.referrerpolicy&&(s.referrerPolicy=r.referrerpolicy),r.crossorigin==="use-credentials"?s.credentials="include":r.crossorigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function i(r){if(r.ep)return;r.ep=!0;const s=n(r);fetch(r.href,s)}})();function Gc(e,t){const n=Object.create(null),i=e.split(",");for(let r=0;r<i.length;r++)n[i[r]]=!0;return t?r=>!!n[r.toLowerCase()]:r=>!!n[r]}function Vc(e){if(Ae(e)){const t={};for(let n=0;n<e.length;n++){const i=e[n],r=ut(i)?Vp(i):Vc(i);if(r)for(const s in r)t[s]=r[s]}return t}else{if(ut(e))return e;if($e(e))return e}}const Hp=/;(?![^(]*\))/g,kp=/:([^]+)/,Gp=/\/\*.*?\*\//gs;function Vp(e){const t={};return e.replace(Gp,"").split(Hp).forEach(n=>{if(n){const i=n.split(kp);i.length>1&&(t[i[0].trim()]=i[1].trim())}}),t}function Wc(e){let t="";if(ut(e))t=e;else if(Ae(e))for(let n=0;n<e.length;n++){const i=Wc(e[n]);i&&(t+=i+" ")}else if($e(e))for(const n in e)e[n]&&(t+=n+" ");return t.trim()}const Wp="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",jp=Gc(Wp);function Gd(e){return!!e||e===""}const Su=e=>ut(e)?e:e==null?"":Ae(e)||$e(e)&&(e.toString===qd||!Oe(e.toString))?JSON.stringify(e,Vd,2):String(e),Vd=(e,t)=>t&&t.__v_isRef?Vd(e,t.value):Ar(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((n,[i,r])=>(n[`${i} =>`]=r,n),{})}:Wd(t)?{[`Set(${t.size})`]:[...t.values()]}:$e(t)&&!Ae(t)&&!Xd(t)?String(t):t,Je={},Er=[],dn=()=>{},qp=()=>!1,Xp=/^on[^a-z]/,Aa=e=>Xp.test(e),jc=e=>e.startsWith("onUpdate:"),wt=Object.assign,qc=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)},Yp=Object.prototype.hasOwnProperty,ze=(e,t)=>Yp.call(e,t),Ae=Array.isArray,Ar=e=>La(e)==="[object Map]",Wd=e=>La(e)==="[object Set]",Oe=e=>typeof e=="function",ut=e=>typeof e=="string",Xc=e=>typeof e=="symbol",$e=e=>e!==null&&typeof e=="object",jd=e=>$e(e)&&Oe(e.then)&&Oe(e.catch),qd=Object.prototype.toString,La=e=>qd.call(e),Jp=e=>La(e).slice(8,-1),Xd=e=>La(e)==="[object Object]",Yc=e=>ut(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,ea=Gc(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),Ca=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},Zp=/-(\w)/g,Or=Ca(e=>e.replace(Zp,(t,n)=>n?n.toUpperCase():"")),$p=/\B([A-Z])/g,Zr=Ca(e=>e.replace($p,"-$1").toLowerCase()),Yd=Ca(e=>e.charAt(0).toUpperCase()+e.slice(1)),$a=Ca(e=>e?`on${Yd(e)}`:""),Rs=(e,t)=>!Object.is(e,t),Ka=(e,t)=>{for(let n=0;n<e.length;n++)e[n](t)},oa=(e,t,n)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,value:n})},Jd=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let Tu;const Kp=()=>Tu||(Tu=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});let zt;class Zd{constructor(t=!1){this.detached=t,this.active=!0,this.effects=[],this.cleanups=[],this.parent=zt,!t&&zt&&(this.index=(zt.scopes||(zt.scopes=[])).push(this)-1)}run(t){if(this.active){const n=zt;try{return zt=this,t()}finally{zt=n}}}on(){zt=this}off(){zt=this.parent}stop(t){if(this.active){let n,i;for(n=0,i=this.effects.length;n<i;n++)this.effects[n].stop();for(n=0,i=this.cleanups.length;n<i;n++)this.cleanups[n]();if(this.scopes)for(n=0,i=this.scopes.length;n<i;n++)this.scopes[n].stop(!0);if(!this.detached&&this.parent&&!t){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}}}function $d(e){return new Zd(e)}function Qp(e,t=zt){t&&t.active&&t.effects.push(e)}function em(){return zt}function tm(e){zt&&zt.cleanups.push(e)}const Jc=e=>{const t=new Set(e);return t.w=0,t.n=0,t},Kd=e=>(e.w&Mi)>0,Qd=e=>(e.n&Mi)>0,nm=({deps:e})=>{if(e.length)for(let t=0;t<e.length;t++)e[t].w|=Mi},im=e=>{const{deps:t}=e;if(t.length){let n=0;for(let i=0;i<t.length;i++){const r=t[i];Kd(r)&&!Qd(r)?r.delete(e):t[n++]=r,r.w&=~Mi,r.n&=~Mi}t.length=n}},Vl=new WeakMap;let ps=0,Mi=1;const Wl=30;let cn;const ki=Symbol(""),jl=Symbol("");class Zc{constructor(t,n=null,i){this.fn=t,this.scheduler=n,this.active=!0,this.deps=[],this.parent=void 0,Qp(this,i)}run(){if(!this.active)return this.fn();let t=cn,n=gi;for(;t;){if(t===this)return;t=t.parent}try{return this.parent=cn,cn=this,gi=!0,Mi=1<<++ps,ps<=Wl?nm(this):Eu(this),this.fn()}finally{ps<=Wl&&im(this),Mi=1<<--ps,cn=this.parent,gi=n,this.parent=void 0,this.deferStop&&this.stop()}}stop(){cn===this?this.deferStop=!0:this.active&&(Eu(this),this.onStop&&this.onStop(),this.active=!1)}}function Eu(e){const{deps:t}=e;if(t.length){for(let n=0;n<t.length;n++)t[n].delete(e);t.length=0}}let gi=!0;const eh=[];function $r(){eh.push(gi),gi=!1}function Kr(){const e=eh.pop();gi=e===void 0?!0:e}function Vt(e,t,n){if(gi&&cn){let i=Vl.get(e);i||Vl.set(e,i=new Map);let r=i.get(n);r||i.set(n,r=Jc()),th(r)}}function th(e,t){let n=!1;ps<=Wl?Qd(e)||(e.n|=Mi,n=!Kd(e)):n=!e.has(cn),n&&(e.add(cn),cn.deps.push(e))}function Hn(e,t,n,i,r,s){const o=Vl.get(e);if(!o)return;let a=[];if(t==="clear")a=[...o.values()];else if(n==="length"&&Ae(e)){const l=Jd(i);o.forEach((c,f)=>{(f==="length"||f>=l)&&a.push(c)})}else switch(n!==void 0&&a.push(o.get(n)),t){case"add":Ae(e)?Yc(n)&&a.push(o.get("length")):(a.push(o.get(ki)),Ar(e)&&a.push(o.get(jl)));break;case"delete":Ae(e)||(a.push(o.get(ki)),Ar(e)&&a.push(o.get(jl)));break;case"set":Ar(e)&&a.push(o.get(ki));break}if(a.length===1)a[0]&&ql(a[0]);else{const l=[];for(const c of a)c&&l.push(...c);ql(Jc(l))}}function ql(e,t){const n=Ae(e)?e:[...e];for(const i of n)i.computed&&Au(i);for(const i of n)i.computed||Au(i)}function Au(e,t){(e!==cn||e.allowRecurse)&&(e.scheduler?e.scheduler():e.run())}const rm=Gc("__proto__,__v_isRef,__isVue"),nh=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(Xc)),sm=$c(),om=$c(!1,!0),am=$c(!0),Lu=lm();function lm(){const e={};return["includes","indexOf","lastIndexOf"].forEach(t=>{e[t]=function(...n){const i=Ue(this);for(let s=0,o=this.length;s<o;s++)Vt(i,"get",s+"");const r=i[t](...n);return r===-1||r===!1?i[t](...n.map(Ue)):r}}),["push","pop","shift","unshift","splice"].forEach(t=>{e[t]=function(...n){$r();const i=Ue(this)[t].apply(this,n);return Kr(),i}}),e}function $c(e=!1,t=!1){return function(i,r,s){if(r==="__v_isReactive")return!e;if(r==="__v_isReadonly")return e;if(r==="__v_isShallow")return t;if(r==="__v_raw"&&s===(e?t?Sm:ah:t?oh:sh).get(i))return i;const o=Ae(i);if(!e&&o&&ze(Lu,r))return Reflect.get(Lu,r,s);const a=Reflect.get(i,r,s);return(Xc(r)?nh.has(r):rm(r))||(e||Vt(i,"get",r),t)?a:et(a)?o&&Yc(r)?a:a.value:$e(a)?e?lh(a):Ra(a):a}}const cm=ih(),um=ih(!0);function ih(e=!1){return function(n,i,r,s){let o=n[i];if(Nr(o)&&et(o)&&!et(r))return!1;if(!e&&(!aa(r)&&!Nr(r)&&(o=Ue(o),r=Ue(r)),!Ae(n)&&et(o)&&!et(r)))return o.value=r,!0;const a=Ae(n)&&Yc(i)?Number(i)<n.length:ze(n,i),l=Reflect.set(n,i,r,s);return n===Ue(s)&&(a?Rs(r,o)&&Hn(n,"set",i,r):Hn(n,"add",i,r)),l}}function fm(e,t){const n=ze(e,t);e[t];const i=Reflect.deleteProperty(e,t);return i&&n&&Hn(e,"delete",t,void 0),i}function dm(e,t){const n=Reflect.has(e,t);return(!Xc(t)||!nh.has(t))&&Vt(e,"has",t),n}function hm(e){return Vt(e,"iterate",Ae(e)?"length":ki),Reflect.ownKeys(e)}const rh={get:sm,set:cm,deleteProperty:fm,has:dm,ownKeys:hm},pm={get:am,set(e,t){return!0},deleteProperty(e,t){return!0}},mm=wt({},rh,{get:om,set:um}),Kc=e=>e,Pa=e=>Reflect.getPrototypeOf(e);function uo(e,t,n=!1,i=!1){e=e.__v_raw;const r=Ue(e),s=Ue(t);n||(t!==s&&Vt(r,"get",t),Vt(r,"get",s));const{has:o}=Pa(r),a=i?Kc:n?tu:Is;if(o.call(r,t))return a(e.get(t));if(o.call(r,s))return a(e.get(s));e!==r&&e.get(t)}function fo(e,t=!1){const n=this.__v_raw,i=Ue(n),r=Ue(e);return t||(e!==r&&Vt(i,"has",e),Vt(i,"has",r)),e===r?n.has(e):n.has(e)||n.has(r)}function ho(e,t=!1){return e=e.__v_raw,!t&&Vt(Ue(e),"iterate",ki),Reflect.get(e,"size",e)}function Cu(e){e=Ue(e);const t=Ue(this);return Pa(t).has.call(t,e)||(t.add(e),Hn(t,"add",e,e)),this}function Pu(e,t){t=Ue(t);const n=Ue(this),{has:i,get:r}=Pa(n);let s=i.call(n,e);s||(e=Ue(e),s=i.call(n,e));const o=r.call(n,e);return n.set(e,t),s?Rs(t,o)&&Hn(n,"set",e,t):Hn(n,"add",e,t),this}function Ru(e){const t=Ue(this),{has:n,get:i}=Pa(t);let r=n.call(t,e);r||(e=Ue(e),r=n.call(t,e)),i&&i.call(t,e);const s=t.delete(e);return r&&Hn(t,"delete",e,void 0),s}function Iu(){const e=Ue(this),t=e.size!==0,n=e.clear();return t&&Hn(e,"clear",void 0,void 0),n}function po(e,t){return function(i,r){const s=this,o=s.__v_raw,a=Ue(o),l=t?Kc:e?tu:Is;return!e&&Vt(a,"iterate",ki),o.forEach((c,f)=>i.call(r,l(c),l(f),s))}}function mo(e,t,n){return function(...i){const r=this.__v_raw,s=Ue(r),o=Ar(s),a=e==="entries"||e===Symbol.iterator&&o,l=e==="keys"&&o,c=r[e](...i),f=n?Kc:t?tu:Is;return!t&&Vt(s,"iterate",l?jl:ki),{next(){const{value:u,done:d}=c.next();return d?{value:u,done:d}:{value:a?[f(u[0]),f(u[1])]:f(u),done:d}},[Symbol.iterator](){return this}}}}function ei(e){return function(...t){return e==="delete"?!1:this}}function gm(){const e={get(s){return uo(this,s)},get size(){return ho(this)},has:fo,add:Cu,set:Pu,delete:Ru,clear:Iu,forEach:po(!1,!1)},t={get(s){return uo(this,s,!1,!0)},get size(){return ho(this)},has:fo,add:Cu,set:Pu,delete:Ru,clear:Iu,forEach:po(!1,!0)},n={get(s){return uo(this,s,!0)},get size(){return ho(this,!0)},has(s){return fo.call(this,s,!0)},add:ei("add"),set:ei("set"),delete:ei("delete"),clear:ei("clear"),forEach:po(!0,!1)},i={get(s){return uo(this,s,!0,!0)},get size(){return ho(this,!0)},has(s){return fo.call(this,s,!0)},add:ei("add"),set:ei("set"),delete:ei("delete"),clear:ei("clear"),forEach:po(!0,!0)};return["keys","values","entries",Symbol.iterator].forEach(s=>{e[s]=mo(s,!1,!1),n[s]=mo(s,!0,!1),t[s]=mo(s,!1,!0),i[s]=mo(s,!0,!0)}),[e,n,t,i]}const[vm,ym,xm,_m]=gm();function Qc(e,t){const n=t?e?_m:xm:e?ym:vm;return(i,r,s)=>r==="__v_isReactive"?!e:r==="__v_isReadonly"?e:r==="__v_raw"?i:Reflect.get(ze(n,r)&&r in i?n:i,r,s)}const bm={get:Qc(!1,!1)},wm={get:Qc(!1,!0)},Mm={get:Qc(!0,!1)},sh=new WeakMap,oh=new WeakMap,ah=new WeakMap,Sm=new WeakMap;function Tm(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Em(e){return e.__v_skip||!Object.isExtensible(e)?0:Tm(Jp(e))}function Ra(e){return Nr(e)?e:eu(e,!1,rh,bm,sh)}function Am(e){return eu(e,!1,mm,wm,oh)}function lh(e){return eu(e,!0,pm,Mm,ah)}function eu(e,t,n,i,r){if(!$e(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const s=r.get(e);if(s)return s;const o=Em(e);if(o===0)return e;const a=new Proxy(e,o===2?i:n);return r.set(e,a),a}function vi(e){return Nr(e)?vi(e.__v_raw):!!(e&&e.__v_isReactive)}function Nr(e){return!!(e&&e.__v_isReadonly)}function aa(e){return!!(e&&e.__v_isShallow)}function ch(e){return vi(e)||Nr(e)}function Ue(e){const t=e&&e.__v_raw;return t?Ue(t):e}function Dr(e){return oa(e,"__v_skip",!0),e}const Is=e=>$e(e)?Ra(e):e,tu=e=>$e(e)?lh(e):e;function uh(e){gi&&cn&&(e=Ue(e),th(e.dep||(e.dep=Jc())))}function fh(e,t){e=Ue(e),e.dep&&ql(e.dep)}function et(e){return!!(e&&e.__v_isRef===!0)}function it(e){return Lm(e,!1)}function Lm(e,t){return et(e)?e:new Cm(e,t)}class Cm{constructor(t,n){this.__v_isShallow=n,this.dep=void 0,this.__v_isRef=!0,this._rawValue=n?t:Ue(t),this._value=n?t:Is(t)}get value(){return uh(this),this._value}set value(t){const n=this.__v_isShallow||aa(t)||Nr(t);t=n?t:Ue(t),Rs(t,this._rawValue)&&(this._rawValue=t,this._value=n?t:Is(t),fh(this))}}function ci(e){return et(e)?e.value:e}const Pm={get:(e,t,n)=>ci(Reflect.get(e,t,n)),set:(e,t,n,i)=>{const r=e[t];return et(r)&&!et(n)?(r.value=n,!0):Reflect.set(e,t,n,i)}};function dh(e){return vi(e)?e:new Proxy(e,Pm)}function Rm(e){const t=Ae(e)?new Array(e.length):{};for(const n in e)t[n]=Om(e,n);return t}class Im{constructor(t,n,i){this._object=t,this._key=n,this._defaultValue=i,this.__v_isRef=!0}get value(){const t=this._object[this._key];return t===void 0?this._defaultValue:t}set value(t){this._object[this._key]=t}}function Om(e,t,n){const i=e[t];return et(i)?i:new Im(e,t,n)}var hh;class Nm{constructor(t,n,i,r){this._setter=n,this.dep=void 0,this.__v_isRef=!0,this[hh]=!1,this._dirty=!0,this.effect=new Zc(t,()=>{this._dirty||(this._dirty=!0,fh(this))}),this.effect.computed=this,this.effect.active=this._cacheable=!r,this.__v_isReadonly=i}get value(){const t=Ue(this);return uh(t),(t._dirty||!t._cacheable)&&(t._dirty=!1,t._value=t.effect.run()),t._value}set value(t){this._setter(t)}}hh="__v_isReadonly";function Dm(e,t,n=!1){let i,r;const s=Oe(e);return s?(i=e,r=dn):(i=e.get,r=e.set),new Nm(i,r,s||!r,n)}function yi(e,t,n,i){let r;try{r=i?e(...i):e()}catch(s){Ia(s,t,n)}return r}function Qt(e,t,n,i){if(Oe(e)){const s=yi(e,t,n,i);return s&&jd(s)&&s.catch(o=>{Ia(o,t,n)}),s}const r=[];for(let s=0;s<e.length;s++)r.push(Qt(e[s],t,n,i));return r}function Ia(e,t,n,i=!0){const r=t?t.vnode:null;if(t){let s=t.parent;const o=t.proxy,a=n;for(;s;){const c=s.ec;if(c){for(let f=0;f<c.length;f++)if(c[f](e,o,a)===!1)return}s=s.parent}const l=t.appContext.config.errorHandler;if(l){yi(l,null,10,[e,o,a]);return}}Fm(e,n,r,i)}function Fm(e,t,n,i=!0){console.error(e)}let Os=!1,Xl=!1;const yt=[];let wn=0;const Lr=[];let Fn=null,zi=0;const ph=Promise.resolve();let nu=null;function iu(e){const t=nu||ph;return e?t.then(this?e.bind(this):e):t}function Bm(e){let t=wn+1,n=yt.length;for(;t<n;){const i=t+n>>>1;Ns(yt[i])<e?t=i+1:n=i}return t}function ru(e){(!yt.length||!yt.includes(e,Os&&e.allowRecurse?wn+1:wn))&&(e.id==null?yt.push(e):yt.splice(Bm(e.id),0,e),mh())}function mh(){!Os&&!Xl&&(Xl=!0,nu=ph.then(vh))}function zm(e){const t=yt.indexOf(e);t>wn&&yt.splice(t,1)}function Um(e){Ae(e)?Lr.push(...e):(!Fn||!Fn.includes(e,e.allowRecurse?zi+1:zi))&&Lr.push(e),mh()}function Ou(e,t=Os?wn+1:0){for(;t<yt.length;t++){const n=yt[t];n&&n.pre&&(yt.splice(t,1),t--,n())}}function gh(e){if(Lr.length){const t=[...new Set(Lr)];if(Lr.length=0,Fn){Fn.push(...t);return}for(Fn=t,Fn.sort((n,i)=>Ns(n)-Ns(i)),zi=0;zi<Fn.length;zi++)Fn[zi]();Fn=null,zi=0}}const Ns=e=>e.id==null?1/0:e.id,Hm=(e,t)=>{const n=Ns(e)-Ns(t);if(n===0){if(e.pre&&!t.pre)return-1;if(t.pre&&!e.pre)return 1}return n};function vh(e){Xl=!1,Os=!0,yt.sort(Hm);const t=dn;try{for(wn=0;wn<yt.length;wn++){const n=yt[wn];n&&n.active!==!1&&yi(n,null,14)}}finally{wn=0,yt.length=0,gh(),Os=!1,nu=null,(yt.length||Lr.length)&&vh()}}function km(e,t,...n){if(e.isUnmounted)return;const i=e.vnode.props||Je;let r=n;const s=t.startsWith("update:"),o=s&&t.slice(7);if(o&&o in i){const f=`${o==="modelValue"?"model":o}Modifiers`,{number:u,trim:d}=i[f]||Je;d&&(r=n.map(h=>ut(h)?h.trim():h)),u&&(r=n.map(Jd))}let a,l=i[a=$a(t)]||i[a=$a(Or(t))];!l&&s&&(l=i[a=$a(Zr(t))]),l&&Qt(l,e,6,r);const c=i[a+"Once"];if(c){if(!e.emitted)e.emitted={};else if(e.emitted[a])return;e.emitted[a]=!0,Qt(c,e,6,r)}}function yh(e,t,n=!1){const i=t.emitsCache,r=i.get(e);if(r!==void 0)return r;const s=e.emits;let o={},a=!1;if(!Oe(e)){const l=c=>{const f=yh(c,t,!0);f&&(a=!0,wt(o,f))};!n&&t.mixins.length&&t.mixins.forEach(l),e.extends&&l(e.extends),e.mixins&&e.mixins.forEach(l)}return!s&&!a?($e(e)&&i.set(e,null),null):(Ae(s)?s.forEach(l=>o[l]=null):wt(o,s),$e(e)&&i.set(e,o),o)}function Oa(e,t){return!e||!Aa(t)?!1:(t=t.slice(2).replace(/Once$/,""),ze(e,t[0].toLowerCase()+t.slice(1))||ze(e,Zr(t))||ze(e,t))}let un=null,Na=null;function la(e){const t=un;return un=e,Na=e&&e.type.__scopeId||null,t}function Gm(e){Na=e}function Vm(){Na=null}function ms(e,t=un,n){if(!t||e._n)return e;const i=(...r)=>{i._d&&Gu(-1);const s=la(t);let o;try{o=e(...r)}finally{la(s),i._d&&Gu(1)}return o};return i._n=!0,i._c=!0,i._d=!0,i}function Qa(e){const{type:t,vnode:n,proxy:i,withProxy:r,props:s,propsOptions:[o],slots:a,attrs:l,emit:c,render:f,renderCache:u,data:d,setupState:h,ctx:p,inheritAttrs:v}=e;let y,m;const g=la(e);try{if(n.shapeFlag&4){const P=r||i;y=_n(f.call(P,P,u,s,h,d,p)),m=l}else{const P=t;y=_n(P.length>1?P(s,{attrs:l,slots:a,emit:c}):P(s,null)),m=t.props?l:Wm(l)}}catch(P){bs.length=0,Ia(P,e,1),y=mt(hn)}let T=y;if(m&&v!==!1){const P=Object.keys(m),{shapeFlag:A}=T;P.length&&A&7&&(o&&P.some(jc)&&(m=jm(m,o)),T=Si(T,m))}return n.dirs&&(T=Si(T),T.dirs=T.dirs?T.dirs.concat(n.dirs):n.dirs),n.transition&&(T.transition=n.transition),y=T,la(g),y}const Wm=e=>{let t;for(const n in e)(n==="class"||n==="style"||Aa(n))&&((t||(t={}))[n]=e[n]);return t},jm=(e,t)=>{const n={};for(const i in e)(!jc(i)||!(i.slice(9)in t))&&(n[i]=e[i]);return n};function qm(e,t,n){const{props:i,children:r,component:s}=e,{props:o,children:a,patchFlag:l}=t,c=s.emitsOptions;if(t.dirs||t.transition)return!0;if(n&&l>=0){if(l&1024)return!0;if(l&16)return i?Nu(i,o,c):!!o;if(l&8){const f=t.dynamicProps;for(let u=0;u<f.length;u++){const d=f[u];if(o[d]!==i[d]&&!Oa(c,d))return!0}}}else return(r||a)&&(!a||!a.$stable)?!0:i===o?!1:i?o?Nu(i,o,c):!0:!!o;return!1}function Nu(e,t,n){const i=Object.keys(t);if(i.length!==Object.keys(e).length)return!0;for(let r=0;r<i.length;r++){const s=i[r];if(t[s]!==e[s]&&!Oa(n,s))return!0}return!1}function Xm({vnode:e,parent:t},n){for(;t&&t.subTree===e;)(e=t.vnode).el=n,t=t.parent}const Ym=e=>e.__isSuspense;function Jm(e,t){t&&t.pendingBranch?Ae(e)?t.effects.push(...e):t.effects.push(e):Um(e)}function su(e,t){if(pt){let n=pt.provides;const i=pt.parent&&pt.parent.provides;i===n&&(n=pt.provides=Object.create(i)),n[e]=t}}function ys(e,t,n=!1){const i=pt||un;if(i){const r=i.parent==null?i.vnode.appContext&&i.vnode.appContext.provides:i.parent.provides;if(r&&e in r)return r[e];if(arguments.length>1)return n&&Oe(t)?t.call(i.proxy):t}}const go={};function xs(e,t,n){return xh(e,t,n)}function xh(e,t,{immediate:n,deep:i,flush:r,onTrack:s,onTrigger:o}=Je){const a=pt;let l,c=!1,f=!1;if(et(e)?(l=()=>e.value,c=aa(e)):vi(e)?(l=()=>e,i=!0):Ae(e)?(f=!0,c=e.some(T=>vi(T)||aa(T)),l=()=>e.map(T=>{if(et(T))return T.value;if(vi(T))return xr(T);if(Oe(T))return yi(T,a,2)})):Oe(e)?t?l=()=>yi(e,a,2):l=()=>{if(!(a&&a.isUnmounted))return u&&u(),Qt(e,a,3,[d])}:l=dn,t&&i){const T=l;l=()=>xr(T())}let u,d=T=>{u=m.onStop=()=>{yi(T,a,4)}},h;if(Fs)if(d=dn,t?n&&Qt(t,a,3,[l(),f?[]:void 0,d]):l(),r==="sync"){const T=kg();h=T.__watcherHandles||(T.__watcherHandles=[])}else return dn;let p=f?new Array(e.length).fill(go):go;const v=()=>{if(!!m.active)if(t){const T=m.run();(i||c||(f?T.some((P,A)=>Rs(P,p[A])):Rs(T,p)))&&(u&&u(),Qt(t,a,3,[T,p===go?void 0:f&&p[0]===go?[]:p,d]),p=T)}else m.run()};v.allowRecurse=!!t;let y;r==="sync"?y=v:r==="post"?y=()=>At(v,a&&a.suspense):(v.pre=!0,a&&(v.id=a.uid),y=()=>ru(v));const m=new Zc(l,y);t?n?v():p=m.run():r==="post"?At(m.run.bind(m),a&&a.suspense):m.run();const g=()=>{m.stop(),a&&a.scope&&qc(a.scope.effects,m)};return h&&h.push(g),g}function Zm(e,t,n){const i=this.proxy,r=ut(e)?e.includes(".")?_h(i,e):()=>i[e]:e.bind(i,i);let s;Oe(t)?s=t:(s=t.handler,n=t);const o=pt;Fr(this);const a=xh(r,s.bind(i),n);return o?Fr(o):Gi(),a}function _h(e,t){const n=t.split(".");return()=>{let i=e;for(let r=0;r<n.length&&i;r++)i=i[n[r]];return i}}function xr(e,t){if(!$e(e)||e.__v_skip||(t=t||new Set,t.has(e)))return e;if(t.add(e),et(e))xr(e.value,t);else if(Ae(e))for(let n=0;n<e.length;n++)xr(e[n],t);else if(Wd(e)||Ar(e))e.forEach(n=>{xr(n,t)});else if(Xd(e))for(const n in e)xr(e[n],t);return e}function $m(){const e={isMounted:!1,isLeaving:!1,isUnmounting:!1,leavingVNodes:new Map};return to(()=>{e.isMounted=!0}),Ba(()=>{e.isUnmounting=!0}),e}const Zt=[Function,Array],Km={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,onBeforeEnter:Zt,onEnter:Zt,onAfterEnter:Zt,onEnterCancelled:Zt,onBeforeLeave:Zt,onLeave:Zt,onAfterLeave:Zt,onLeaveCancelled:Zt,onBeforeAppear:Zt,onAppear:Zt,onAfterAppear:Zt,onAppearCancelled:Zt},setup(e,{slots:t}){const n=Fh(),i=$m();let r;return()=>{const s=t.default&&wh(t.default(),!0);if(!s||!s.length)return;let o=s[0];if(s.length>1){for(const v of s)if(v.type!==hn){o=v;break}}const a=Ue(e),{mode:l}=a;if(i.isLeaving)return el(o);const c=Du(o);if(!c)return el(o);const f=Yl(c,a,i,n);Jl(c,f);const u=n.subTree,d=u&&Du(u);let h=!1;const{getTransitionKey:p}=c.type;if(p){const v=p();r===void 0?r=v:v!==r&&(r=v,h=!0)}if(d&&d.type!==hn&&(!Ui(c,d)||h)){const v=Yl(d,a,i,n);if(Jl(d,v),l==="out-in")return i.isLeaving=!0,v.afterLeave=()=>{i.isLeaving=!1,n.update.active!==!1&&n.update()},el(o);l==="in-out"&&c.type!==hn&&(v.delayLeave=(y,m,g)=>{const T=bh(i,d);T[String(d.key)]=d,y._leaveCb=()=>{m(),y._leaveCb=void 0,delete f.delayedLeave},f.delayedLeave=g})}return o}}},Qm=Km;function bh(e,t){const{leavingVNodes:n}=e;let i=n.get(t.type);return i||(i=Object.create(null),n.set(t.type,i)),i}function Yl(e,t,n,i){const{appear:r,mode:s,persisted:o=!1,onBeforeEnter:a,onEnter:l,onAfterEnter:c,onEnterCancelled:f,onBeforeLeave:u,onLeave:d,onAfterLeave:h,onLeaveCancelled:p,onBeforeAppear:v,onAppear:y,onAfterAppear:m,onAppearCancelled:g}=t,T=String(e.key),P=bh(n,e),A=(B,W)=>{B&&Qt(B,i,9,W)},M=(B,W)=>{const te=W[1];A(B,W),Ae(B)?B.every(H=>H.length<=1)&&te():B.length<=1&&te()},N={mode:s,persisted:o,beforeEnter(B){let W=a;if(!n.isMounted)if(r)W=v||a;else return;B._leaveCb&&B._leaveCb(!0);const te=P[T];te&&Ui(e,te)&&te.el._leaveCb&&te.el._leaveCb(),A(W,[B])},enter(B){let W=l,te=c,H=f;if(!n.isMounted)if(r)W=y||l,te=m||c,H=g||f;else return;let j=!1;const Y=B._enterCb=X=>{j||(j=!0,X?A(H,[B]):A(te,[B]),N.delayedLeave&&N.delayedLeave(),B._enterCb=void 0)};W?M(W,[B,Y]):Y()},leave(B,W){const te=String(e.key);if(B._enterCb&&B._enterCb(!0),n.isUnmounting)return W();A(u,[B]);let H=!1;const j=B._leaveCb=Y=>{H||(H=!0,W(),Y?A(p,[B]):A(h,[B]),B._leaveCb=void 0,P[te]===e&&delete P[te])};P[te]=e,d?M(d,[B,j]):j()},clone(B){return Yl(B,t,n,i)}};return N}function el(e){if(Da(e))return e=Si(e),e.children=null,e}function Du(e){return Da(e)?e.children?e.children[0]:void 0:e}function Jl(e,t){e.shapeFlag&6&&e.component?Jl(e.component.subTree,t):e.shapeFlag&128?(e.ssContent.transition=t.clone(e.ssContent),e.ssFallback.transition=t.clone(e.ssFallback)):e.transition=t}function wh(e,t=!1,n){let i=[],r=0;for(let s=0;s<e.length;s++){let o=e[s];const a=n==null?o.key:String(n)+String(o.key!=null?o.key:s);o.type===an?(o.patchFlag&128&&r++,i=i.concat(wh(o.children,t,a))):(t||o.type!==hn)&&i.push(a!=null?Si(o,{key:a}):o)}if(r>1)for(let s=0;s<i.length;s++)i[s].patchFlag=-2;return i}const ta=e=>!!e.type.__asyncLoader,Da=e=>e.type.__isKeepAlive;function eg(e,t){Mh(e,"a",t)}function tg(e,t){Mh(e,"da",t)}function Mh(e,t,n=pt){const i=e.__wdc||(e.__wdc=()=>{let r=n;for(;r;){if(r.isDeactivated)return;r=r.parent}return e()});if(Fa(t,i,n),n){let r=n.parent;for(;r&&r.parent;)Da(r.parent.vnode)&&ng(i,t,n,r),r=r.parent}}function ng(e,t,n,i){const r=Fa(t,e,i,!0);Th(()=>{qc(i[t],r)},n)}function Fa(e,t,n=pt,i=!1){if(n){const r=n[e]||(n[e]=[]),s=t.__weh||(t.__weh=(...o)=>{if(n.isUnmounted)return;$r(),Fr(n);const a=Qt(t,n,e,o);return Gi(),Kr(),a});return i?r.unshift(s):r.push(s),s}}const Xn=e=>(t,n=pt)=>(!Fs||e==="sp")&&Fa(e,(...i)=>t(...i),n),ig=Xn("bm"),to=Xn("m"),Sh=Xn("bu"),ou=Xn("u"),Ba=Xn("bum"),Th=Xn("um"),rg=Xn("sp"),sg=Xn("rtg"),og=Xn("rtc");function ag(e,t=pt){Fa("ec",e,t)}function Pi(e,t,n,i){const r=e.dirs,s=t&&t.dirs;for(let o=0;o<r.length;o++){const a=r[o];s&&(a.oldValue=s[o].value);let l=a.dir[i];l&&($r(),Qt(l,n,8,[e.el,a,e,t]),Kr())}}const lg=Symbol(),Zl=e=>e?Bh(e)?uu(e)||e.proxy:Zl(e.parent):null,_s=wt(Object.create(null),{$:e=>e,$el:e=>e.vnode.el,$data:e=>e.data,$props:e=>e.props,$attrs:e=>e.attrs,$slots:e=>e.slots,$refs:e=>e.refs,$parent:e=>Zl(e.parent),$root:e=>Zl(e.root),$emit:e=>e.emit,$options:e=>au(e),$forceUpdate:e=>e.f||(e.f=()=>ru(e.update)),$nextTick:e=>e.n||(e.n=iu.bind(e.proxy)),$watch:e=>Zm.bind(e)}),tl=(e,t)=>e!==Je&&!e.__isScriptSetup&&ze(e,t),cg={get({_:e},t){const{ctx:n,setupState:i,data:r,props:s,accessCache:o,type:a,appContext:l}=e;let c;if(t[0]!=="$"){const h=o[t];if(h!==void 0)switch(h){case 1:return i[t];case 2:return r[t];case 4:return n[t];case 3:return s[t]}else{if(tl(i,t))return o[t]=1,i[t];if(r!==Je&&ze(r,t))return o[t]=2,r[t];if((c=e.propsOptions[0])&&ze(c,t))return o[t]=3,s[t];if(n!==Je&&ze(n,t))return o[t]=4,n[t];$l&&(o[t]=0)}}const f=_s[t];let u,d;if(f)return t==="$attrs"&&Vt(e,"get",t),f(e);if((u=a.__cssModules)&&(u=u[t]))return u;if(n!==Je&&ze(n,t))return o[t]=4,n[t];if(d=l.config.globalProperties,ze(d,t))return d[t]},set({_:e},t,n){const{data:i,setupState:r,ctx:s}=e;return tl(r,t)?(r[t]=n,!0):i!==Je&&ze(i,t)?(i[t]=n,!0):ze(e.props,t)||t[0]==="$"&&t.slice(1)in e?!1:(s[t]=n,!0)},has({_:{data:e,setupState:t,accessCache:n,ctx:i,appContext:r,propsOptions:s}},o){let a;return!!n[o]||e!==Je&&ze(e,o)||tl(t,o)||(a=s[0])&&ze(a,o)||ze(i,o)||ze(_s,o)||ze(r.config.globalProperties,o)},defineProperty(e,t,n){return n.get!=null?e._.accessCache[t]=0:ze(n,"value")&&this.set(e,t,n.value,null),Reflect.defineProperty(e,t,n)}};let $l=!0;function ug(e){const t=au(e),n=e.proxy,i=e.ctx;$l=!1,t.beforeCreate&&Fu(t.beforeCreate,e,"bc");const{data:r,computed:s,methods:o,watch:a,provide:l,inject:c,created:f,beforeMount:u,mounted:d,beforeUpdate:h,updated:p,activated:v,deactivated:y,beforeDestroy:m,beforeUnmount:g,destroyed:T,unmounted:P,render:A,renderTracked:M,renderTriggered:N,errorCaptured:B,serverPrefetch:W,expose:te,inheritAttrs:H,components:j,directives:Y,filters:X}=t;if(c&&fg(c,i,null,e.appContext.config.unwrapInjectedRef),o)for(const ne in o){const oe=o[ne];Oe(oe)&&(i[ne]=oe.bind(n))}if(r){const ne=r.call(n,n);$e(ne)&&(e.data=Ra(ne))}if($l=!0,s)for(const ne in s){const oe=s[ne],fe=Oe(oe)?oe.bind(n,n):Oe(oe.get)?oe.get.bind(n,n):dn,ge=!Oe(oe)&&Oe(oe.set)?oe.set.bind(n):dn,he=Ha({get:fe,set:ge});Object.defineProperty(i,ne,{enumerable:!0,configurable:!0,get:()=>he.value,set:de=>he.value=de})}if(a)for(const ne in a)Eh(a[ne],i,n,ne);if(l){const ne=Oe(l)?l.call(n):l;Reflect.ownKeys(ne).forEach(oe=>{su(oe,ne[oe])})}f&&Fu(f,e,"c");function $(ne,oe){Ae(oe)?oe.forEach(fe=>ne(fe.bind(n))):oe&&ne(oe.bind(n))}if($(ig,u),$(to,d),$(Sh,h),$(ou,p),$(eg,v),$(tg,y),$(ag,B),$(og,M),$(sg,N),$(Ba,g),$(Th,P),$(rg,W),Ae(te))if(te.length){const ne=e.exposed||(e.exposed={});te.forEach(oe=>{Object.defineProperty(ne,oe,{get:()=>n[oe],set:fe=>n[oe]=fe})})}else e.exposed||(e.exposed={});A&&e.render===dn&&(e.render=A),H!=null&&(e.inheritAttrs=H),j&&(e.components=j),Y&&(e.directives=Y)}function fg(e,t,n=dn,i=!1){Ae(e)&&(e=Kl(e));for(const r in e){const s=e[r];let o;$e(s)?"default"in s?o=ys(s.from||r,s.default,!0):o=ys(s.from||r):o=ys(s),et(o)&&i?Object.defineProperty(t,r,{enumerable:!0,configurable:!0,get:()=>o.value,set:a=>o.value=a}):t[r]=o}}function Fu(e,t,n){Qt(Ae(e)?e.map(i=>i.bind(t.proxy)):e.bind(t.proxy),t,n)}function Eh(e,t,n,i){const r=i.includes(".")?_h(n,i):()=>n[i];if(ut(e)){const s=t[e];Oe(s)&&xs(r,s)}else if(Oe(e))xs(r,e.bind(n));else if($e(e))if(Ae(e))e.forEach(s=>Eh(s,t,n,i));else{const s=Oe(e.handler)?e.handler.bind(n):t[e.handler];Oe(s)&&xs(r,s,e)}}function au(e){const t=e.type,{mixins:n,extends:i}=t,{mixins:r,optionsCache:s,config:{optionMergeStrategies:o}}=e.appContext,a=s.get(t);let l;return a?l=a:!r.length&&!n&&!i?l=t:(l={},r.length&&r.forEach(c=>ca(l,c,o,!0)),ca(l,t,o)),$e(t)&&s.set(t,l),l}function ca(e,t,n,i=!1){const{mixins:r,extends:s}=t;s&&ca(e,s,n,!0),r&&r.forEach(o=>ca(e,o,n,!0));for(const o in t)if(!(i&&o==="expose")){const a=dg[o]||n&&n[o];e[o]=a?a(e[o],t[o]):t[o]}return e}const dg={data:Bu,props:Bi,emits:Bi,methods:Bi,computed:Bi,beforeCreate:St,created:St,beforeMount:St,mounted:St,beforeUpdate:St,updated:St,beforeDestroy:St,beforeUnmount:St,destroyed:St,unmounted:St,activated:St,deactivated:St,errorCaptured:St,serverPrefetch:St,components:Bi,directives:Bi,watch:pg,provide:Bu,inject:hg};function Bu(e,t){return t?e?function(){return wt(Oe(e)?e.call(this,this):e,Oe(t)?t.call(this,this):t)}:t:e}function hg(e,t){return Bi(Kl(e),Kl(t))}function Kl(e){if(Ae(e)){const t={};for(let n=0;n<e.length;n++)t[e[n]]=e[n];return t}return e}function St(e,t){return e?[...new Set([].concat(e,t))]:t}function Bi(e,t){return e?wt(wt(Object.create(null),e),t):t}function pg(e,t){if(!e)return t;if(!t)return e;const n=wt(Object.create(null),e);for(const i in t)n[i]=St(e[i],t[i]);return n}function mg(e,t,n,i=!1){const r={},s={};oa(s,Ua,1),e.propsDefaults=Object.create(null),Ah(e,t,r,s);for(const o in e.propsOptions[0])o in r||(r[o]=void 0);n?e.props=i?r:Am(r):e.type.props?e.props=r:e.props=s,e.attrs=s}function gg(e,t,n,i){const{props:r,attrs:s,vnode:{patchFlag:o}}=e,a=Ue(r),[l]=e.propsOptions;let c=!1;if((i||o>0)&&!(o&16)){if(o&8){const f=e.vnode.dynamicProps;for(let u=0;u<f.length;u++){let d=f[u];if(Oa(e.emitsOptions,d))continue;const h=t[d];if(l)if(ze(s,d))h!==s[d]&&(s[d]=h,c=!0);else{const p=Or(d);r[p]=Ql(l,a,p,h,e,!1)}else h!==s[d]&&(s[d]=h,c=!0)}}}else{Ah(e,t,r,s)&&(c=!0);let f;for(const u in a)(!t||!ze(t,u)&&((f=Zr(u))===u||!ze(t,f)))&&(l?n&&(n[u]!==void 0||n[f]!==void 0)&&(r[u]=Ql(l,a,u,void 0,e,!0)):delete r[u]);if(s!==a)for(const u in s)(!t||!ze(t,u)&&!0)&&(delete s[u],c=!0)}c&&Hn(e,"set","$attrs")}function Ah(e,t,n,i){const[r,s]=e.propsOptions;let o=!1,a;if(t)for(let l in t){if(ea(l))continue;const c=t[l];let f;r&&ze(r,f=Or(l))?!s||!s.includes(f)?n[f]=c:(a||(a={}))[f]=c:Oa(e.emitsOptions,l)||(!(l in i)||c!==i[l])&&(i[l]=c,o=!0)}if(s){const l=Ue(n),c=a||Je;for(let f=0;f<s.length;f++){const u=s[f];n[u]=Ql(r,l,u,c[u],e,!ze(c,u))}}return o}function Ql(e,t,n,i,r,s){const o=e[n];if(o!=null){const a=ze(o,"default");if(a&&i===void 0){const l=o.default;if(o.type!==Function&&Oe(l)){const{propsDefaults:c}=r;n in c?i=c[n]:(Fr(r),i=c[n]=l.call(null,t),Gi())}else i=l}o[0]&&(s&&!a?i=!1:o[1]&&(i===""||i===Zr(n))&&(i=!0))}return i}function Lh(e,t,n=!1){const i=t.propsCache,r=i.get(e);if(r)return r;const s=e.props,o={},a=[];let l=!1;if(!Oe(e)){const f=u=>{l=!0;const[d,h]=Lh(u,t,!0);wt(o,d),h&&a.push(...h)};!n&&t.mixins.length&&t.mixins.forEach(f),e.extends&&f(e.extends),e.mixins&&e.mixins.forEach(f)}if(!s&&!l)return $e(e)&&i.set(e,Er),Er;if(Ae(s))for(let f=0;f<s.length;f++){const u=Or(s[f]);zu(u)&&(o[u]=Je)}else if(s)for(const f in s){const u=Or(f);if(zu(u)){const d=s[f],h=o[u]=Ae(d)||Oe(d)?{type:d}:Object.assign({},d);if(h){const p=ku(Boolean,h.type),v=ku(String,h.type);h[0]=p>-1,h[1]=v<0||p<v,(p>-1||ze(h,"default"))&&a.push(u)}}}const c=[o,a];return $e(e)&&i.set(e,c),c}function zu(e){return e[0]!=="$"}function Uu(e){const t=e&&e.toString().match(/^\s*function (\w+)/);return t?t[1]:e===null?"null":""}function Hu(e,t){return Uu(e)===Uu(t)}function ku(e,t){return Ae(t)?t.findIndex(n=>Hu(n,e)):Oe(t)&&Hu(t,e)?0:-1}const Ch=e=>e[0]==="_"||e==="$stable",lu=e=>Ae(e)?e.map(_n):[_n(e)],vg=(e,t,n)=>{if(t._n)return t;const i=ms((...r)=>lu(t(...r)),n);return i._c=!1,i},Ph=(e,t,n)=>{const i=e._ctx;for(const r in e){if(Ch(r))continue;const s=e[r];if(Oe(s))t[r]=vg(r,s,i);else if(s!=null){const o=lu(s);t[r]=()=>o}}},Rh=(e,t)=>{const n=lu(t);e.slots.default=()=>n},yg=(e,t)=>{if(e.vnode.shapeFlag&32){const n=t._;n?(e.slots=Ue(t),oa(t,"_",n)):Ph(t,e.slots={})}else e.slots={},t&&Rh(e,t);oa(e.slots,Ua,1)},xg=(e,t,n)=>{const{vnode:i,slots:r}=e;let s=!0,o=Je;if(i.shapeFlag&32){const a=t._;a?n&&a===1?s=!1:(wt(r,t),!n&&a===1&&delete r._):(s=!t.$stable,Ph(t,r)),o=t}else t&&(Rh(e,t),o={default:1});if(s)for(const a in r)!Ch(a)&&!(a in o)&&delete r[a]};function Ih(){return{app:null,config:{isNativeTag:qp,performance:!1,globalProperties:{},optionMergeStrategies:{},errorHandler:void 0,warnHandler:void 0,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap,propsCache:new WeakMap,emitsCache:new WeakMap}}let _g=0;function bg(e,t){return function(i,r=null){Oe(i)||(i=Object.assign({},i)),r!=null&&!$e(r)&&(r=null);const s=Ih(),o=new Set;let a=!1;const l=s.app={_uid:_g++,_component:i,_props:r,_container:null,_context:s,_instance:null,version:Gg,get config(){return s.config},set config(c){},use(c,...f){return o.has(c)||(c&&Oe(c.install)?(o.add(c),c.install(l,...f)):Oe(c)&&(o.add(c),c(l,...f))),l},mixin(c){return s.mixins.includes(c)||s.mixins.push(c),l},component(c,f){return f?(s.components[c]=f,l):s.components[c]},directive(c,f){return f?(s.directives[c]=f,l):s.directives[c]},mount(c,f,u){if(!a){const d=mt(i,r);return d.appContext=s,f&&t?t(d,c):e(d,c,u),a=!0,l._container=c,c.__vue_app__=l,uu(d.component)||d.component.proxy}},unmount(){a&&(e(null,l._container),delete l._container.__vue_app__)},provide(c,f){return s.provides[c]=f,l}};return l}}function ec(e,t,n,i,r=!1){if(Ae(e)){e.forEach((d,h)=>ec(d,t&&(Ae(t)?t[h]:t),n,i,r));return}if(ta(i)&&!r)return;const s=i.shapeFlag&4?uu(i.component)||i.component.proxy:i.el,o=r?null:s,{i:a,r:l}=e,c=t&&t.r,f=a.refs===Je?a.refs={}:a.refs,u=a.setupState;if(c!=null&&c!==l&&(ut(c)?(f[c]=null,ze(u,c)&&(u[c]=null)):et(c)&&(c.value=null)),Oe(l))yi(l,a,12,[o,f]);else{const d=ut(l),h=et(l);if(d||h){const p=()=>{if(e.f){const v=d?ze(u,l)?u[l]:f[l]:l.value;r?Ae(v)&&qc(v,s):Ae(v)?v.includes(s)||v.push(s):d?(f[l]=[s],ze(u,l)&&(u[l]=f[l])):(l.value=[s],e.k&&(f[e.k]=l.value))}else d?(f[l]=o,ze(u,l)&&(u[l]=o)):h&&(l.value=o,e.k&&(f[e.k]=o))};o?(p.id=-1,At(p,n)):p()}}}const At=Jm;function wg(e){return Mg(e)}function Mg(e,t){const n=Kp();n.__VUE__=!0;const{insert:i,remove:r,patchProp:s,createElement:o,createText:a,createComment:l,setText:c,setElementText:f,parentNode:u,nextSibling:d,setScopeId:h=dn,insertStaticContent:p}=e,v=(x,_,L,F=null,O=null,b=null,w=!1,V=null,k=!!_.dynamicChildren)=>{if(x===_)return;x&&!Ui(x,_)&&(F=S(x),de(x,O,b,!0),x=null),_.patchFlag===-2&&(k=!1,_.dynamicChildren=null);const{type:C,ref:J,shapeFlag:Z}=_;switch(C){case za:y(x,_,L,F);break;case hn:m(x,_,L,F);break;case nl:x==null&&g(_,L,F,w);break;case an:j(x,_,L,F,O,b,w,V,k);break;default:Z&1?A(x,_,L,F,O,b,w,V,k):Z&6?Y(x,_,L,F,O,b,w,V,k):(Z&64||Z&128)&&C.process(x,_,L,F,O,b,w,V,k,R)}J!=null&&O&&ec(J,x&&x.ref,b,_||x,!_)},y=(x,_,L,F)=>{if(x==null)i(_.el=a(_.children),L,F);else{const O=_.el=x.el;_.children!==x.children&&c(O,_.children)}},m=(x,_,L,F)=>{x==null?i(_.el=l(_.children||""),L,F):_.el=x.el},g=(x,_,L,F)=>{[x.el,x.anchor]=p(x.children,_,L,F,x.el,x.anchor)},T=({el:x,anchor:_},L,F)=>{let O;for(;x&&x!==_;)O=d(x),i(x,L,F),x=O;i(_,L,F)},P=({el:x,anchor:_})=>{let L;for(;x&&x!==_;)L=d(x),r(x),x=L;r(_)},A=(x,_,L,F,O,b,w,V,k)=>{w=w||_.type==="svg",x==null?M(_,L,F,O,b,w,V,k):W(x,_,O,b,w,V,k)},M=(x,_,L,F,O,b,w,V)=>{let k,C;const{type:J,props:Z,shapeFlag:K,transition:Q,dirs:ae}=x;if(k=x.el=o(x.type,b,Z&&Z.is,Z),K&8?f(k,x.children):K&16&&B(x.children,k,null,F,O,b&&J!=="foreignObject",w,V),ae&&Pi(x,null,F,"created"),Z){for(const pe in Z)pe!=="value"&&!ea(pe)&&s(k,pe,null,Z[pe],b,x.children,F,O,E);"value"in Z&&s(k,"value",null,Z.value),(C=Z.onVnodeBeforeMount)&&vn(C,F,x)}N(k,x,x.scopeId,w,F),ae&&Pi(x,null,F,"beforeMount");const ue=(!O||O&&!O.pendingBranch)&&Q&&!Q.persisted;ue&&Q.beforeEnter(k),i(k,_,L),((C=Z&&Z.onVnodeMounted)||ue||ae)&&At(()=>{C&&vn(C,F,x),ue&&Q.enter(k),ae&&Pi(x,null,F,"mounted")},O)},N=(x,_,L,F,O)=>{if(L&&h(x,L),F)for(let b=0;b<F.length;b++)h(x,F[b]);if(O){let b=O.subTree;if(_===b){const w=O.vnode;N(x,w,w.scopeId,w.slotScopeIds,O.parent)}}},B=(x,_,L,F,O,b,w,V,k=0)=>{for(let C=k;C<x.length;C++){const J=x[C]=V?fi(x[C]):_n(x[C]);v(null,J,_,L,F,O,b,w,V)}},W=(x,_,L,F,O,b,w)=>{const V=_.el=x.el;let{patchFlag:k,dynamicChildren:C,dirs:J}=_;k|=x.patchFlag&16;const Z=x.props||Je,K=_.props||Je;let Q;L&&Ri(L,!1),(Q=K.onVnodeBeforeUpdate)&&vn(Q,L,_,x),J&&Pi(_,x,L,"beforeUpdate"),L&&Ri(L,!0);const ae=O&&_.type!=="foreignObject";if(C?te(x.dynamicChildren,C,V,L,F,ae,b):w||oe(x,_,V,null,L,F,ae,b,!1),k>0){if(k&16)H(V,_,Z,K,L,F,O);else if(k&2&&Z.class!==K.class&&s(V,"class",null,K.class,O),k&4&&s(V,"style",Z.style,K.style,O),k&8){const ue=_.dynamicProps;for(let pe=0;pe<ue.length;pe++){const ce=ue[pe],ye=Z[ce],Te=K[ce];(Te!==ye||ce==="value")&&s(V,ce,ye,Te,O,x.children,L,F,E)}}k&1&&x.children!==_.children&&f(V,_.children)}else!w&&C==null&&H(V,_,Z,K,L,F,O);((Q=K.onVnodeUpdated)||J)&&At(()=>{Q&&vn(Q,L,_,x),J&&Pi(_,x,L,"updated")},F)},te=(x,_,L,F,O,b,w)=>{for(let V=0;V<_.length;V++){const k=x[V],C=_[V],J=k.el&&(k.type===an||!Ui(k,C)||k.shapeFlag&70)?u(k.el):L;v(k,C,J,null,F,O,b,w,!0)}},H=(x,_,L,F,O,b,w)=>{if(L!==F){if(L!==Je)for(const V in L)!ea(V)&&!(V in F)&&s(x,V,L[V],null,w,_.children,O,b,E);for(const V in F){if(ea(V))continue;const k=F[V],C=L[V];k!==C&&V!=="value"&&s(x,V,C,k,w,_.children,O,b,E)}"value"in F&&s(x,"value",L.value,F.value)}},j=(x,_,L,F,O,b,w,V,k)=>{const C=_.el=x?x.el:a(""),J=_.anchor=x?x.anchor:a("");let{patchFlag:Z,dynamicChildren:K,slotScopeIds:Q}=_;Q&&(V=V?V.concat(Q):Q),x==null?(i(C,L,F),i(J,L,F),B(_.children,L,J,O,b,w,V,k)):Z>0&&Z&64&&K&&x.dynamicChildren?(te(x.dynamicChildren,K,L,O,b,w,V),(_.key!=null||O&&_===O.subTree)&&Oh(x,_,!0)):oe(x,_,L,J,O,b,w,V,k)},Y=(x,_,L,F,O,b,w,V,k)=>{_.slotScopeIds=V,x==null?_.shapeFlag&512?O.ctx.activate(_,L,F,w,k):X(_,L,F,O,b,w,k):q(x,_,k)},X=(x,_,L,F,O,b,w)=>{const V=x.component=Ng(x,F,O);if(Da(x)&&(V.ctx.renderer=R),Dg(V),V.asyncDep){if(O&&O.registerDep(V,$),!x.el){const k=V.subTree=mt(hn);m(null,k,_,L)}return}$(V,x,_,L,O,b,w)},q=(x,_,L)=>{const F=_.component=x.component;if(qm(x,_,L))if(F.asyncDep&&!F.asyncResolved){ne(F,_,L);return}else F.next=_,zm(F.update),F.update();else _.el=x.el,F.vnode=_},$=(x,_,L,F,O,b,w)=>{const V=()=>{if(x.isMounted){let{next:J,bu:Z,u:K,parent:Q,vnode:ae}=x,ue=J,pe;Ri(x,!1),J?(J.el=ae.el,ne(x,J,w)):J=ae,Z&&Ka(Z),(pe=J.props&&J.props.onVnodeBeforeUpdate)&&vn(pe,Q,J,ae),Ri(x,!0);const ce=Qa(x),ye=x.subTree;x.subTree=ce,v(ye,ce,u(ye.el),S(ye),x,O,b),J.el=ce.el,ue===null&&Xm(x,ce.el),K&&At(K,O),(pe=J.props&&J.props.onVnodeUpdated)&&At(()=>vn(pe,Q,J,ae),O)}else{let J;const{el:Z,props:K}=_,{bm:Q,m:ae,parent:ue}=x,pe=ta(_);if(Ri(x,!1),Q&&Ka(Q),!pe&&(J=K&&K.onVnodeBeforeMount)&&vn(J,ue,_),Ri(x,!0),Z&&G){const ce=()=>{x.subTree=Qa(x),G(Z,x.subTree,x,O,null)};pe?_.type.__asyncLoader().then(()=>!x.isUnmounted&&ce()):ce()}else{const ce=x.subTree=Qa(x);v(null,ce,L,F,x,O,b),_.el=ce.el}if(ae&&At(ae,O),!pe&&(J=K&&K.onVnodeMounted)){const ce=_;At(()=>vn(J,ue,ce),O)}(_.shapeFlag&256||ue&&ta(ue.vnode)&&ue.vnode.shapeFlag&256)&&x.a&&At(x.a,O),x.isMounted=!0,_=L=F=null}},k=x.effect=new Zc(V,()=>ru(C),x.scope),C=x.update=()=>k.run();C.id=x.uid,Ri(x,!0),C()},ne=(x,_,L)=>{_.component=x;const F=x.vnode.props;x.vnode=_,x.next=null,gg(x,_.props,F,L),xg(x,_.children,L),$r(),Ou(),Kr()},oe=(x,_,L,F,O,b,w,V,k=!1)=>{const C=x&&x.children,J=x?x.shapeFlag:0,Z=_.children,{patchFlag:K,shapeFlag:Q}=_;if(K>0){if(K&128){ge(C,Z,L,F,O,b,w,V,k);return}else if(K&256){fe(C,Z,L,F,O,b,w,V,k);return}}Q&8?(J&16&&E(C,O,b),Z!==C&&f(L,Z)):J&16?Q&16?ge(C,Z,L,F,O,b,w,V,k):E(C,O,b,!0):(J&8&&f(L,""),Q&16&&B(Z,L,F,O,b,w,V,k))},fe=(x,_,L,F,O,b,w,V,k)=>{x=x||Er,_=_||Er;const C=x.length,J=_.length,Z=Math.min(C,J);let K;for(K=0;K<Z;K++){const Q=_[K]=k?fi(_[K]):_n(_[K]);v(x[K],Q,L,null,O,b,w,V,k)}C>J?E(x,O,b,!0,!1,Z):B(_,L,F,O,b,w,V,k,Z)},ge=(x,_,L,F,O,b,w,V,k)=>{let C=0;const J=_.length;let Z=x.length-1,K=J-1;for(;C<=Z&&C<=K;){const Q=x[C],ae=_[C]=k?fi(_[C]):_n(_[C]);if(Ui(Q,ae))v(Q,ae,L,null,O,b,w,V,k);else break;C++}for(;C<=Z&&C<=K;){const Q=x[Z],ae=_[K]=k?fi(_[K]):_n(_[K]);if(Ui(Q,ae))v(Q,ae,L,null,O,b,w,V,k);else break;Z--,K--}if(C>Z){if(C<=K){const Q=K+1,ae=Q<J?_[Q].el:F;for(;C<=K;)v(null,_[C]=k?fi(_[C]):_n(_[C]),L,ae,O,b,w,V,k),C++}}else if(C>K)for(;C<=Z;)de(x[C],O,b,!0),C++;else{const Q=C,ae=C,ue=new Map;for(C=ae;C<=K;C++){const tt=_[C]=k?fi(_[C]):_n(_[C]);tt.key!=null&&ue.set(tt.key,C)}let pe,ce=0;const ye=K-ae+1;let Te=!1,Ke=0;const gt=new Array(ye);for(C=0;C<ye;C++)gt[C]=0;for(C=Q;C<=Z;C++){const tt=x[C];if(ce>=ye){de(tt,O,b,!0);continue}let ft;if(tt.key!=null)ft=ue.get(tt.key);else for(pe=ae;pe<=K;pe++)if(gt[pe-ae]===0&&Ui(tt,_[pe])){ft=pe;break}ft===void 0?de(tt,O,b,!0):(gt[ft-ae]=C+1,ft>=Ke?Ke=ft:Te=!0,v(tt,_[ft],L,null,O,b,w,V,k),ce++)}const $n=Te?Sg(gt):Er;for(pe=$n.length-1,C=ye-1;C>=0;C--){const tt=ae+C,ft=_[tt],Kn=tt+1<J?_[tt+1].el:F;gt[C]===0?v(null,ft,L,Kn,O,b,w,V,k):Te&&(pe<0||C!==$n[pe]?he(ft,L,Kn,2):pe--)}}},he=(x,_,L,F,O=null)=>{const{el:b,type:w,transition:V,children:k,shapeFlag:C}=x;if(C&6){he(x.component.subTree,_,L,F);return}if(C&128){x.suspense.move(_,L,F);return}if(C&64){w.move(x,_,L,R);return}if(w===an){i(b,_,L);for(let Z=0;Z<k.length;Z++)he(k[Z],_,L,F);i(x.anchor,_,L);return}if(w===nl){T(x,_,L);return}if(F!==2&&C&1&&V)if(F===0)V.beforeEnter(b),i(b,_,L),At(()=>V.enter(b),O);else{const{leave:Z,delayLeave:K,afterLeave:Q}=V,ae=()=>i(b,_,L),ue=()=>{Z(b,()=>{ae(),Q&&Q()})};K?K(b,ae,ue):ue()}else i(b,_,L)},de=(x,_,L,F=!1,O=!1)=>{const{type:b,props:w,ref:V,children:k,dynamicChildren:C,shapeFlag:J,patchFlag:Z,dirs:K}=x;if(V!=null&&ec(V,null,L,x,!0),J&256){_.ctx.deactivate(x);return}const Q=J&1&&K,ae=!ta(x);let ue;if(ae&&(ue=w&&w.onVnodeBeforeUnmount)&&vn(ue,_,x),J&6)se(x.component,L,F);else{if(J&128){x.suspense.unmount(L,F);return}Q&&Pi(x,null,_,"beforeUnmount"),J&64?x.type.remove(x,_,L,O,R,F):C&&(b!==an||Z>0&&Z&64)?E(C,_,L,!1,!0):(b===an&&Z&384||!O&&J&16)&&E(k,_,L),F&&Me(x)}(ae&&(ue=w&&w.onVnodeUnmounted)||Q)&&At(()=>{ue&&vn(ue,_,x),Q&&Pi(x,null,_,"unmounted")},L)},Me=x=>{const{type:_,el:L,anchor:F,transition:O}=x;if(_===an){ke(L,F);return}if(_===nl){P(x);return}const b=()=>{r(L),O&&!O.persisted&&O.afterLeave&&O.afterLeave()};if(x.shapeFlag&1&&O&&!O.persisted){const{leave:w,delayLeave:V}=O,k=()=>w(L,b);V?V(x.el,b,k):k()}else b()},ke=(x,_)=>{let L;for(;x!==_;)L=d(x),r(x),x=L;r(_)},se=(x,_,L)=>{const{bum:F,scope:O,update:b,subTree:w,um:V}=x;F&&Ka(F),O.stop(),b&&(b.active=!1,de(w,x,_,L)),V&&At(V,_),At(()=>{x.isUnmounted=!0},_),_&&_.pendingBranch&&!_.isUnmounted&&x.asyncDep&&!x.asyncResolved&&x.suspenseId===_.pendingId&&(_.deps--,_.deps===0&&_.resolve())},E=(x,_,L,F=!1,O=!1,b=0)=>{for(let w=b;w<x.length;w++)de(x[w],_,L,F,O)},S=x=>x.shapeFlag&6?S(x.component.subTree):x.shapeFlag&128?x.suspense.next():d(x.anchor||x.el),D=(x,_,L)=>{x==null?_._vnode&&de(_._vnode,null,null,!0):v(_._vnode||null,x,_,null,null,null,L),Ou(),gh(),_._vnode=x},R={p:v,um:de,m:he,r:Me,mt:X,mc:B,pc:oe,pbc:te,n:S,o:e};let U,G;return t&&([U,G]=t(R)),{render:D,hydrate:U,createApp:bg(D,U)}}function Ri({effect:e,update:t},n){e.allowRecurse=t.allowRecurse=n}function Oh(e,t,n=!1){const i=e.children,r=t.children;if(Ae(i)&&Ae(r))for(let s=0;s<i.length;s++){const o=i[s];let a=r[s];a.shapeFlag&1&&!a.dynamicChildren&&((a.patchFlag<=0||a.patchFlag===32)&&(a=r[s]=fi(r[s]),a.el=o.el),n||Oh(o,a)),a.type===za&&(a.el=o.el)}}function Sg(e){const t=e.slice(),n=[0];let i,r,s,o,a;const l=e.length;for(i=0;i<l;i++){const c=e[i];if(c!==0){if(r=n[n.length-1],e[r]<c){t[i]=r,n.push(i);continue}for(s=0,o=n.length-1;s<o;)a=s+o>>1,e[n[a]]<c?s=a+1:o=a;c<e[n[s]]&&(s>0&&(t[i]=n[s-1]),n[s]=i)}}for(s=n.length,o=n[s-1];s-- >0;)n[s]=o,o=t[o];return n}const Tg=e=>e.__isTeleport,an=Symbol(void 0),za=Symbol(void 0),hn=Symbol(void 0),nl=Symbol(void 0),bs=[];let fn=null;function na(e=!1){bs.push(fn=e?null:[])}function Eg(){bs.pop(),fn=bs[bs.length-1]||null}let Ds=1;function Gu(e){Ds+=e}function Nh(e){return e.dynamicChildren=Ds>0?fn||Er:null,Eg(),Ds>0&&fn&&fn.push(e),e}function il(e,t,n,i,r,s){return Nh($t(e,t,n,i,r,s,!0))}function Ag(e,t,n,i,r){return Nh(mt(e,t,n,i,r,!0))}function tc(e){return e?e.__v_isVNode===!0:!1}function Ui(e,t){return e.type===t.type&&e.key===t.key}const Ua="__vInternal",Dh=({key:e})=>e!=null?e:null,ia=({ref:e,ref_key:t,ref_for:n})=>e!=null?ut(e)||et(e)||Oe(e)?{i:un,r:e,k:t,f:!!n}:e:null;function $t(e,t=null,n=null,i=0,r=null,s=e===an?0:1,o=!1,a=!1){const l={__v_isVNode:!0,__v_skip:!0,type:e,props:t,key:t&&Dh(t),ref:t&&ia(t),scopeId:Na,slotScopeIds:null,children:n,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:s,patchFlag:i,dynamicProps:r,dynamicChildren:null,appContext:null,ctx:un};return a?(cu(l,n),s&128&&e.normalize(l)):n&&(l.shapeFlag|=ut(n)?8:16),Ds>0&&!o&&fn&&(l.patchFlag>0||s&6)&&l.patchFlag!==32&&fn.push(l),l}const mt=Lg;function Lg(e,t=null,n=null,i=0,r=null,s=!1){if((!e||e===lg)&&(e=hn),tc(e)){const a=Si(e,t,!0);return n&&cu(a,n),Ds>0&&!s&&fn&&(a.shapeFlag&6?fn[fn.indexOf(e)]=a:fn.push(a)),a.patchFlag|=-2,a}if(Ug(e)&&(e=e.__vccOpts),t){t=Cg(t);let{class:a,style:l}=t;a&&!ut(a)&&(t.class=Wc(a)),$e(l)&&(ch(l)&&!Ae(l)&&(l=wt({},l)),t.style=Vc(l))}const o=ut(e)?1:Ym(e)?128:Tg(e)?64:$e(e)?4:Oe(e)?2:0;return $t(e,t,n,i,r,o,s,!0)}function Cg(e){return e?ch(e)||Ua in e?wt({},e):e:null}function Si(e,t,n=!1){const{props:i,ref:r,patchFlag:s,children:o}=e,a=t?Rg(i||{},t):i;return{__v_isVNode:!0,__v_skip:!0,type:e.type,props:a,key:a&&Dh(a),ref:t&&t.ref?n&&r?Ae(r)?r.concat(ia(t)):[r,ia(t)]:ia(t):r,scopeId:e.scopeId,slotScopeIds:e.slotScopeIds,children:o,target:e.target,targetAnchor:e.targetAnchor,staticCount:e.staticCount,shapeFlag:e.shapeFlag,patchFlag:t&&e.type!==an?s===-1?16:s|16:s,dynamicProps:e.dynamicProps,dynamicChildren:e.dynamicChildren,appContext:e.appContext,dirs:e.dirs,transition:e.transition,component:e.component,suspense:e.suspense,ssContent:e.ssContent&&Si(e.ssContent),ssFallback:e.ssFallback&&Si(e.ssFallback),el:e.el,anchor:e.anchor,ctx:e.ctx}}function Pg(e=" ",t=0){return mt(za,null,e,t)}function Vu(e="",t=!1){return t?(na(),Ag(hn,null,e)):mt(hn,null,e)}function _n(e){return e==null||typeof e=="boolean"?mt(hn):Ae(e)?mt(an,null,e.slice()):typeof e=="object"?fi(e):mt(za,null,String(e))}function fi(e){return e.el===null&&e.patchFlag!==-1||e.memo?e:Si(e)}function cu(e,t){let n=0;const{shapeFlag:i}=e;if(t==null)t=null;else if(Ae(t))n=16;else if(typeof t=="object")if(i&65){const r=t.default;r&&(r._c&&(r._d=!1),cu(e,r()),r._c&&(r._d=!0));return}else{n=32;const r=t._;!r&&!(Ua in t)?t._ctx=un:r===3&&un&&(un.slots._===1?t._=1:(t._=2,e.patchFlag|=1024))}else Oe(t)?(t={default:t,_ctx:un},n=32):(t=String(t),i&64?(n=16,t=[Pg(t)]):n=8);e.children=t,e.shapeFlag|=n}function Rg(...e){const t={};for(let n=0;n<e.length;n++){const i=e[n];for(const r in i)if(r==="class")t.class!==i.class&&(t.class=Wc([t.class,i.class]));else if(r==="style")t.style=Vc([t.style,i.style]);else if(Aa(r)){const s=t[r],o=i[r];o&&s!==o&&!(Ae(s)&&s.includes(o))&&(t[r]=s?[].concat(s,o):o)}else r!==""&&(t[r]=i[r])}return t}function vn(e,t,n,i=null){Qt(e,t,7,[n,i])}const Ig=Ih();let Og=0;function Ng(e,t,n){const i=e.type,r=(t?t.appContext:e.appContext)||Ig,s={uid:Og++,vnode:e,type:i,parent:t,appContext:r,root:null,next:null,subTree:null,effect:null,update:null,scope:new Zd(!0),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:t?t.provides:Object.create(r.provides),accessCache:null,renderCache:[],components:null,directives:null,propsOptions:Lh(i,r),emitsOptions:yh(i,r),emit:null,emitted:null,propsDefaults:Je,inheritAttrs:i.inheritAttrs,ctx:Je,data:Je,props:Je,attrs:Je,slots:Je,refs:Je,setupState:Je,setupContext:null,suspense:n,suspenseId:n?n.pendingId:0,asyncDep:null,asyncResolved:!1,isMounted:!1,isUnmounted:!1,isDeactivated:!1,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};return s.ctx={_:s},s.root=t?t.root:s,s.emit=km.bind(null,s),e.ce&&e.ce(s),s}let pt=null;const Fh=()=>pt||un,Fr=e=>{pt=e,e.scope.on()},Gi=()=>{pt&&pt.scope.off(),pt=null};function Bh(e){return e.vnode.shapeFlag&4}let Fs=!1;function Dg(e,t=!1){Fs=t;const{props:n,children:i}=e.vnode,r=Bh(e);mg(e,n,r,t),yg(e,i);const s=r?Fg(e,t):void 0;return Fs=!1,s}function Fg(e,t){const n=e.type;e.accessCache=Object.create(null),e.proxy=Dr(new Proxy(e.ctx,cg));const{setup:i}=n;if(i){const r=e.setupContext=i.length>1?zg(e):null;Fr(e),$r();const s=yi(i,e,0,[e.props,r]);if(Kr(),Gi(),jd(s)){if(s.then(Gi,Gi),t)return s.then(o=>{Wu(e,o,t)}).catch(o=>{Ia(o,e,0)});e.asyncDep=s}else Wu(e,s,t)}else zh(e,t)}function Wu(e,t,n){Oe(t)?e.type.__ssrInlineRender?e.ssrRender=t:e.render=t:$e(t)&&(e.setupState=dh(t)),zh(e,n)}let ju;function zh(e,t,n){const i=e.type;if(!e.render){if(!t&&ju&&!i.render){const r=i.template||au(e).template;if(r){const{isCustomElement:s,compilerOptions:o}=e.appContext.config,{delimiters:a,compilerOptions:l}=i,c=wt(wt({isCustomElement:s,delimiters:a},o),l);i.render=ju(r,c)}}e.render=i.render||dn}Fr(e),$r(),ug(e),Kr(),Gi()}function Bg(e){return new Proxy(e.attrs,{get(t,n){return Vt(e,"get","$attrs"),t[n]}})}function zg(e){const t=i=>{e.exposed=i||{}};let n;return{get attrs(){return n||(n=Bg(e))},slots:e.slots,emit:e.emit,expose:t}}function uu(e){if(e.exposed)return e.exposeProxy||(e.exposeProxy=new Proxy(dh(Dr(e.exposed)),{get(t,n){if(n in t)return t[n];if(n in _s)return _s[n](e)},has(t,n){return n in t||n in _s}}))}function Ug(e){return Oe(e)&&"__vccOpts"in e}const Ha=(e,t)=>Dm(e,t,Fs);function ln(e,t,n){const i=arguments.length;return i===2?$e(t)&&!Ae(t)?tc(t)?mt(e,null,[t]):mt(e,t):mt(e,null,t):(i>3?n=Array.prototype.slice.call(arguments,2):i===3&&tc(n)&&(n=[n]),mt(e,t,n))}const Hg=Symbol(""),kg=()=>ys(Hg),Gg="3.2.45",Vg="http://www.w3.org/2000/svg",Hi=typeof document<"u"?document:null,qu=Hi&&Hi.createElement("template"),Wg={insert:(e,t,n)=>{t.insertBefore(e,n||null)},remove:e=>{const t=e.parentNode;t&&t.removeChild(e)},createElement:(e,t,n,i)=>{const r=t?Hi.createElementNS(Vg,e):Hi.createElement(e,n?{is:n}:void 0);return e==="select"&&i&&i.multiple!=null&&r.setAttribute("multiple",i.multiple),r},createText:e=>Hi.createTextNode(e),createComment:e=>Hi.createComment(e),setText:(e,t)=>{e.nodeValue=t},setElementText:(e,t)=>{e.textContent=t},parentNode:e=>e.parentNode,nextSibling:e=>e.nextSibling,querySelector:e=>Hi.querySelector(e),setScopeId(e,t){e.setAttribute(t,"")},insertStaticContent(e,t,n,i,r,s){const o=n?n.previousSibling:t.lastChild;if(r&&(r===s||r.nextSibling))for(;t.insertBefore(r.cloneNode(!0),n),!(r===s||!(r=r.nextSibling)););else{qu.innerHTML=i?`<svg>${e}</svg>`:e;const a=qu.content;if(i){const l=a.firstChild;for(;l.firstChild;)a.appendChild(l.firstChild);a.removeChild(l)}t.insertBefore(a,n)}return[o?o.nextSibling:t.firstChild,n?n.previousSibling:t.lastChild]}};function jg(e,t,n){const i=e._vtc;i&&(t=(t?[t,...i]:[...i]).join(" ")),t==null?e.removeAttribute("class"):n?e.setAttribute("class",t):e.className=t}function qg(e,t,n){const i=e.style,r=ut(n);if(n&&!r){for(const s in n)nc(i,s,n[s]);if(t&&!ut(t))for(const s in t)n[s]==null&&nc(i,s,"")}else{const s=i.display;r?t!==n&&(i.cssText=n):t&&e.removeAttribute("style"),"_vod"in e&&(i.display=s)}}const Xu=/\s*!important$/;function nc(e,t,n){if(Ae(n))n.forEach(i=>nc(e,t,i));else if(n==null&&(n=""),t.startsWith("--"))e.setProperty(t,n);else{const i=Xg(e,t);Xu.test(n)?e.setProperty(Zr(i),n.replace(Xu,""),"important"):e[i]=n}}const Yu=["Webkit","Moz","ms"],rl={};function Xg(e,t){const n=rl[t];if(n)return n;let i=Or(t);if(i!=="filter"&&i in e)return rl[t]=i;i=Yd(i);for(let r=0;r<Yu.length;r++){const s=Yu[r]+i;if(s in e)return rl[t]=s}return t}const Ju="http://www.w3.org/1999/xlink";function Yg(e,t,n,i,r){if(i&&t.startsWith("xlink:"))n==null?e.removeAttributeNS(Ju,t.slice(6,t.length)):e.setAttributeNS(Ju,t,n);else{const s=jp(t);n==null||s&&!Gd(n)?e.removeAttribute(t):e.setAttribute(t,s?"":n)}}function Jg(e,t,n,i,r,s,o){if(t==="innerHTML"||t==="textContent"){i&&o(i,r,s),e[t]=n==null?"":n;return}if(t==="value"&&e.tagName!=="PROGRESS"&&!e.tagName.includes("-")){e._value=n;const l=n==null?"":n;(e.value!==l||e.tagName==="OPTION")&&(e.value=l),n==null&&e.removeAttribute(t);return}let a=!1;if(n===""||n==null){const l=typeof e[t];l==="boolean"?n=Gd(n):n==null&&l==="string"?(n="",a=!0):l==="number"&&(n=0,a=!0)}try{e[t]=n}catch{}a&&e.removeAttribute(t)}function Zg(e,t,n,i){e.addEventListener(t,n,i)}function $g(e,t,n,i){e.removeEventListener(t,n,i)}function Kg(e,t,n,i,r=null){const s=e._vei||(e._vei={}),o=s[t];if(i&&o)o.value=i;else{const[a,l]=Qg(t);if(i){const c=s[t]=nv(i,r);Zg(e,a,c,l)}else o&&($g(e,a,o,l),s[t]=void 0)}}const Zu=/(?:Once|Passive|Capture)$/;function Qg(e){let t;if(Zu.test(e)){t={};let i;for(;i=e.match(Zu);)e=e.slice(0,e.length-i[0].length),t[i[0].toLowerCase()]=!0}return[e[2]===":"?e.slice(3):Zr(e.slice(2)),t]}let sl=0;const ev=Promise.resolve(),tv=()=>sl||(ev.then(()=>sl=0),sl=Date.now());function nv(e,t){const n=i=>{if(!i._vts)i._vts=Date.now();else if(i._vts<=n.attached)return;Qt(iv(i,n.value),t,5,[i])};return n.value=e,n.attached=tv(),n}function iv(e,t){if(Ae(t)){const n=e.stopImmediatePropagation;return e.stopImmediatePropagation=()=>{n.call(e),e._stopped=!0},t.map(i=>r=>!r._stopped&&i&&i(r))}else return t}const $u=/^on[a-z]/,rv=(e,t,n,i,r=!1,s,o,a,l)=>{t==="class"?jg(e,i,r):t==="style"?qg(e,n,i):Aa(t)?jc(t)||Kg(e,t,n,i,o):(t[0]==="."?(t=t.slice(1),!0):t[0]==="^"?(t=t.slice(1),!1):sv(e,t,i,r))?Jg(e,t,i,s,o,a,l):(t==="true-value"?e._trueValue=i:t==="false-value"&&(e._falseValue=i),Yg(e,t,i,r))};function sv(e,t,n,i){return i?!!(t==="innerHTML"||t==="textContent"||t in e&&$u.test(t)&&Oe(n)):t==="spellcheck"||t==="draggable"||t==="translate"||t==="form"||t==="list"&&e.tagName==="INPUT"||t==="type"&&e.tagName==="TEXTAREA"||$u.test(t)&&ut(n)?!1:t in e}const ov={name:String,type:String,css:{type:Boolean,default:!0},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};Qm.props;const av=wt({patchProp:rv},Wg);let Ku;function lv(){return Ku||(Ku=wg(av))}const cv=(...e)=>{const t=lv().createApp(...e),{mount:n}=t;return t.mount=i=>{const r=uv(i);if(!r)return;const s=t._component;!Oe(s)&&!s.render&&!s.template&&(s.template=r.innerHTML),r.innerHTML="";const o=n(r,!1,r instanceof SVGElement);return r instanceof Element&&(r.removeAttribute("v-cloak"),r.setAttribute("data-v-app","")),o},t};function uv(e){return ut(e)?document.querySelector(e):e}const fv="/assets/1.c58d1bc1.png",dv="/assets/2.d851f5fb.png",hv="/assets/3.37c8bb73.png",pv="124",mv=0,Qu=1,gv=2,Uh=1,vv=2,gs=3,no=0,ht=1,io=2,Hh=1,ws=0,Ms=1,ic=2,ef=3,tf=4,yv=5,vr=100,xv=101,_v=102,nf=103,rf=104,bv=200,wv=201,Mv=202,Sv=203,kh=204,Gh=205,Tv=206,Ev=207,Av=208,Lv=209,Cv=210,Pv=0,Rv=1,Iv=2,rc=3,Ov=4,Nv=5,Dv=6,Fv=7,ka=0,Bv=1,zv=2,Ss=0,Uv=1,Hv=2,kv=3,Gv=4,Vv=5,Vh=300,fu=301,du=302,sf=303,of=304,hu=306,pu=307,Un=1e3,Ct=1001,ua=1002,xt=1003,sc=1004,oc=1005,ct=1006,Wh=1007,Br=1008,mu=1009,Wv=1010,jv=1011,fa=1012,qv=1013,ra=1014,di=1015,da=1016,Xv=1017,Yv=1018,Jv=1019,Ts=1020,Zv=1021,xi=1022,pn=1023,$v=1024,Kv=1025,Cr=1026,Bs=1027,Qv=1028,ey=1029,ty=1030,ny=1031,iy=1032,ry=1033,af=33776,lf=33777,cf=33778,uf=33779,ff=35840,df=35841,hf=35842,pf=35843,sy=36196,mf=37492,gf=37496,oy=37808,ay=37809,ly=37810,cy=37811,uy=37812,fy=37813,dy=37814,hy=37815,py=37816,my=37817,gy=37818,vy=37819,yy=37820,xy=37821,_y=36492,by=37840,wy=37841,My=37842,Sy=37843,Ty=37844,Ey=37845,Ay=37846,Ly=37847,Cy=37848,Py=37849,Ry=37850,Iy=37851,Oy=37852,Ny=37853,Dy=2200,Fy=2201,By=2202,zs=2300,Pr=2301,ol=2302,_r=2400,br=2401,ha=2402,gu=2500,jh=2501,zy=0,Uy=1,vf=2,ro=3e3,Us=3001,Hy=3007,ky=3002,Gy=3003,Vy=3004,Wy=3005,jy=3006,qy=3200,Xy=3201,Zi=0,Yy=1,al=7680,Jy=519,Ga=35044,Hs=35048,yf="300 es";function Yn(){}Object.assign(Yn.prototype,{addEventListener:function(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)},hasEventListener:function(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1},removeEventListener:function(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}},dispatchEvent:function(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let r=0,s=i.length;r<s;r++)i[r].call(this,e)}}});const dt=[];for(let e=0;e<256;e++)dt[e]=(e<16?"0":"")+e.toString(16);let vo=1234567;const Ee={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function(){const e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0,i=Math.random()*4294967295|0;return(dt[e&255]+dt[e>>8&255]+dt[e>>16&255]+dt[e>>24&255]+"-"+dt[t&255]+dt[t>>8&255]+"-"+dt[t>>16&15|64]+dt[t>>24&255]+"-"+dt[n&63|128]+dt[n>>8&255]+"-"+dt[n>>16&255]+dt[n>>24&255]+dt[i&255]+dt[i>>8&255]+dt[i>>16&255]+dt[i>>24&255]).toUpperCase()},clamp:function(e,t,n){return Math.max(t,Math.min(n,e))},euclideanModulo:function(e,t){return(e%t+t)%t},mapLinear:function(e,t,n,i,r){return i+(e-t)*(r-i)/(n-t)},lerp:function(e,t,n){return(1-n)*e+n*t},smoothstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*(3-2*e))},smootherstep:function(e,t,n){return e<=t?0:e>=n?1:(e=(e-t)/(n-t),e*e*e*(e*(e*6-15)+10))},randInt:function(e,t){return e+Math.floor(Math.random()*(t-e+1))},randFloat:function(e,t){return e+Math.random()*(t-e)},randFloatSpread:function(e){return e*(.5-Math.random())},seededRandom:function(e){return e!==void 0&&(vo=e%2147483647),vo=vo*16807%2147483647,(vo-1)/2147483646},degToRad:function(e){return e*Ee.DEG2RAD},radToDeg:function(e){return e*Ee.RAD2DEG},isPowerOfTwo:function(e){return(e&e-1)===0&&e!==0},ceilPowerOfTwo:function(e){return Math.pow(2,Math.ceil(Math.log(e)/Math.LN2))},floorPowerOfTwo:function(e){return Math.pow(2,Math.floor(Math.log(e)/Math.LN2))},setQuaternionFromProperEuler:function(e,t,n,i,r){const s=Math.cos,o=Math.sin,a=s(n/2),l=o(n/2),c=s((t+i)/2),f=o((t+i)/2),u=s((t-i)/2),d=o((t-i)/2),h=s((i-t)/2),p=o((i-t)/2);switch(r){case"XYX":e.set(a*f,l*u,l*d,a*c);break;case"YZY":e.set(l*d,a*f,l*u,a*c);break;case"ZXZ":e.set(l*u,l*d,a*f,a*c);break;case"XZX":e.set(a*f,l*p,l*h,a*c);break;case"YXY":e.set(l*h,a*f,l*p,a*c);break;case"ZYZ":e.set(l*p,l*h,a*f,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}};class le{constructor(t=0,n=0){Object.defineProperty(this,"isVector2",{value:!0}),this.x=t,this.y=n}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,n){return this.x=t,this.y=n,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,n){switch(t){case 0:this.x=n;break;case 1:this.y=n;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t,n){return n!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,n)):(this.x+=t.x,this.y+=t.y,this)}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this}addScaledVector(t,n){return this.x+=t.x*n,this.y+=t.y*n,this}sub(t,n){return n!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,n)):(this.x-=t.x,this.y-=t.y,this)}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const n=this.x,i=this.y,r=t.elements;return this.x=r[0]*n+r[3]*i+r[6],this.y=r[1]*n+r[4]*i+r[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this}clampScalar(t,n){return this.x=Math.max(t,Math.min(n,this.x)),this.y=Math.max(t,Math.min(n,this.y)),this}clampLength(t,n){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(n,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const n=this.x-t.x,i=this.y-t.y;return n*n+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this}lerpVectors(t,n,i){return this.x=t.x+(n.x-t.x)*i,this.y=t.y+(n.y-t.y)*i,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,n=0){return this.x=t[n],this.y=t[n+1],this}toArray(t=[],n=0){return t[n]=this.x,t[n+1]=this.y,t}fromBufferAttribute(t,n,i){return i!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(n),this.y=t.getY(n),this}rotateAround(t,n){const i=Math.cos(n),r=Math.sin(n),s=this.x-t.x,o=this.y-t.y;return this.x=s*i-o*r+t.x,this.y=s*r+o*i+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}}class It{constructor(){Object.defineProperty(this,"isMatrix3",{value:!0}),this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,n,i,r,s,o,a,l,c){const f=this.elements;return f[0]=t,f[1]=r,f[2]=a,f[3]=n,f[4]=s,f[5]=l,f[6]=i,f[7]=o,f[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}clone(){return new this.constructor().fromArray(this.elements)}copy(t){const n=this.elements,i=t.elements;return n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=i[3],n[4]=i[4],n[5]=i[5],n[6]=i[6],n[7]=i[7],n[8]=i[8],this}extractBasis(t,n,i){return t.setFromMatrix3Column(this,0),n.setFromMatrix3Column(this,1),i.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const n=t.elements;return this.set(n[0],n[4],n[8],n[1],n[5],n[9],n[2],n[6],n[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,n){const i=t.elements,r=n.elements,s=this.elements,o=i[0],a=i[3],l=i[6],c=i[1],f=i[4],u=i[7],d=i[2],h=i[5],p=i[8],v=r[0],y=r[3],m=r[6],g=r[1],T=r[4],P=r[7],A=r[2],M=r[5],N=r[8];return s[0]=o*v+a*g+l*A,s[3]=o*y+a*T+l*M,s[6]=o*m+a*P+l*N,s[1]=c*v+f*g+u*A,s[4]=c*y+f*T+u*M,s[7]=c*m+f*P+u*N,s[2]=d*v+h*g+p*A,s[5]=d*y+h*T+p*M,s[8]=d*m+h*P+p*N,this}multiplyScalar(t){const n=this.elements;return n[0]*=t,n[3]*=t,n[6]*=t,n[1]*=t,n[4]*=t,n[7]*=t,n[2]*=t,n[5]*=t,n[8]*=t,this}determinant(){const t=this.elements,n=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],f=t[8];return n*o*f-n*a*c-i*s*f+i*a*l+r*s*c-r*o*l}invert(){const t=this.elements,n=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],f=t[8],u=f*o-a*c,d=a*l-f*s,h=c*s-o*l,p=n*u+i*d+r*h;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const v=1/p;return t[0]=u*v,t[1]=(r*c-f*i)*v,t[2]=(a*i-r*o)*v,t[3]=d*v,t[4]=(f*n-r*l)*v,t[5]=(r*s-a*n)*v,t[6]=h*v,t[7]=(i*l-c*n)*v,t[8]=(o*n-i*s)*v,this}transpose(){let t;const n=this.elements;return t=n[1],n[1]=n[3],n[3]=t,t=n[2],n[2]=n[6],n[6]=t,t=n[5],n[5]=n[7],n[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).copy(this).invert().transpose()}transposeIntoArray(t){const n=this.elements;return t[0]=n[0],t[1]=n[3],t[2]=n[6],t[3]=n[1],t[4]=n[4],t[5]=n[7],t[6]=n[2],t[7]=n[5],t[8]=n[8],this}setUvTransform(t,n,i,r,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(i*l,i*c,-i*(l*o+c*a)+o+t,-r*c,r*l,-r*(-c*o+l*a)+a+n,0,0,1),this}scale(t,n){const i=this.elements;return i[0]*=t,i[3]*=t,i[6]*=t,i[1]*=n,i[4]*=n,i[7]*=n,this}rotate(t){const n=Math.cos(t),i=Math.sin(t),r=this.elements,s=r[0],o=r[3],a=r[6],l=r[1],c=r[4],f=r[7];return r[0]=n*s+i*l,r[3]=n*o+i*c,r[6]=n*a+i*f,r[1]=-i*s+n*l,r[4]=-i*o+n*c,r[7]=-i*a+n*f,this}translate(t,n){const i=this.elements;return i[0]+=t*i[2],i[3]+=t*i[5],i[6]+=t*i[8],i[1]+=n*i[2],i[4]+=n*i[5],i[7]+=n*i[8],this}equals(t){const n=this.elements,i=t.elements;for(let r=0;r<9;r++)if(n[r]!==i[r])return!1;return!0}fromArray(t,n=0){for(let i=0;i<9;i++)this.elements[i]=t[i+n];return this}toArray(t=[],n=0){const i=this.elements;return t[n]=i[0],t[n+1]=i[1],t[n+2]=i[2],t[n+3]=i[3],t[n+4]=i[4],t[n+5]=i[5],t[n+6]=i[6],t[n+7]=i[7],t[n+8]=i[8],t}}let er;const Qr={getDataURL:function(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{er===void 0&&(er=document.createElementNS("http://www.w3.org/1999/xhtml","canvas")),er.width=e.width,er.height=e.height;const n=er.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=er}return t.width>2048||t.height>2048?t.toDataURL("image/jpeg",.6):t.toDataURL("image/png")}};let Zy=0;function qe(e=qe.DEFAULT_IMAGE,t=qe.DEFAULT_MAPPING,n=Ct,i=Ct,r=ct,s=Br,o=pn,a=mu,l=1,c=ro){Object.defineProperty(this,"id",{value:Zy++}),this.uuid=Ee.generateUUID(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=s,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=a,this.offset=new le(0,0),this.repeat=new le(1,1),this.center=new le(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new It,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=c,this.version=0,this.onUpdate=null}qe.DEFAULT_IMAGE=void 0;qe.DEFAULT_MAPPING=Vh;qe.prototype=Object.assign(Object.create(Yn.prototype),{constructor:qe,isTexture:!0,updateMatrix:function(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this},toJSON:function(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const i=this.image;if(i.uuid===void 0&&(i.uuid=Ee.generateUUID()),!t&&e.images[i.uuid]===void 0){let r;if(Array.isArray(i)){r=[];for(let s=0,o=i.length;s<o;s++)i[s].isDataTexture?r.push(ll(i[s].image)):r.push(ll(i[s]))}else r=ll(i);e.images[i.uuid]={uuid:i.uuid,url:r}}n.image=i.uuid}return t||(e.textures[this.uuid]=n),n},dispose:function(){this.dispatchEvent({type:"dispose"})},transformUv:function(e){if(this.mapping!==Vh)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Un:e.x=e.x-Math.floor(e.x);break;case Ct:e.x=e.x<0?0:1;break;case ua:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Un:e.y=e.y-Math.floor(e.y);break;case Ct:e.y=e.y<0?0:1;break;case ua:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}});Object.defineProperty(qe.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}});function ll(e){return typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap?Qr.getDataURL(e):e.data?{data:Array.prototype.slice.call(e.data),width:e.width,height:e.height,type:e.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class Ge{constructor(t=0,n=0,i=0,r=1){Object.defineProperty(this,"isVector4",{value:!0}),this.x=t,this.y=n,this.z=i,this.w=r}get width(){return this.z}set width(t){this.z=t}get height(){return this.w}set height(t){this.w=t}set(t,n,i,r){return this.x=t,this.y=n,this.z=i,this.w=r,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this.w=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setW(t){return this.w=t,this}setComponent(t,n){switch(t){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;case 3:this.w=n;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w!==void 0?t.w:1,this}add(t,n){return n!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,n)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this.w+=t,this}addVectors(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this.w=t.w+n.w,this}addScaledVector(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this.w+=t.w*n,this}sub(t,n){return n!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,n)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this.w-=t,this}subVectors(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this.w=t.w-n.w,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}applyMatrix4(t){const n=this.x,i=this.y,r=this.z,s=this.w,o=t.elements;return this.x=o[0]*n+o[4]*i+o[8]*r+o[12]*s,this.y=o[1]*n+o[5]*i+o[9]*r+o[13]*s,this.z=o[2]*n+o[6]*i+o[10]*r+o[14]*s,this.w=o[3]*n+o[7]*i+o[11]*r+o[15]*s,this}divideScalar(t){return this.multiplyScalar(1/t)}setAxisAngleFromQuaternion(t){this.w=2*Math.acos(t.w);const n=Math.sqrt(1-t.w*t.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=t.x/n,this.y=t.y/n,this.z=t.z/n),this}setAxisAngleFromRotationMatrix(t){let n,i,r,s;const l=t.elements,c=l[0],f=l[4],u=l[8],d=l[1],h=l[5],p=l[9],v=l[2],y=l[6],m=l[10];if(Math.abs(f-d)<.01&&Math.abs(u-v)<.01&&Math.abs(p-y)<.01){if(Math.abs(f+d)<.1&&Math.abs(u+v)<.1&&Math.abs(p+y)<.1&&Math.abs(c+h+m-3)<.1)return this.set(1,0,0,0),this;n=Math.PI;const T=(c+1)/2,P=(h+1)/2,A=(m+1)/2,M=(f+d)/4,N=(u+v)/4,B=(p+y)/4;return T>P&&T>A?T<.01?(i=0,r=.707106781,s=.707106781):(i=Math.sqrt(T),r=M/i,s=N/i):P>A?P<.01?(i=.707106781,r=0,s=.707106781):(r=Math.sqrt(P),i=M/r,s=B/r):A<.01?(i=.707106781,r=.707106781,s=0):(s=Math.sqrt(A),i=N/s,r=B/s),this.set(i,r,s,n),this}let g=Math.sqrt((y-p)*(y-p)+(u-v)*(u-v)+(d-f)*(d-f));return Math.abs(g)<.001&&(g=1),this.x=(y-p)/g,this.y=(u-v)/g,this.z=(d-f)/g,this.w=Math.acos((c+h+m-1)/2),this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this.w=Math.min(this.w,t.w),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this.w=Math.max(this.w,t.w),this}clamp(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this.z=Math.max(t.z,Math.min(n.z,this.z)),this.w=Math.max(t.w,Math.min(n.w,this.w)),this}clampScalar(t,n){return this.x=Math.max(t,Math.min(n,this.x)),this.y=Math.max(t,Math.min(n,this.y)),this.z=Math.max(t,Math.min(n,this.z)),this.w=Math.max(t,Math.min(n,this.w)),this}clampLength(t,n){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(n,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this.w+=(t.w-this.w)*n,this}lerpVectors(t,n,i){return this.x=t.x+(n.x-t.x)*i,this.y=t.y+(n.y-t.y)*i,this.z=t.z+(n.z-t.z)*i,this.w=t.w+(n.w-t.w)*i,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z&&t.w===this.w}fromArray(t,n=0){return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this.w=t[n+3],this}toArray(t=[],n=0){return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t[n+3]=this.w,t}fromBufferAttribute(t,n,i){return i!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(n),this.y=t.getY(n),this.z=t.getZ(n),this.w=t.getW(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}}function mn(e,t,n){this.width=e,this.height=t,this.scissor=new Ge(0,0,e,t),this.scissorTest=!1,this.viewport=new Ge(0,0,e,t),n=n||{},this.texture=new qe(void 0,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.encoding),this.texture.image={},this.texture.image.width=e,this.texture.image.height=t,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:ct,this.depthBuffer=n.depthBuffer!==void 0?n.depthBuffer:!0,this.stencilBuffer=n.stencilBuffer!==void 0?n.stencilBuffer:!1,this.depthTexture=n.depthTexture!==void 0?n.depthTexture:null}mn.prototype=Object.assign(Object.create(Yn.prototype),{constructor:mn,isWebGLRenderTarget:!0,setSize:function(e,t){(this.width!==e||this.height!==t)&&(this.width=e,this.height=t,this.texture.image.width=e,this.texture.image.height=t,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.width=e.width,this.height=e.height,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});function xf(e,t,n){mn.call(this,e,t,n),this.samples=4}xf.prototype=Object.assign(Object.create(mn.prototype),{constructor:xf,isWebGLMultisampleRenderTarget:!0,copy:function(e){return mn.prototype.copy.call(this,e),this.samples=e.samples,this}});class Gt{constructor(t=0,n=0,i=0,r=1){Object.defineProperty(this,"isQuaternion",{value:!0}),this._x=t,this._y=n,this._z=i,this._w=r}static slerp(t,n,i,r){return i.copy(t).slerp(n,r)}static slerpFlat(t,n,i,r,s,o,a){let l=i[r+0],c=i[r+1],f=i[r+2],u=i[r+3];const d=s[o+0],h=s[o+1],p=s[o+2],v=s[o+3];if(u!==v||l!==d||c!==h||f!==p){let y=1-a;const m=l*d+c*h+f*p+u*v,g=m>=0?1:-1,T=1-m*m;if(T>Number.EPSILON){const A=Math.sqrt(T),M=Math.atan2(A,m*g);y=Math.sin(y*M)/A,a=Math.sin(a*M)/A}const P=a*g;if(l=l*y+d*P,c=c*y+h*P,f=f*y+p*P,u=u*y+v*P,y===1-a){const A=1/Math.sqrt(l*l+c*c+f*f+u*u);l*=A,c*=A,f*=A,u*=A}}t[n]=l,t[n+1]=c,t[n+2]=f,t[n+3]=u}static multiplyQuaternionsFlat(t,n,i,r,s,o){const a=i[r],l=i[r+1],c=i[r+2],f=i[r+3],u=s[o],d=s[o+1],h=s[o+2],p=s[o+3];return t[n]=a*p+f*u+l*h-c*d,t[n+1]=l*p+f*d+c*u-a*h,t[n+2]=c*p+f*h+a*d-l*u,t[n+3]=f*p-a*u-l*d-c*h,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,n,i,r){return this._x=t,this._y=n,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,n){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,r=t._y,s=t._z,o=t._order,a=Math.cos,l=Math.sin,c=a(i/2),f=a(r/2),u=a(s/2),d=l(i/2),h=l(r/2),p=l(s/2);switch(o){case"XYZ":this._x=d*f*u+c*h*p,this._y=c*h*u-d*f*p,this._z=c*f*p+d*h*u,this._w=c*f*u-d*h*p;break;case"YXZ":this._x=d*f*u+c*h*p,this._y=c*h*u-d*f*p,this._z=c*f*p-d*h*u,this._w=c*f*u+d*h*p;break;case"ZXY":this._x=d*f*u-c*h*p,this._y=c*h*u+d*f*p,this._z=c*f*p+d*h*u,this._w=c*f*u-d*h*p;break;case"ZYX":this._x=d*f*u-c*h*p,this._y=c*h*u+d*f*p,this._z=c*f*p-d*h*u,this._w=c*f*u+d*h*p;break;case"YZX":this._x=d*f*u+c*h*p,this._y=c*h*u+d*f*p,this._z=c*f*p-d*h*u,this._w=c*f*u-d*h*p;break;case"XZY":this._x=d*f*u-c*h*p,this._y=c*h*u-d*f*p,this._z=c*f*p+d*h*u,this._w=c*f*u+d*h*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return n!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,n){const i=n/2,r=Math.sin(i);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const n=t.elements,i=n[0],r=n[4],s=n[8],o=n[1],a=n[5],l=n[9],c=n[2],f=n[6],u=n[10],d=i+a+u;if(d>0){const h=.5/Math.sqrt(d+1);this._w=.25/h,this._x=(f-l)*h,this._y=(s-c)*h,this._z=(o-r)*h}else if(i>a&&i>u){const h=2*Math.sqrt(1+i-a-u);this._w=(f-l)/h,this._x=.25*h,this._y=(r+o)/h,this._z=(s+c)/h}else if(a>u){const h=2*Math.sqrt(1+a-i-u);this._w=(s-c)/h,this._x=(r+o)/h,this._y=.25*h,this._z=(l+f)/h}else{const h=2*Math.sqrt(1+u-i-a);this._w=(o-r)/h,this._x=(s+c)/h,this._y=(l+f)/h,this._z=.25*h}return this._onChangeCallback(),this}setFromUnitVectors(t,n){let r=t.dot(n)+1;return r<1e-6?(r=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=r):(this._x=0,this._y=-t.z,this._z=t.y,this._w=r)):(this._x=t.y*n.z-t.z*n.y,this._y=t.z*n.x-t.x*n.z,this._z=t.x*n.y-t.y*n.x,this._w=r),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(Ee.clamp(this.dot(t),-1,1)))}rotateTowards(t,n){const i=this.angleTo(t);if(i===0)return this;const r=Math.min(1,n/i);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,n){return n!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,n)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,n){const i=t._x,r=t._y,s=t._z,o=t._w,a=n._x,l=n._y,c=n._z,f=n._w;return this._x=i*f+o*a+r*c-s*l,this._y=r*f+o*l+s*a-i*c,this._z=s*f+o*c+i*l-r*a,this._w=o*f-i*a-r*l-s*c,this._onChangeCallback(),this}slerp(t,n){if(n===0)return this;if(n===1)return this.copy(t);const i=this._x,r=this._y,s=this._z,o=this._w;let a=o*t._w+i*t._x+r*t._y+s*t._z;if(a<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,a=-a):this.copy(t),a>=1)return this._w=o,this._x=i,this._y=r,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const h=1-n;return this._w=h*o+n*this._w,this._x=h*i+n*this._x,this._y=h*r+n*this._y,this._z=h*s+n*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),f=Math.atan2(c,a),u=Math.sin((1-n)*f)/c,d=Math.sin(n*f)/c;return this._w=o*u+this._w*d,this._x=i*u+this._x*d,this._y=r*u+this._y*d,this._z=s*u+this._z*d,this._onChangeCallback(),this}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,n=0){return this._x=t[n],this._y=t[n+1],this._z=t[n+2],this._w=t[n+3],this._onChangeCallback(),this}toArray(t=[],n=0){return t[n]=this._x,t[n+1]=this._y,t[n+2]=this._z,t[n+3]=this._w,t}fromBufferAttribute(t,n){return this._x=t.getX(n),this._y=t.getY(n),this._z=t.getZ(n),this._w=t.getW(n),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}class z{constructor(t=0,n=0,i=0){Object.defineProperty(this,"isVector3",{value:!0}),this.x=t,this.y=n,this.z=i}set(t,n,i){return i===void 0&&(i=this.z),this.x=t,this.y=n,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,n){switch(t){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,n){return n!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,n)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,n){return this.x=t.x+n.x,this.y=t.y+n.y,this.z=t.z+n.z,this}addScaledVector(t,n){return this.x+=t.x*n,this.y+=t.y*n,this.z+=t.z*n,this}sub(t,n){return n!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,n)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,n){return this.x=t.x-n.x,this.y=t.y-n.y,this.z=t.z-n.z,this}multiply(t,n){return n!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,n)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,n){return this.x=t.x*n.x,this.y=t.y*n.y,this.z=t.z*n.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(_f.setFromEuler(t))}applyAxisAngle(t,n){return this.applyQuaternion(_f.setFromAxisAngle(t,n))}applyMatrix3(t){const n=this.x,i=this.y,r=this.z,s=t.elements;return this.x=s[0]*n+s[3]*i+s[6]*r,this.y=s[1]*n+s[4]*i+s[7]*r,this.z=s[2]*n+s[5]*i+s[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const n=this.x,i=this.y,r=this.z,s=t.elements,o=1/(s[3]*n+s[7]*i+s[11]*r+s[15]);return this.x=(s[0]*n+s[4]*i+s[8]*r+s[12])*o,this.y=(s[1]*n+s[5]*i+s[9]*r+s[13])*o,this.z=(s[2]*n+s[6]*i+s[10]*r+s[14])*o,this}applyQuaternion(t){const n=this.x,i=this.y,r=this.z,s=t.x,o=t.y,a=t.z,l=t.w,c=l*n+o*r-a*i,f=l*i+a*n-s*r,u=l*r+s*i-o*n,d=-s*n-o*i-a*r;return this.x=c*l+d*-s+f*-a-u*-o,this.y=f*l+d*-o+u*-s-c*-a,this.z=u*l+d*-a+c*-o-f*-s,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const n=this.x,i=this.y,r=this.z,s=t.elements;return this.x=s[0]*n+s[4]*i+s[8]*r,this.y=s[1]*n+s[5]*i+s[9]*r,this.z=s[2]*n+s[6]*i+s[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,n){return this.x=Math.max(t.x,Math.min(n.x,this.x)),this.y=Math.max(t.y,Math.min(n.y,this.y)),this.z=Math.max(t.z,Math.min(n.z,this.z)),this}clampScalar(t,n){return this.x=Math.max(t,Math.min(n,this.x)),this.y=Math.max(t,Math.min(n,this.y)),this.z=Math.max(t,Math.min(n,this.z)),this}clampLength(t,n){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(n,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,n){return this.x+=(t.x-this.x)*n,this.y+=(t.y-this.y)*n,this.z+=(t.z-this.z)*n,this}lerpVectors(t,n,i){return this.x=t.x+(n.x-t.x)*i,this.y=t.y+(n.y-t.y)*i,this.z=t.z+(n.z-t.z)*i,this}cross(t,n){return n!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,n)):this.crossVectors(this,t)}crossVectors(t,n){const i=t.x,r=t.y,s=t.z,o=n.x,a=n.y,l=n.z;return this.x=r*l-s*a,this.y=s*o-i*l,this.z=i*a-r*o,this}projectOnVector(t){const n=t.lengthSq();if(n===0)return this.set(0,0,0);const i=t.dot(this)/n;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return cl.copy(this).projectOnVector(t),this.sub(cl)}reflect(t){return this.sub(cl.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const n=Math.sqrt(this.lengthSq()*t.lengthSq());if(n===0)return Math.PI/2;const i=this.dot(t)/n;return Math.acos(Ee.clamp(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const n=this.x-t.x,i=this.y-t.y,r=this.z-t.z;return n*n+i*i+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,n,i){const r=Math.sin(n)*t;return this.x=r*Math.sin(i),this.y=Math.cos(n)*t,this.z=r*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,n,i){return this.x=t*Math.sin(n),this.y=i,this.z=t*Math.cos(n),this}setFromMatrixPosition(t){const n=t.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this}setFromMatrixScale(t){const n=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=n,this.y=i,this.z=r,this}setFromMatrixColumn(t,n){return this.fromArray(t.elements,n*4)}setFromMatrix3Column(t,n){return this.fromArray(t.elements,n*3)}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,n=0){return this.x=t[n],this.y=t[n+1],this.z=t[n+2],this}toArray(t=[],n=0){return t[n]=this.x,t[n+1]=this.y,t[n+2]=this.z,t}fromBufferAttribute(t,n,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(n),this.y=t.getY(n),this.z=t.getZ(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}}const cl=new z,_f=new Gt;class Jn{constructor(t,n){Object.defineProperty(this,"isBox3",{value:!0}),this.min=t!==void 0?t:new z(1/0,1/0,1/0),this.max=n!==void 0?n:new z(-1/0,-1/0,-1/0)}set(t,n){return this.min.copy(t),this.max.copy(n),this}setFromArray(t){let n=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=t.length;l<c;l+=3){const f=t[l],u=t[l+1],d=t[l+2];f<n&&(n=f),u<i&&(i=u),d<r&&(r=d),f>s&&(s=f),u>o&&(o=u),d>a&&(a=d)}return this.min.set(n,i,r),this.max.set(s,o,a),this}setFromBufferAttribute(t){let n=1/0,i=1/0,r=1/0,s=-1/0,o=-1/0,a=-1/0;for(let l=0,c=t.count;l<c;l++){const f=t.getX(l),u=t.getY(l),d=t.getZ(l);f<n&&(n=f),u<i&&(i=u),d<r&&(r=d),f>s&&(s=f),u>o&&(o=u),d>a&&(a=d)}return this.min.set(n,i,r),this.max.set(s,o,a),this}setFromPoints(t){this.makeEmpty();for(let n=0,i=t.length;n<i;n++)this.expandByPoint(t[n]);return this}setFromCenterAndSize(t,n){const i=ss.copy(n).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}setFromObject(t){return this.makeEmpty(),this.expandByObject(t)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return t===void 0&&(console.warn("THREE.Box3: .getCenter() target is now required"),t=new z),this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return t===void 0&&(console.warn("THREE.Box3: .getSize() target is now required"),t=new z),this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t){t.updateWorldMatrix(!1,!1);const n=t.geometry;n!==void 0&&(n.boundingBox===null&&n.computeBoundingBox(),fl.copy(n.boundingBox),fl.applyMatrix4(t.matrixWorld),this.union(fl));const i=t.children;for(let r=0,s=i.length;r<s;r++)this.expandByObject(i[r]);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,n){return n===void 0&&(console.warn("THREE.Box3: .getParameter() target is now required"),n=new z),n.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,ss),ss.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let n,i;return t.normal.x>0?(n=t.normal.x*this.min.x,i=t.normal.x*this.max.x):(n=t.normal.x*this.max.x,i=t.normal.x*this.min.x),t.normal.y>0?(n+=t.normal.y*this.min.y,i+=t.normal.y*this.max.y):(n+=t.normal.y*this.max.y,i+=t.normal.y*this.min.y),t.normal.z>0?(n+=t.normal.z*this.min.z,i+=t.normal.z*this.max.z):(n+=t.normal.z*this.max.z,i+=t.normal.z*this.min.z),n<=-t.constant&&i>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(os),yo.subVectors(this.max,os),tr.subVectors(t.a,os),nr.subVectors(t.b,os),ir.subVectors(t.c,os),ti.subVectors(nr,tr),ni.subVectors(ir,nr),Ii.subVectors(tr,ir);let n=[0,-ti.z,ti.y,0,-ni.z,ni.y,0,-Ii.z,Ii.y,ti.z,0,-ti.x,ni.z,0,-ni.x,Ii.z,0,-Ii.x,-ti.y,ti.x,0,-ni.y,ni.x,0,-Ii.y,Ii.x,0];return!ul(n,tr,nr,ir,yo)||(n=[1,0,0,0,1,0,0,0,1],!ul(n,tr,nr,ir,yo))?!1:(xo.crossVectors(ti,ni),n=[xo.x,xo.y,xo.z],ul(n,tr,nr,ir,yo))}clampPoint(t,n){return n===void 0&&(console.warn("THREE.Box3: .clampPoint() target is now required"),n=new z),n.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return ss.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return t===void 0&&console.error("THREE.Box3: .getBoundingSphere() target is now required"),this.getCenter(t.center),t.radius=this.getSize(ss).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(Rn[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),Rn[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),Rn[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),Rn[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),Rn[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),Rn[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),Rn[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),Rn[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(Rn),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}function ul(e,t,n,i,r){for(let s=0,o=e.length-3;s<=o;s+=3){Oi.fromArray(e,s);const a=r.x*Math.abs(Oi.x)+r.y*Math.abs(Oi.y)+r.z*Math.abs(Oi.z),l=t.dot(Oi),c=n.dot(Oi),f=i.dot(Oi);if(Math.max(-Math.max(l,c,f),Math.min(l,c,f))>a)return!1}return!0}const Rn=[new z,new z,new z,new z,new z,new z,new z,new z],ss=new z,fl=new Jn,tr=new z,nr=new z,ir=new z,ti=new z,ni=new z,Ii=new z,os=new z,yo=new z,xo=new z,Oi=new z,$y=new Jn;class Zn{constructor(t,n){this.center=t!==void 0?t:new z,this.radius=n!==void 0?n:-1}set(t,n){return this.center.copy(t),this.radius=n,this}setFromPoints(t,n){const i=this.center;n!==void 0?i.copy(n):$y.setFromPoints(t).getCenter(i);let r=0;for(let s=0,o=t.length;s<o;s++)r=Math.max(r,i.distanceToSquared(t[s]));return this.radius=Math.sqrt(r),this}clone(){return new this.constructor().copy(this)}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const n=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=n*n}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,n){const i=this.center.distanceToSquared(t);return n===void 0&&(console.warn("THREE.Sphere: .clampPoint() target is now required"),n=new z),n.copy(t),i>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n}getBoundingBox(t){return t===void 0&&(console.warn("THREE.Sphere: .getBoundingBox() target is now required"),t=new Jn),this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}}const In=new z,dl=new z,_o=new z,ii=new z,hl=new z,bo=new z,pl=new z;class so{constructor(t,n){this.origin=t!==void 0?t:new z,this.direction=n!==void 0?n:new z(0,0,-1)}set(t,n){return this.origin.copy(t),this.direction.copy(n),this}clone(){return new this.constructor().copy(this)}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,n){return n===void 0&&(console.warn("THREE.Ray: .at() target is now required"),n=new z),n.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,In)),this}closestPointToPoint(t,n){n===void 0&&(console.warn("THREE.Ray: .closestPointToPoint() target is now required"),n=new z),n.subVectors(t,this.origin);const i=n.dot(this.direction);return i<0?n.copy(this.origin):n.copy(this.direction).multiplyScalar(i).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const n=In.subVectors(t,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(t):(In.copy(this.direction).multiplyScalar(n).add(this.origin),In.distanceToSquared(t))}distanceSqToSegment(t,n,i,r){dl.copy(t).add(n).multiplyScalar(.5),_o.copy(n).sub(t).normalize(),ii.copy(this.origin).sub(dl);const s=t.distanceTo(n)*.5,o=-this.direction.dot(_o),a=ii.dot(this.direction),l=-ii.dot(_o),c=ii.lengthSq(),f=Math.abs(1-o*o);let u,d,h,p;if(f>0)if(u=o*l-a,d=o*a-l,p=s*f,u>=0)if(d>=-p)if(d<=p){const v=1/f;u*=v,d*=v,h=u*(u+o*d+2*a)+d*(o*u+d+2*l)+c}else d=s,u=Math.max(0,-(o*d+a)),h=-u*u+d*(d+2*l)+c;else d=-s,u=Math.max(0,-(o*d+a)),h=-u*u+d*(d+2*l)+c;else d<=-p?(u=Math.max(0,-(-o*s+a)),d=u>0?-s:Math.min(Math.max(-s,-l),s),h=-u*u+d*(d+2*l)+c):d<=p?(u=0,d=Math.min(Math.max(-s,-l),s),h=d*(d+2*l)+c):(u=Math.max(0,-(o*s+a)),d=u>0?s:Math.min(Math.max(-s,-l),s),h=-u*u+d*(d+2*l)+c);else d=o>0?-s:s,u=Math.max(0,-(o*d+a)),h=-u*u+d*(d+2*l)+c;return i&&i.copy(this.direction).multiplyScalar(u).add(this.origin),r&&r.copy(_o).multiplyScalar(d).add(dl),h}intersectSphere(t,n){In.subVectors(t.center,this.origin);const i=In.dot(this.direction),r=In.dot(In)-i*i,s=t.radius*t.radius;if(r>s)return null;const o=Math.sqrt(s-r),a=i-o,l=i+o;return a<0&&l<0?null:a<0?this.at(l,n):this.at(a,n)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const n=t.normal.dot(this.direction);if(n===0)return t.distanceToPoint(this.origin)===0?0:null;const i=-(this.origin.dot(t.normal)+t.constant)/n;return i>=0?i:null}intersectPlane(t,n){const i=this.distanceToPlane(t);return i===null?null:this.at(i,n)}intersectsPlane(t){const n=t.distanceToPoint(this.origin);return n===0||t.normal.dot(this.direction)*n<0}intersectBox(t,n){let i,r,s,o,a,l;const c=1/this.direction.x,f=1/this.direction.y,u=1/this.direction.z,d=this.origin;return c>=0?(i=(t.min.x-d.x)*c,r=(t.max.x-d.x)*c):(i=(t.max.x-d.x)*c,r=(t.min.x-d.x)*c),f>=0?(s=(t.min.y-d.y)*f,o=(t.max.y-d.y)*f):(s=(t.max.y-d.y)*f,o=(t.min.y-d.y)*f),i>o||s>r||((s>i||i!==i)&&(i=s),(o<r||r!==r)&&(r=o),u>=0?(a=(t.min.z-d.z)*u,l=(t.max.z-d.z)*u):(a=(t.max.z-d.z)*u,l=(t.min.z-d.z)*u),i>l||a>r)||((a>i||i!==i)&&(i=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(i>=0?i:r,n)}intersectsBox(t){return this.intersectBox(t,In)!==null}intersectTriangle(t,n,i,r,s){hl.subVectors(n,t),bo.subVectors(i,t),pl.crossVectors(hl,bo);let o=this.direction.dot(pl),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;ii.subVectors(this.origin,t);const l=a*this.direction.dot(bo.crossVectors(ii,bo));if(l<0)return null;const c=a*this.direction.dot(hl.cross(ii));if(c<0||l+c>o)return null;const f=-a*ii.dot(pl);return f<0?null:this.at(f/o,s)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}}class Le{constructor(){Object.defineProperty(this,"isMatrix4",{value:!0}),this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,n,i,r,s,o,a,l,c,f,u,d,h,p,v,y){const m=this.elements;return m[0]=t,m[4]=n,m[8]=i,m[12]=r,m[1]=s,m[5]=o,m[9]=a,m[13]=l,m[2]=c,m[6]=f,m[10]=u,m[14]=d,m[3]=h,m[7]=p,m[11]=v,m[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Le().fromArray(this.elements)}copy(t){const n=this.elements,i=t.elements;return n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=i[3],n[4]=i[4],n[5]=i[5],n[6]=i[6],n[7]=i[7],n[8]=i[8],n[9]=i[9],n[10]=i[10],n[11]=i[11],n[12]=i[12],n[13]=i[13],n[14]=i[14],n[15]=i[15],this}copyPosition(t){const n=this.elements,i=t.elements;return n[12]=i[12],n[13]=i[13],n[14]=i[14],this}extractBasis(t,n,i){return t.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),i.setFromMatrixColumn(this,2),this}makeBasis(t,n,i){return this.set(t.x,n.x,i.x,0,t.y,n.y,i.y,0,t.z,n.z,i.z,0,0,0,0,1),this}extractRotation(t){const n=this.elements,i=t.elements,r=1/rr.setFromMatrixColumn(t,0).length(),s=1/rr.setFromMatrixColumn(t,1).length(),o=1/rr.setFromMatrixColumn(t,2).length();return n[0]=i[0]*r,n[1]=i[1]*r,n[2]=i[2]*r,n[3]=0,n[4]=i[4]*s,n[5]=i[5]*s,n[6]=i[6]*s,n[7]=0,n[8]=i[8]*o,n[9]=i[9]*o,n[10]=i[10]*o,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const n=this.elements,i=t.x,r=t.y,s=t.z,o=Math.cos(i),a=Math.sin(i),l=Math.cos(r),c=Math.sin(r),f=Math.cos(s),u=Math.sin(s);if(t.order==="XYZ"){const d=o*f,h=o*u,p=a*f,v=a*u;n[0]=l*f,n[4]=-l*u,n[8]=c,n[1]=h+p*c,n[5]=d-v*c,n[9]=-a*l,n[2]=v-d*c,n[6]=p+h*c,n[10]=o*l}else if(t.order==="YXZ"){const d=l*f,h=l*u,p=c*f,v=c*u;n[0]=d+v*a,n[4]=p*a-h,n[8]=o*c,n[1]=o*u,n[5]=o*f,n[9]=-a,n[2]=h*a-p,n[6]=v+d*a,n[10]=o*l}else if(t.order==="ZXY"){const d=l*f,h=l*u,p=c*f,v=c*u;n[0]=d-v*a,n[4]=-o*u,n[8]=p+h*a,n[1]=h+p*a,n[5]=o*f,n[9]=v-d*a,n[2]=-o*c,n[6]=a,n[10]=o*l}else if(t.order==="ZYX"){const d=o*f,h=o*u,p=a*f,v=a*u;n[0]=l*f,n[4]=p*c-h,n[8]=d*c+v,n[1]=l*u,n[5]=v*c+d,n[9]=h*c-p,n[2]=-c,n[6]=a*l,n[10]=o*l}else if(t.order==="YZX"){const d=o*l,h=o*c,p=a*l,v=a*c;n[0]=l*f,n[4]=v-d*u,n[8]=p*u+h,n[1]=u,n[5]=o*f,n[9]=-a*f,n[2]=-c*f,n[6]=h*u+p,n[10]=d-v*u}else if(t.order==="XZY"){const d=o*l,h=o*c,p=a*l,v=a*c;n[0]=l*f,n[4]=-u,n[8]=c*f,n[1]=d*u+v,n[5]=o*f,n[9]=h*u-p,n[2]=p*u-h,n[6]=a*f,n[10]=v*u+d}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromQuaternion(t){return this.compose(Ky,t,Qy)}lookAt(t,n,i){const r=this.elements;return Ft.subVectors(t,n),Ft.lengthSq()===0&&(Ft.z=1),Ft.normalize(),ri.crossVectors(i,Ft),ri.lengthSq()===0&&(Math.abs(i.z)===1?Ft.x+=1e-4:Ft.z+=1e-4,Ft.normalize(),ri.crossVectors(i,Ft)),ri.normalize(),wo.crossVectors(Ft,ri),r[0]=ri.x,r[4]=wo.x,r[8]=Ft.x,r[1]=ri.y,r[5]=wo.y,r[9]=Ft.y,r[2]=ri.z,r[6]=wo.z,r[10]=Ft.z,this}multiply(t,n){return n!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,n)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,n){const i=t.elements,r=n.elements,s=this.elements,o=i[0],a=i[4],l=i[8],c=i[12],f=i[1],u=i[5],d=i[9],h=i[13],p=i[2],v=i[6],y=i[10],m=i[14],g=i[3],T=i[7],P=i[11],A=i[15],M=r[0],N=r[4],B=r[8],W=r[12],te=r[1],H=r[5],j=r[9],Y=r[13],X=r[2],q=r[6],$=r[10],ne=r[14],oe=r[3],fe=r[7],ge=r[11],he=r[15];return s[0]=o*M+a*te+l*X+c*oe,s[4]=o*N+a*H+l*q+c*fe,s[8]=o*B+a*j+l*$+c*ge,s[12]=o*W+a*Y+l*ne+c*he,s[1]=f*M+u*te+d*X+h*oe,s[5]=f*N+u*H+d*q+h*fe,s[9]=f*B+u*j+d*$+h*ge,s[13]=f*W+u*Y+d*ne+h*he,s[2]=p*M+v*te+y*X+m*oe,s[6]=p*N+v*H+y*q+m*fe,s[10]=p*B+v*j+y*$+m*ge,s[14]=p*W+v*Y+y*ne+m*he,s[3]=g*M+T*te+P*X+A*oe,s[7]=g*N+T*H+P*q+A*fe,s[11]=g*B+T*j+P*$+A*ge,s[15]=g*W+T*Y+P*ne+A*he,this}multiplyScalar(t){const n=this.elements;return n[0]*=t,n[4]*=t,n[8]*=t,n[12]*=t,n[1]*=t,n[5]*=t,n[9]*=t,n[13]*=t,n[2]*=t,n[6]*=t,n[10]*=t,n[14]*=t,n[3]*=t,n[7]*=t,n[11]*=t,n[15]*=t,this}determinant(){const t=this.elements,n=t[0],i=t[4],r=t[8],s=t[12],o=t[1],a=t[5],l=t[9],c=t[13],f=t[2],u=t[6],d=t[10],h=t[14],p=t[3],v=t[7],y=t[11],m=t[15];return p*(+s*l*u-r*c*u-s*a*d+i*c*d+r*a*h-i*l*h)+v*(+n*l*h-n*c*d+s*o*d-r*o*h+r*c*f-s*l*f)+y*(+n*c*u-n*a*h-s*o*u+i*o*h+s*a*f-i*c*f)+m*(-r*a*f-n*l*u+n*a*d+r*o*u-i*o*d+i*l*f)}transpose(){const t=this.elements;let n;return n=t[1],t[1]=t[4],t[4]=n,n=t[2],t[2]=t[8],t[8]=n,n=t[6],t[6]=t[9],t[9]=n,n=t[3],t[3]=t[12],t[12]=n,n=t[7],t[7]=t[13],t[13]=n,n=t[11],t[11]=t[14],t[14]=n,this}setPosition(t,n,i){const r=this.elements;return t.isVector3?(r[12]=t.x,r[13]=t.y,r[14]=t.z):(r[12]=t,r[13]=n,r[14]=i),this}invert(){const t=this.elements,n=t[0],i=t[1],r=t[2],s=t[3],o=t[4],a=t[5],l=t[6],c=t[7],f=t[8],u=t[9],d=t[10],h=t[11],p=t[12],v=t[13],y=t[14],m=t[15],g=u*y*c-v*d*c+v*l*h-a*y*h-u*l*m+a*d*m,T=p*d*c-f*y*c-p*l*h+o*y*h+f*l*m-o*d*m,P=f*v*c-p*u*c+p*a*h-o*v*h-f*a*m+o*u*m,A=p*u*l-f*v*l-p*a*d+o*v*d+f*a*y-o*u*y,M=n*g+i*T+r*P+s*A;if(M===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const N=1/M;return t[0]=g*N,t[1]=(v*d*s-u*y*s-v*r*h+i*y*h+u*r*m-i*d*m)*N,t[2]=(a*y*s-v*l*s+v*r*c-i*y*c-a*r*m+i*l*m)*N,t[3]=(u*l*s-a*d*s-u*r*c+i*d*c+a*r*h-i*l*h)*N,t[4]=T*N,t[5]=(f*y*s-p*d*s+p*r*h-n*y*h-f*r*m+n*d*m)*N,t[6]=(p*l*s-o*y*s-p*r*c+n*y*c+o*r*m-n*l*m)*N,t[7]=(o*d*s-f*l*s+f*r*c-n*d*c-o*r*h+n*l*h)*N,t[8]=P*N,t[9]=(p*u*s-f*v*s-p*i*h+n*v*h+f*i*m-n*u*m)*N,t[10]=(o*v*s-p*a*s+p*i*c-n*v*c-o*i*m+n*a*m)*N,t[11]=(f*a*s-o*u*s-f*i*c+n*u*c+o*i*h-n*a*h)*N,t[12]=A*N,t[13]=(f*v*r-p*u*r+p*i*d-n*v*d-f*i*y+n*u*y)*N,t[14]=(p*a*r-o*v*r-p*i*l+n*v*l+o*i*y-n*a*y)*N,t[15]=(o*u*r-f*a*r+f*i*l-n*u*l-o*i*d+n*a*d)*N,this}scale(t){const n=this.elements,i=t.x,r=t.y,s=t.z;return n[0]*=i,n[4]*=r,n[8]*=s,n[1]*=i,n[5]*=r,n[9]*=s,n[2]*=i,n[6]*=r,n[10]*=s,n[3]*=i,n[7]*=r,n[11]*=s,this}getMaxScaleOnAxis(){const t=this.elements,n=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],i=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],r=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(n,i,r))}makeTranslation(t,n,i){return this.set(1,0,0,t,0,1,0,n,0,0,1,i,0,0,0,1),this}makeRotationX(t){const n=Math.cos(t),i=Math.sin(t);return this.set(1,0,0,0,0,n,-i,0,0,i,n,0,0,0,0,1),this}makeRotationY(t){const n=Math.cos(t),i=Math.sin(t);return this.set(n,0,i,0,0,1,0,0,-i,0,n,0,0,0,0,1),this}makeRotationZ(t){const n=Math.cos(t),i=Math.sin(t);return this.set(n,-i,0,0,i,n,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,n){const i=Math.cos(n),r=Math.sin(n),s=1-i,o=t.x,a=t.y,l=t.z,c=s*o,f=s*a;return this.set(c*o+i,c*a-r*l,c*l+r*a,0,c*a+r*l,f*a+i,f*l-r*o,0,c*l-r*a,f*l+r*o,s*l*l+i,0,0,0,0,1),this}makeScale(t,n,i){return this.set(t,0,0,0,0,n,0,0,0,0,i,0,0,0,0,1),this}makeShear(t,n,i){return this.set(1,n,i,0,t,1,i,0,t,n,1,0,0,0,0,1),this}compose(t,n,i){const r=this.elements,s=n._x,o=n._y,a=n._z,l=n._w,c=s+s,f=o+o,u=a+a,d=s*c,h=s*f,p=s*u,v=o*f,y=o*u,m=a*u,g=l*c,T=l*f,P=l*u,A=i.x,M=i.y,N=i.z;return r[0]=(1-(v+m))*A,r[1]=(h+P)*A,r[2]=(p-T)*A,r[3]=0,r[4]=(h-P)*M,r[5]=(1-(d+m))*M,r[6]=(y+g)*M,r[7]=0,r[8]=(p+T)*N,r[9]=(y-g)*N,r[10]=(1-(d+v))*N,r[11]=0,r[12]=t.x,r[13]=t.y,r[14]=t.z,r[15]=1,this}decompose(t,n,i){const r=this.elements;let s=rr.set(r[0],r[1],r[2]).length();const o=rr.set(r[4],r[5],r[6]).length(),a=rr.set(r[8],r[9],r[10]).length();this.determinant()<0&&(s=-s),t.x=r[12],t.y=r[13],t.z=r[14],nn.copy(this);const c=1/s,f=1/o,u=1/a;return nn.elements[0]*=c,nn.elements[1]*=c,nn.elements[2]*=c,nn.elements[4]*=f,nn.elements[5]*=f,nn.elements[6]*=f,nn.elements[8]*=u,nn.elements[9]*=u,nn.elements[10]*=u,n.setFromRotationMatrix(nn),i.x=s,i.y=o,i.z=a,this}makePerspective(t,n,i,r,s,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*s/(n-t),c=2*s/(i-r),f=(n+t)/(n-t),u=(i+r)/(i-r),d=-(o+s)/(o-s),h=-2*o*s/(o-s);return a[0]=l,a[4]=0,a[8]=f,a[12]=0,a[1]=0,a[5]=c,a[9]=u,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=h,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(t,n,i,r,s,o){const a=this.elements,l=1/(n-t),c=1/(i-r),f=1/(o-s),u=(n+t)*l,d=(i+r)*c,h=(o+s)*f;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-u,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*f,a[14]=-h,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(t){const n=this.elements,i=t.elements;for(let r=0;r<16;r++)if(n[r]!==i[r])return!1;return!0}fromArray(t,n=0){for(let i=0;i<16;i++)this.elements[i]=t[i+n];return this}toArray(t=[],n=0){const i=this.elements;return t[n]=i[0],t[n+1]=i[1],t[n+2]=i[2],t[n+3]=i[3],t[n+4]=i[4],t[n+5]=i[5],t[n+6]=i[6],t[n+7]=i[7],t[n+8]=i[8],t[n+9]=i[9],t[n+10]=i[10],t[n+11]=i[11],t[n+12]=i[12],t[n+13]=i[13],t[n+14]=i[14],t[n+15]=i[15],t}}const rr=new z,nn=new Le,Ky=new z(0,0,0),Qy=new z(1,1,1),ri=new z,wo=new z,Ft=new z;class oo{constructor(t=0,n=0,i=0,r=oo.DefaultOrder){Object.defineProperty(this,"isEuler",{value:!0}),this._x=t,this._y=n,this._z=i,this._order=r}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get order(){return this._order}set order(t){this._order=t,this._onChangeCallback()}set(t,n,i,r){return this._x=t,this._y=n,this._z=i,this._order=r||this._order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(t){return this._x=t._x,this._y=t._y,this._z=t._z,this._order=t._order,this._onChangeCallback(),this}setFromRotationMatrix(t,n,i){const r=Ee.clamp,s=t.elements,o=s[0],a=s[4],l=s[8],c=s[1],f=s[5],u=s[9],d=s[2],h=s[6],p=s[10];switch(n=n||this._order,n){case"XYZ":this._y=Math.asin(r(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-a,o)):(this._x=Math.atan2(h,f),this._z=0);break;case"YXZ":this._x=Math.asin(-r(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(l,p),this._z=Math.atan2(c,f)):(this._y=Math.atan2(-d,o),this._z=0);break;case"ZXY":this._x=Math.asin(r(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(-d,p),this._z=Math.atan2(-a,f)):(this._y=0,this._z=Math.atan2(c,o));break;case"ZYX":this._y=Math.asin(-r(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(h,p),this._z=Math.atan2(c,o)):(this._x=0,this._z=Math.atan2(-a,f));break;case"YZX":this._z=Math.asin(r(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-u,f),this._y=Math.atan2(-d,o)):(this._x=0,this._y=Math.atan2(l,p));break;case"XZY":this._z=Math.asin(-r(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(h,f),this._y=Math.atan2(l,o)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+n)}return this._order=n,i!==!1&&this._onChangeCallback(),this}setFromQuaternion(t,n,i){return bf.makeRotationFromQuaternion(t),this.setFromRotationMatrix(bf,n,i)}setFromVector3(t,n){return this.set(t.x,t.y,t.z,n||this._order)}reorder(t){return wf.setFromEuler(this),this.setFromQuaternion(wf,t)}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._order===this._order}fromArray(t){return this._x=t[0],this._y=t[1],this._z=t[2],t[3]!==void 0&&(this._order=t[3]),this._onChangeCallback(),this}toArray(t=[],n=0){return t[n]=this._x,t[n+1]=this._y,t[n+2]=this._z,t[n+3]=this._order,t}toVector3(t){return t?t.set(this._x,this._y,this._z):new z(this._x,this._y,this._z)}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}}oo.DefaultOrder="XYZ";oo.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];const bf=new Le,wf=new Gt;class qh{constructor(){this.mask=1}set(t){this.mask=1<<t|0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return(this.mask&t.mask)!==0}}let ex=0;const Mf=new z,sr=new Gt,On=new Le,Mo=new z,as=new z,tx=new z,nx=new Gt,Sf=new z(1,0,0),Tf=new z(0,1,0),Ef=new z(0,0,1),ix={type:"added"},Af={type:"removed"};function be(){Object.defineProperty(this,"id",{value:ex++}),this.uuid=Ee.generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=be.DefaultUp.clone();const e=new z,t=new oo,n=new Gt,i=new z(1,1,1);function r(){n.setFromEuler(t,!1)}function s(){t.setFromQuaternion(n,void 0,!1)}t._onChange(r),n._onChange(s),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Le},normalMatrix:{value:new It}}),this.matrix=new Le,this.matrixWorld=new Le,this.matrixAutoUpdate=be.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new qh,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}be.DefaultUp=new z(0,1,0);be.DefaultMatrixAutoUpdate=!0;be.prototype=Object.assign(Object.create(Yn.prototype),{constructor:be,isObject3D:!0,onBeforeRender:function(){},onAfterRender:function(){},applyMatrix4:function(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)},applyQuaternion:function(e){return this.quaternion.premultiply(e),this},setRotationFromAxisAngle:function(e,t){this.quaternion.setFromAxisAngle(e,t)},setRotationFromEuler:function(e){this.quaternion.setFromEuler(e,!0)},setRotationFromMatrix:function(e){this.quaternion.setFromRotationMatrix(e)},setRotationFromQuaternion:function(e){this.quaternion.copy(e)},rotateOnAxis:function(e,t){return sr.setFromAxisAngle(e,t),this.quaternion.multiply(sr),this},rotateOnWorldAxis:function(e,t){return sr.setFromAxisAngle(e,t),this.quaternion.premultiply(sr),this},rotateX:function(e){return this.rotateOnAxis(Sf,e)},rotateY:function(e){return this.rotateOnAxis(Tf,e)},rotateZ:function(e){return this.rotateOnAxis(Ef,e)},translateOnAxis:function(e,t){return Mf.copy(e).applyQuaternion(this.quaternion),this.position.add(Mf.multiplyScalar(t)),this},translateX:function(e){return this.translateOnAxis(Sf,e)},translateY:function(e){return this.translateOnAxis(Tf,e)},translateZ:function(e){return this.translateOnAxis(Ef,e)},localToWorld:function(e){return e.applyMatrix4(this.matrixWorld)},worldToLocal:function(e){return e.applyMatrix4(On.copy(this.matrixWorld).invert())},lookAt:function(e,t,n){e.isVector3?Mo.copy(e):Mo.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),as.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?On.lookAt(as,Mo,this.up):On.lookAt(Mo,as,this.up),this.quaternion.setFromRotationMatrix(On),i&&(On.extractRotation(i.matrixWorld),sr.setFromRotationMatrix(On),this.quaternion.premultiply(sr.invert()))},add:function(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(ix)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)},remove:function(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Af)),this},clear:function(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(Af)}return this.children.length=0,this},attach:function(e){return this.updateWorldMatrix(!0,!1),On.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),On.multiply(e.parent.matrixWorld)),e.applyMatrix4(On),e.updateWorldMatrix(!1,!1),this.add(e),this},getObjectById:function(e){return this.getObjectByProperty("id",e)},getObjectByName:function(e){return this.getObjectByProperty("name",e)},getObjectByProperty:function(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const s=this.children[n].getObjectByProperty(e,t);if(s!==void 0)return s}},getWorldPosition:function(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldPosition() target is now required"),e=new z),this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)},getWorldQuaternion:function(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"),e=new Gt),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(as,e,tx),e},getWorldScale:function(e){return e===void 0&&(console.warn("THREE.Object3D: .getWorldScale() target is now required"),e=new z),this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(as,nx,e),e},getWorldDirection:function(e){e===void 0&&(console.warn("THREE.Object3D: .getWorldDirection() target is now required"),e=new z),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()},raycast:function(){},traverse:function(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)},traverseVisible:function(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)},traverseAncestors:function(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)},updateWorldMatrix:function(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let r=0,s=i.length;r<s;r++)i[r].updateWorldMatrix(!1,!0)}},toJSON:function(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},n.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON());function r(o,a){return o[a.uuid]===void 0&&(o[a.uuid]=a.toJSON(e)),a.uuid}if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const a=o.shapes;if(Array.isArray(a))for(let l=0,c=a.length;l<c;l++){const f=a[l];r(e.shapes,f)}else r(e.shapes,a)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let a=0,l=this.material.length;a<l;a++)o.push(r(e.materials,this.material[a]));i.material=o}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const a=this.animations[o];i.animations.push(r(e.animations,a))}}if(t){const o=s(e.geometries),a=s(e.materials),l=s(e.textures),c=s(e.images),f=s(e.shapes),u=s(e.skeletons),d=s(e.animations);o.length>0&&(n.geometries=o),a.length>0&&(n.materials=a),l.length>0&&(n.textures=l),c.length>0&&(n.images=c),f.length>0&&(n.shapes=f),u.length>0&&(n.skeletons=u),d.length>0&&(n.animations=d)}return n.object=i,n;function s(o){const a=[];for(const l in o){const c=o[l];delete c.metadata,a.push(c)}return a}},clone:function(e){return new this.constructor().copy(this,e)},copy:function(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}});const ml=new z,rx=new z,sx=new It;class Bn{constructor(t,n){Object.defineProperty(this,"isPlane",{value:!0}),this.normal=t!==void 0?t:new z(1,0,0),this.constant=n!==void 0?n:0}set(t,n){return this.normal.copy(t),this.constant=n,this}setComponents(t,n,i,r){return this.normal.set(t,n,i),this.constant=r,this}setFromNormalAndCoplanarPoint(t,n){return this.normal.copy(t),this.constant=-n.dot(this.normal),this}setFromCoplanarPoints(t,n,i){const r=ml.subVectors(i,n).cross(rx.subVectors(t,n)).normalize();return this.setFromNormalAndCoplanarPoint(r,t),this}clone(){return new this.constructor().copy(this)}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,n){return n===void 0&&(console.warn("THREE.Plane: .projectPoint() target is now required"),n=new z),n.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,n){n===void 0&&(console.warn("THREE.Plane: .intersectLine() target is now required"),n=new z);const i=t.delta(ml),r=this.normal.dot(i);if(r===0)return this.distanceToPoint(t.start)===0?n.copy(t.start):void 0;const s=-(t.start.dot(this.normal)+this.constant)/r;if(!(s<0||s>1))return n.copy(i).multiplyScalar(s).add(t.start)}intersectsLine(t){const n=this.distanceToPoint(t.start),i=this.distanceToPoint(t.end);return n<0&&i>0||i<0&&n>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t===void 0&&(console.warn("THREE.Plane: .coplanarPoint() target is now required"),t=new z),t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,n){const i=n||sx.getNormalMatrix(t),r=this.coplanarPoint(ml).applyMatrix4(t),s=this.normal.applyMatrix3(i).normalize();return this.constant=-r.dot(s),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}}const rn=new z,Nn=new z,gl=new z,Dn=new z,or=new z,ar=new z,Lf=new z,vl=new z,yl=new z,xl=new z;class _t{constructor(t,n,i){this.a=t!==void 0?t:new z,this.b=n!==void 0?n:new z,this.c=i!==void 0?i:new z}static getNormal(t,n,i,r){r===void 0&&(console.warn("THREE.Triangle: .getNormal() target is now required"),r=new z),r.subVectors(i,n),rn.subVectors(t,n),r.cross(rn);const s=r.lengthSq();return s>0?r.multiplyScalar(1/Math.sqrt(s)):r.set(0,0,0)}static getBarycoord(t,n,i,r,s){rn.subVectors(r,n),Nn.subVectors(i,n),gl.subVectors(t,n);const o=rn.dot(rn),a=rn.dot(Nn),l=rn.dot(gl),c=Nn.dot(Nn),f=Nn.dot(gl),u=o*c-a*a;if(s===void 0&&(console.warn("THREE.Triangle: .getBarycoord() target is now required"),s=new z),u===0)return s.set(-2,-1,-1);const d=1/u,h=(c*l-a*f)*d,p=(o*f-a*l)*d;return s.set(1-h-p,p,h)}static containsPoint(t,n,i,r){return this.getBarycoord(t,n,i,r,Dn),Dn.x>=0&&Dn.y>=0&&Dn.x+Dn.y<=1}static getUV(t,n,i,r,s,o,a,l){return this.getBarycoord(t,n,i,r,Dn),l.set(0,0),l.addScaledVector(s,Dn.x),l.addScaledVector(o,Dn.y),l.addScaledVector(a,Dn.z),l}static isFrontFacing(t,n,i,r){return rn.subVectors(i,n),Nn.subVectors(t,n),rn.cross(Nn).dot(r)<0}set(t,n,i){return this.a.copy(t),this.b.copy(n),this.c.copy(i),this}setFromPointsAndIndices(t,n,i,r){return this.a.copy(t[n]),this.b.copy(t[i]),this.c.copy(t[r]),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return rn.subVectors(this.c,this.b),Nn.subVectors(this.a,this.b),rn.cross(Nn).length()*.5}getMidpoint(t){return t===void 0&&(console.warn("THREE.Triangle: .getMidpoint() target is now required"),t=new z),t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return _t.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t===void 0&&(console.warn("THREE.Triangle: .getPlane() target is now required"),t=new Bn),t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,n){return _t.getBarycoord(t,this.a,this.b,this.c,n)}getUV(t,n,i,r,s){return _t.getUV(t,this.a,this.b,this.c,n,i,r,s)}containsPoint(t){return _t.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return _t.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,n){n===void 0&&(console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),n=new z);const i=this.a,r=this.b,s=this.c;let o,a;or.subVectors(r,i),ar.subVectors(s,i),vl.subVectors(t,i);const l=or.dot(vl),c=ar.dot(vl);if(l<=0&&c<=0)return n.copy(i);yl.subVectors(t,r);const f=or.dot(yl),u=ar.dot(yl);if(f>=0&&u<=f)return n.copy(r);const d=l*u-f*c;if(d<=0&&l>=0&&f<=0)return o=l/(l-f),n.copy(i).addScaledVector(or,o);xl.subVectors(t,s);const h=or.dot(xl),p=ar.dot(xl);if(p>=0&&h<=p)return n.copy(s);const v=h*c-l*p;if(v<=0&&c>=0&&p<=0)return a=c/(c-p),n.copy(i).addScaledVector(ar,a);const y=f*p-h*u;if(y<=0&&u-f>=0&&h-p>=0)return Lf.subVectors(s,r),a=(u-f)/(u-f+(h-p)),n.copy(r).addScaledVector(Lf,a);const m=1/(y+v+d);return o=v*m,a=d*m,n.copy(i).addScaledVector(or,o).addScaledVector(ar,a)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}const Xh={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},sn={h:0,s:0,l:0},So={h:0,s:0,l:0};function _l(e,t,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?e+(t-e)*6*n:n<1/2?t:n<2/3?e+(t-e)*6*(2/3-n):e}function bl(e){return e<.04045?e*.0773993808:Math.pow(e*.9478672986+.0521327014,2.4)}function wl(e){return e<.0031308?e*12.92:1.055*Math.pow(e,.41666)-.055}class xe{constructor(t,n,i){return Object.defineProperty(this,"isColor",{value:!0}),n===void 0&&i===void 0?this.set(t):this.setRGB(t,n,i)}set(t){return t&&t.isColor?this.copy(t):typeof t=="number"?this.setHex(t):typeof t=="string"&&this.setStyle(t),this}setScalar(t){return this.r=t,this.g=t,this.b=t,this}setHex(t){return t=Math.floor(t),this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}setRGB(t,n,i){return this.r=t,this.g=n,this.b=i,this}setHSL(t,n,i){if(t=Ee.euclideanModulo(t,1),n=Ee.clamp(n,0,1),i=Ee.clamp(i,0,1),n===0)this.r=this.g=this.b=i;else{const r=i<=.5?i*(1+n):i+n-i*n,s=2*i-r;this.r=_l(s,r,t+1/3),this.g=_l(s,r,t),this.b=_l(s,r,t-1/3)}return this}setStyle(t){function n(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+t+" will be ignored.")}let i;if(i=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)){let r;const s=i[1],o=i[2];switch(s){case"rgb":case"rgba":if(r=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,n(r[4]),this;if(r=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,n(r[4]),this;break;case"hsl":case"hsla":if(r=/^(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(r[1])/360,l=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return n(r[4]),this.setHSL(a,l,c)}break}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(t)){const r=i[1],s=r.length;if(s===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(s===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return t&&t.length>0?this.setColorName(t):this}setColorName(t){const n=Xh[t];return n!==void 0?this.setHex(n):console.warn("THREE.Color: Unknown color "+t),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}copyGammaToLinear(t,n=2){return this.r=Math.pow(t.r,n),this.g=Math.pow(t.g,n),this.b=Math.pow(t.b,n),this}copyLinearToGamma(t,n=2){const i=n>0?1/n:1;return this.r=Math.pow(t.r,i),this.g=Math.pow(t.g,i),this.b=Math.pow(t.b,i),this}convertGammaToLinear(t){return this.copyGammaToLinear(this,t),this}convertLinearToGamma(t){return this.copyLinearToGamma(this,t),this}copySRGBToLinear(t){return this.r=bl(t.r),this.g=bl(t.g),this.b=bl(t.b),this}copyLinearToSRGB(t){return this.r=wl(t.r),this.g=wl(t.g),this.b=wl(t.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(t){t===void 0&&(console.warn("THREE.Color: .getHSL() target is now required"),t={h:0,s:0,l:0});const n=this.r,i=this.g,r=this.b,s=Math.max(n,i,r),o=Math.min(n,i,r);let a,l;const c=(o+s)/2;if(o===s)a=0,l=0;else{const f=s-o;switch(l=c<=.5?f/(s+o):f/(2-s-o),s){case n:a=(i-r)/f+(i<r?6:0);break;case i:a=(r-n)/f+2;break;case r:a=(n-i)/f+4;break}a/=6}return t.h=a,t.s=l,t.l=c,t}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(t,n,i){return this.getHSL(sn),sn.h+=t,sn.s+=n,sn.l+=i,this.setHSL(sn.h,sn.s,sn.l),this}add(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addColors(t,n){return this.r=t.r+n.r,this.g=t.g+n.g,this.b=t.b+n.b,this}addScalar(t){return this.r+=t,this.g+=t,this.b+=t,this}sub(t){return this.r=Math.max(0,this.r-t.r),this.g=Math.max(0,this.g-t.g),this.b=Math.max(0,this.b-t.b),this}multiply(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyScalar(t){return this.r*=t,this.g*=t,this.b*=t,this}lerp(t,n){return this.r+=(t.r-this.r)*n,this.g+=(t.g-this.g)*n,this.b+=(t.b-this.b)*n,this}lerpHSL(t,n){this.getHSL(sn),t.getHSL(So);const i=Ee.lerp(sn.h,So.h,n),r=Ee.lerp(sn.s,So.s,n),s=Ee.lerp(sn.l,So.l,n);return this.setHSL(i,r,s),this}equals(t){return t.r===this.r&&t.g===this.g&&t.b===this.b}fromArray(t,n=0){return this.r=t[n],this.g=t[n+1],this.b=t[n+2],this}toArray(t=[],n=0){return t[n]=this.r,t[n+1]=this.g,t[n+2]=this.b,t}fromBufferAttribute(t,n){return this.r=t.getX(n),this.g=t.getY(n),this.b=t.getZ(n),t.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}xe.NAMES=Xh;xe.prototype.r=1;xe.prototype.g=1;xe.prototype.b=1;class ac{constructor(t,n,i,r,s,o=0){this.a=t,this.b=n,this.c=i,this.normal=r&&r.isVector3?r:new z,this.vertexNormals=Array.isArray(r)?r:[],this.color=s&&s.isColor?s:new xe,this.vertexColors=Array.isArray(s)?s:[],this.materialIndex=o}clone(){return new this.constructor().copy(this)}copy(t){this.a=t.a,this.b=t.b,this.c=t.c,this.normal.copy(t.normal),this.color.copy(t.color),this.materialIndex=t.materialIndex;for(let n=0,i=t.vertexNormals.length;n<i;n++)this.vertexNormals[n]=t.vertexNormals[n].clone();for(let n=0,i=t.vertexColors.length;n<i;n++)this.vertexColors[n]=t.vertexColors[n].clone();return this}}let ox=0;function we(){Object.defineProperty(this,"id",{value:ox++}),this.uuid=Ee.generateUUID(),this.name="",this.type="Material",this.fog=!0,this.blending=Ms,this.side=no,this.flatShading=!1,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.blendSrc=kh,this.blendDst=Gh,this.blendEquation=vr,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=rc,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Jy,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=al,this.stencilZFail=al,this.stencilZPass=al,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaTest=0,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0}we.prototype=Object.assign(Object.create(Yn.prototype),{constructor:we,isMaterial:!0,onBeforeCompile:function(){},customProgramCacheKey:function(){return this.onBeforeCompile.toString()},setValues:function(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===Hh;continue}const i=this[t];if(i===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}},toJSON:function(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen&&this.sheen.isColor&&(n.sheen=this.sheen.getHex()),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,n.reflectivity=this.reflectivity,n.refractionRatio=this.refractionRatio,this.combine!==void 0&&(n.combine=this.combine),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity)),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.size!==void 0&&(n.size=this.size),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==Ms&&(n.blending=this.blending),this.flatShading===!0&&(n.flatShading=this.flatShading),this.side!==no&&(n.side=this.side),this.vertexColors&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=this.transparent),n.depthFunc=this.depthFunc,n.depthTest=this.depthTest,n.depthWrite=this.depthWrite,n.stencilWrite=this.stencilWrite,n.stencilWriteMask=this.stencilWriteMask,n.stencilFunc=this.stencilFunc,n.stencilRef=this.stencilRef,n.stencilFuncMask=this.stencilFuncMask,n.stencilFail=this.stencilFail,n.stencilZFail=this.stencilZFail,n.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(n.wireframe=this.wireframe),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.morphTargets===!0&&(n.morphTargets=!0),this.morphNormals===!0&&(n.morphNormals=!0),this.skinning===!0&&(n.skinning=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(n.userData=this.userData);function i(r){const s=[];for(const o in r){const a=r[o];delete a.metadata,s.push(a)}return s}if(t){const r=i(e.textures),s=i(e.images);r.length>0&&(n.textures=r),s.length>0&&(n.images=s)}return n},clone:function(){return new this.constructor().copy(this)},copy:function(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.flatShading=e.flatShading,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this},dispose:function(){this.dispatchEvent({type:"dispose"})}});Object.defineProperty(we.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}});function Pt(e){we.call(this),this.type="MeshBasicMaterial",this.color=new xe(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ka,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.setValues(e)}Pt.prototype=Object.create(we.prototype);Pt.prototype.constructor=Pt;Pt.prototype.isMeshBasicMaterial=!0;Pt.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this};const je=new z,To=new le;function Se(e,t,n){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n===!0,this.usage=Ga,this.updateRange={offset:0,count:-1},this.version=0}Object.defineProperty(Se.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}});Object.assign(Se.prototype,{isBufferAttribute:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[n+i];return this},copyArray:function(e){return this.array.set(e),this},copyColorsArray:function(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let s=e[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),s=new xe),t[n++]=s.r,t[n++]=s.g,t[n++]=s.b}return this},copyVector2sArray:function(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let s=e[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),s=new le),t[n++]=s.x,t[n++]=s.y}return this},copyVector3sArray:function(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let s=e[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),s=new z),t[n++]=s.x,t[n++]=s.y,t[n++]=s.z}return this},copyVector4sArray:function(e){const t=this.array;let n=0;for(let i=0,r=e.length;i<r;i++){let s=e[i];s===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",i),s=new Ge),t[n++]=s.x,t[n++]=s.y,t[n++]=s.z,t[n++]=s.w}return this},applyMatrix3:function(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)To.fromBufferAttribute(this,t),To.applyMatrix3(e),this.setXY(t,To.x,To.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)je.fromBufferAttribute(this,t),je.applyMatrix3(e),this.setXYZ(t,je.x,je.y,je.z);return this},applyMatrix4:function(e){for(let t=0,n=this.count;t<n;t++)je.x=this.getX(t),je.y=this.getY(t),je.z=this.getZ(t),je.applyMatrix4(e),this.setXYZ(t,je.x,je.y,je.z);return this},applyNormalMatrix:function(e){for(let t=0,n=this.count;t<n;t++)je.x=this.getX(t),je.y=this.getY(t),je.z=this.getZ(t),je.applyNormalMatrix(e),this.setXYZ(t,je.x,je.y,je.z);return this},transformDirection:function(e){for(let t=0,n=this.count;t<n;t++)je.x=this.getX(t),je.y=this.getY(t),je.z=this.getZ(t),je.transformDirection(e),this.setXYZ(t,je.x,je.y,je.z);return this},set:function(e,t=0){return this.array.set(e,t),this},getX:function(e){return this.array[e*this.itemSize]},setX:function(e,t){return this.array[e*this.itemSize]=t,this},getY:function(e){return this.array[e*this.itemSize+1]},setY:function(e,t){return this.array[e*this.itemSize+1]=t,this},getZ:function(e){return this.array[e*this.itemSize+2]},setZ:function(e,t){return this.array[e*this.itemSize+2]=t,this},getW:function(e){return this.array[e*this.itemSize+3]},setW:function(e,t){return this.array[e*this.itemSize+3]=t,this},setXY:function(e,t,n){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this},setXYZ:function(e,t,n,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this},setXYZW:function(e,t,n,i,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=r,this},onUpload:function(e){return this.onUploadCallback=e,this},clone:function(){return new this.constructor(this.array,this.itemSize).copy(this)},toJSON:function(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized}}});function lc(e,t,n){Se.call(this,new Int8Array(e),t,n)}lc.prototype=Object.create(Se.prototype);lc.prototype.constructor=lc;function cc(e,t,n){Se.call(this,new Uint8Array(e),t,n)}cc.prototype=Object.create(Se.prototype);cc.prototype.constructor=cc;function uc(e,t,n){Se.call(this,new Uint8ClampedArray(e),t,n)}uc.prototype=Object.create(Se.prototype);uc.prototype.constructor=uc;function fc(e,t,n){Se.call(this,new Int16Array(e),t,n)}fc.prototype=Object.create(Se.prototype);fc.prototype.constructor=fc;function ks(e,t,n){Se.call(this,new Uint16Array(e),t,n)}ks.prototype=Object.create(Se.prototype);ks.prototype.constructor=ks;function dc(e,t,n){Se.call(this,new Int32Array(e),t,n)}dc.prototype=Object.create(Se.prototype);dc.prototype.constructor=dc;function Gs(e,t,n){Se.call(this,new Uint32Array(e),t,n)}Gs.prototype=Object.create(Se.prototype);Gs.prototype.constructor=Gs;function pa(e,t,n){Se.call(this,new Uint16Array(e),t,n)}pa.prototype=Object.create(Se.prototype);pa.prototype.constructor=pa;pa.prototype.isFloat16BufferAttribute=!0;function Ie(e,t,n){Se.call(this,new Float32Array(e),t,n)}Ie.prototype=Object.create(Se.prototype);Ie.prototype.constructor=Ie;function hc(e,t,n){Se.call(this,new Float64Array(e),t,n)}hc.prototype=Object.create(Se.prototype);hc.prototype.constructor=hc;class ax{constructor(){this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.uvs2=[],this.groups=[],this.morphTargets={},this.skinWeights=[],this.skinIndices=[],this.boundingBox=null,this.boundingSphere=null,this.verticesNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.uvsNeedUpdate=!1,this.groupsNeedUpdate=!1}computeGroups(t){const n=[];let i,r,s;const o=t.faces;for(r=0;r<o.length;r++){const a=o[r];a.materialIndex!==s&&(s=a.materialIndex,i!==void 0&&(i.count=r*3-i.start,n.push(i)),i={start:r*3,materialIndex:s})}i!==void 0&&(i.count=r*3-i.start,n.push(i)),this.groups=n}fromGeometry(t){const n=t.faces,i=t.vertices,r=t.faceVertexUvs,s=r[0]&&r[0].length>0,o=r[1]&&r[1].length>0,a=t.morphTargets,l=a.length;let c;if(l>0){c=[];for(let m=0;m<l;m++)c[m]={name:a[m].name,data:[]};this.morphTargets.position=c}const f=t.morphNormals,u=f.length;let d;if(u>0){d=[];for(let m=0;m<u;m++)d[m]={name:f[m].name,data:[]};this.morphTargets.normal=d}const h=t.skinIndices,p=t.skinWeights,v=h.length===i.length,y=p.length===i.length;i.length>0&&n.length===0&&console.error("THREE.DirectGeometry: Faceless geometries are not supported.");for(let m=0;m<n.length;m++){const g=n[m];this.vertices.push(i[g.a],i[g.b],i[g.c]);const T=g.vertexNormals;if(T.length===3)this.normals.push(T[0],T[1],T[2]);else{const A=g.normal;this.normals.push(A,A,A)}const P=g.vertexColors;if(P.length===3)this.colors.push(P[0],P[1],P[2]);else{const A=g.color;this.colors.push(A,A,A)}if(s===!0){const A=r[0][m];A!==void 0?this.uvs.push(A[0],A[1],A[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",m),this.uvs.push(new le,new le,new le))}if(o===!0){const A=r[1][m];A!==void 0?this.uvs2.push(A[0],A[1],A[2]):(console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",m),this.uvs2.push(new le,new le,new le))}for(let A=0;A<l;A++){const M=a[A].vertices;c[A].data.push(M[g.a],M[g.b],M[g.c])}for(let A=0;A<u;A++){const M=f[A].vertexNormals[m];d[A].data.push(M.a,M.b,M.c)}v&&this.skinIndices.push(h[g.a],h[g.b],h[g.c]),y&&this.skinWeights.push(p[g.a],p[g.b],p[g.c])}return this.computeGroups(t),this.verticesNeedUpdate=t.verticesNeedUpdate,this.normalsNeedUpdate=t.normalsNeedUpdate,this.colorsNeedUpdate=t.colorsNeedUpdate,this.uvsNeedUpdate=t.uvsNeedUpdate,this.groupsNeedUpdate=t.groupsNeedUpdate,t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone()),this}}function Yh(e){if(e.length===0)return-1/0;let t=e[0];for(let n=1,i=e.length;n<i;++n)e[n]>t&&(t=e[n]);return t}const lx={Int8Array,Uint8Array,Uint8ClampedArray:typeof Uint8ClampedArray<"u"?Uint8ClampedArray:Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function Eo(e,t){return new lx[e](t)}let cx=1;const yn=new Le,Ml=new be,lr=new z,Bt=new Jn,ls=new Jn,at=new z;function Be(){Object.defineProperty(this,"id",{value:cx+=2}),this.uuid=Ee.generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}Be.prototype=Object.assign(Object.create(Yn.prototype),{constructor:Be,isBufferGeometry:!0,getIndex:function(){return this.index},setIndex:function(e){return Array.isArray(e)?this.index=new(Yh(e)>65535?Gs:ks)(e,1):this.index=e,this},getAttribute:function(e){return this.attributes[e]},setAttribute:function(e,t){return this.attributes[e]=t,this},deleteAttribute:function(e){return delete this.attributes[e],this},hasAttribute:function(e){return this.attributes[e]!==void 0},addGroup:function(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})},clearGroups:function(){this.groups=[]},setDrawRange:function(e,t){this.drawRange.start=e,this.drawRange.count=t},applyMatrix4:function(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new It().getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this},rotateX:function(e){return yn.makeRotationX(e),this.applyMatrix4(yn),this},rotateY:function(e){return yn.makeRotationY(e),this.applyMatrix4(yn),this},rotateZ:function(e){return yn.makeRotationZ(e),this.applyMatrix4(yn),this},translate:function(e,t,n){return yn.makeTranslation(e,t,n),this.applyMatrix4(yn),this},scale:function(e,t,n){return yn.makeScale(e,t,n),this.applyMatrix4(yn),this},lookAt:function(e){return Ml.lookAt(e),Ml.updateMatrix(),this.applyMatrix4(Ml.matrix),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(lr).negate(),this.translate(lr.x,lr.y,lr.z),this},setFromObject:function(e){const t=e.geometry;if(e.isPoints||e.isLine){const n=new Ie(t.vertices.length*3,3),i=new Ie(t.colors.length*3,3);if(this.setAttribute("position",n.copyVector3sArray(t.vertices)),this.setAttribute("color",i.copyColorsArray(t.colors)),t.lineDistances&&t.lineDistances.length===t.vertices.length){const r=new Ie(t.lineDistances.length,1);this.setAttribute("lineDistance",r.copyArray(t.lineDistances))}t.boundingSphere!==null&&(this.boundingSphere=t.boundingSphere.clone()),t.boundingBox!==null&&(this.boundingBox=t.boundingBox.clone())}else e.isMesh&&t&&t.isGeometry&&this.fromGeometry(t);return this},setFromPoints:function(e){const t=[];for(let n=0,i=e.length;n<i;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new Ie(t,3)),this},updateFromObject:function(e){let t=e.geometry;if(e.isMesh){let n=t.__directGeometry;if(t.elementsNeedUpdate===!0&&(n=void 0,t.elementsNeedUpdate=!1),n===void 0)return this.fromGeometry(t);n.verticesNeedUpdate=t.verticesNeedUpdate,n.normalsNeedUpdate=t.normalsNeedUpdate,n.colorsNeedUpdate=t.colorsNeedUpdate,n.uvsNeedUpdate=t.uvsNeedUpdate,n.groupsNeedUpdate=t.groupsNeedUpdate,t.verticesNeedUpdate=!1,t.normalsNeedUpdate=!1,t.colorsNeedUpdate=!1,t.uvsNeedUpdate=!1,t.groupsNeedUpdate=!1,t=n}if(t.verticesNeedUpdate===!0){const n=this.attributes.position;n!==void 0&&(n.copyVector3sArray(t.vertices),n.needsUpdate=!0),t.verticesNeedUpdate=!1}if(t.normalsNeedUpdate===!0){const n=this.attributes.normal;n!==void 0&&(n.copyVector3sArray(t.normals),n.needsUpdate=!0),t.normalsNeedUpdate=!1}if(t.colorsNeedUpdate===!0){const n=this.attributes.color;n!==void 0&&(n.copyColorsArray(t.colors),n.needsUpdate=!0),t.colorsNeedUpdate=!1}if(t.uvsNeedUpdate){const n=this.attributes.uv;n!==void 0&&(n.copyVector2sArray(t.uvs),n.needsUpdate=!0),t.uvsNeedUpdate=!1}if(t.lineDistancesNeedUpdate){const n=this.attributes.lineDistance;n!==void 0&&(n.copyArray(t.lineDistances),n.needsUpdate=!0),t.lineDistancesNeedUpdate=!1}return t.groupsNeedUpdate&&(t.computeGroups(e.geometry),this.groups=t.groups,t.groupsNeedUpdate=!1),this},fromGeometry:function(e){return e.__directGeometry=new ax().fromGeometry(e),this.fromDirectGeometry(e.__directGeometry)},fromDirectGeometry:function(e){const t=new Float32Array(e.vertices.length*3);if(this.setAttribute("position",new Se(t,3).copyVector3sArray(e.vertices)),e.normals.length>0){const n=new Float32Array(e.normals.length*3);this.setAttribute("normal",new Se(n,3).copyVector3sArray(e.normals))}if(e.colors.length>0){const n=new Float32Array(e.colors.length*3);this.setAttribute("color",new Se(n,3).copyColorsArray(e.colors))}if(e.uvs.length>0){const n=new Float32Array(e.uvs.length*2);this.setAttribute("uv",new Se(n,2).copyVector2sArray(e.uvs))}if(e.uvs2.length>0){const n=new Float32Array(e.uvs2.length*2);this.setAttribute("uv2",new Se(n,2).copyVector2sArray(e.uvs2))}this.groups=e.groups;for(const n in e.morphTargets){const i=[],r=e.morphTargets[n];for(let s=0,o=r.length;s<o;s++){const a=r[s],l=new Ie(a.data.length*3,3);l.name=a.name,i.push(l.copyVector3sArray(a.data))}this.morphAttributes[n]=i}if(e.skinIndices.length>0){const n=new Ie(e.skinIndices.length*4,4);this.setAttribute("skinIndex",n.copyVector4sArray(e.skinIndices))}if(e.skinWeights.length>0){const n=new Ie(e.skinWeights.length*4,4);this.setAttribute("skinWeight",n.copyVector4sArray(e.skinWeights))}return e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),this},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new Jn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new z(-1/0,-1/0,-1/0),new z(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const r=t[n];Bt.setFromBufferAttribute(r),this.morphTargetsRelative?(at.addVectors(this.boundingBox.min,Bt.min),this.boundingBox.expandByPoint(at),at.addVectors(this.boundingBox.max,Bt.max),this.boundingBox.expandByPoint(at)):(this.boundingBox.expandByPoint(Bt.min),this.boundingBox.expandByPoint(Bt.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new Zn);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new z,1/0);return}if(e){const n=this.boundingSphere.center;if(Bt.setFromBufferAttribute(e),t)for(let r=0,s=t.length;r<s;r++){const o=t[r];ls.setFromBufferAttribute(o),this.morphTargetsRelative?(at.addVectors(Bt.min,ls.min),Bt.expandByPoint(at),at.addVectors(Bt.max,ls.max),Bt.expandByPoint(at)):(Bt.expandByPoint(ls.min),Bt.expandByPoint(ls.max))}Bt.getCenter(n);let i=0;for(let r=0,s=e.count;r<s;r++)at.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(at));if(t)for(let r=0,s=t.length;r<s;r++){const o=t[r],a=this.morphTargetsRelative;for(let l=0,c=o.count;l<c;l++)at.fromBufferAttribute(o,l),a&&(lr.fromBufferAttribute(e,l),at.add(lr)),i=Math.max(i,n.distanceToSquared(at))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}},computeFaceNormals:function(){},computeVertexNormals:function(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Se(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let u=0,d=n.count;u<d;u++)n.setXYZ(u,0,0,0);const i=new z,r=new z,s=new z,o=new z,a=new z,l=new z,c=new z,f=new z;if(e)for(let u=0,d=e.count;u<d;u+=3){const h=e.getX(u+0),p=e.getX(u+1),v=e.getX(u+2);i.fromBufferAttribute(t,h),r.fromBufferAttribute(t,p),s.fromBufferAttribute(t,v),c.subVectors(s,r),f.subVectors(i,r),c.cross(f),o.fromBufferAttribute(n,h),a.fromBufferAttribute(n,p),l.fromBufferAttribute(n,v),o.add(c),a.add(c),l.add(c),n.setXYZ(h,o.x,o.y,o.z),n.setXYZ(p,a.x,a.y,a.z),n.setXYZ(v,l.x,l.y,l.z)}else for(let u=0,d=t.count;u<d;u+=3)i.fromBufferAttribute(t,u+0),r.fromBufferAttribute(t,u+1),s.fromBufferAttribute(t,u+2),c.subVectors(s,r),f.subVectors(i,r),c.cross(f),n.setXYZ(u+0,c.x,c.y,c.z),n.setXYZ(u+1,c.x,c.y,c.z),n.setXYZ(u+2,c.x,c.y,c.z);this.normalizeNormals(),n.needsUpdate=!0}},merge:function(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const n=this.attributes;for(const i in n){if(e.attributes[i]===void 0)continue;const s=n[i].array,o=e.attributes[i],a=o.array,l=o.itemSize*t,c=Math.min(a.length,s.length-l);for(let f=0,u=l;f<c;f++,u++)s[u]=a[f]}return this},normalizeNormals:function(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)at.fromBufferAttribute(e,t),at.normalize(),e.setXYZ(t,at.x,at.y,at.z)},toNonIndexed:function(){function e(o,a){const l=o.array,c=o.itemSize,f=o.normalized,u=new l.constructor(a.length*c);let d=0,h=0;for(let p=0,v=a.length;p<v;p++){d=a[p]*c;for(let y=0;y<c;y++)u[h++]=l[d++]}return new Se(u,c,f)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),this;const t=new Be,n=this.index.array,i=this.attributes;for(const o in i){const a=i[o],l=e(a,n);t.setAttribute(o,l)}const r=this.morphAttributes;for(const o in r){const a=[],l=r[o];for(let c=0,f=l.length;c<f;c++){const u=l[c],d=e(u,n);a.push(d)}t.morphAttributes[o]=a}t.morphTargetsRelative=this.morphTargetsRelative;const s=this.groups;for(let o=0,a=s.length;o<a;o++){const l=s[o];t.addGroup(l.start,l.count,l.materialIndex)}return t},toJSON:function(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const a=this.parameters;for(const l in a)a[l]!==void 0&&(e[l]=a[l]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const a in n){const l=n[a],c=l.toJSON(e.data);l.name!==""&&(c.name=l.name),e.data.attributes[a]=c}const i={};let r=!1;for(const a in this.morphAttributes){const l=this.morphAttributes[a],c=[];for(let f=0,u=l.length;f<u;f++){const d=l[f],h=d.toJSON(e.data);d.name!==""&&(h.name=d.name),c.push(h)}c.length>0&&(i[a]=c,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const s=this.groups;s.length>0&&(e.data.groups=JSON.parse(JSON.stringify(s)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e},clone:function(){return new Be().copy(this)},copy:function(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const l in i){const c=i[l];this.setAttribute(l,c.clone(t))}const r=e.morphAttributes;for(const l in r){const c=[],f=r[l];for(let u=0,d=f.length;u<d;u++)c.push(f[u].clone(t));this.morphAttributes[l]=c}this.morphTargetsRelative=e.morphTargetsRelative;const s=e.groups;for(let l=0,c=s.length;l<c;l++){const f=s[l];this.addGroup(f.start,f.count,f.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const a=e.boundingSphere;return a!==null&&(this.boundingSphere=a.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});const Cf=new Le,Ni=new so,Sl=new Zn,si=new z,oi=new z,ai=new z,Tl=new z,El=new z,Al=new z,Ao=new z,Lo=new z,Co=new z,wr=new le,Mr=new le,Sr=new le,Es=new z,Po=new z;function rt(e=new Be,t=new Pt){be.call(this),this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}rt.prototype=Object.assign(Object.create(be.prototype),{constructor:rt,isMesh:!0,copy:function(e){return be.prototype.copy.call(this,e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}},raycast:function(e,t){const n=this.geometry,i=this.material,r=this.matrixWorld;if(i===void 0||(n.boundingSphere===null&&n.computeBoundingSphere(),Sl.copy(n.boundingSphere),Sl.applyMatrix4(r),e.ray.intersectsSphere(Sl)===!1)||(Cf.copy(r).invert(),Ni.copy(e.ray).applyMatrix4(Cf),n.boundingBox!==null&&Ni.intersectsBox(n.boundingBox)===!1))return;let s;if(n.isBufferGeometry){const o=n.index,a=n.attributes.position,l=n.morphAttributes.position,c=n.morphTargetsRelative,f=n.attributes.uv,u=n.attributes.uv2,d=n.groups,h=n.drawRange;if(o!==null)if(Array.isArray(i))for(let p=0,v=d.length;p<v;p++){const y=d[p],m=i[y.materialIndex],g=Math.max(y.start,h.start),T=Math.min(y.start+y.count,h.start+h.count);for(let P=g,A=T;P<A;P+=3){const M=o.getX(P),N=o.getX(P+1),B=o.getX(P+2);s=Ro(this,m,e,Ni,a,l,c,f,u,M,N,B),s&&(s.faceIndex=Math.floor(P/3),s.face.materialIndex=y.materialIndex,t.push(s))}}else{const p=Math.max(0,h.start),v=Math.min(o.count,h.start+h.count);for(let y=p,m=v;y<m;y+=3){const g=o.getX(y),T=o.getX(y+1),P=o.getX(y+2);s=Ro(this,i,e,Ni,a,l,c,f,u,g,T,P),s&&(s.faceIndex=Math.floor(y/3),t.push(s))}}else if(a!==void 0)if(Array.isArray(i))for(let p=0,v=d.length;p<v;p++){const y=d[p],m=i[y.materialIndex],g=Math.max(y.start,h.start),T=Math.min(y.start+y.count,h.start+h.count);for(let P=g,A=T;P<A;P+=3){const M=P,N=P+1,B=P+2;s=Ro(this,m,e,Ni,a,l,c,f,u,M,N,B),s&&(s.faceIndex=Math.floor(P/3),s.face.materialIndex=y.materialIndex,t.push(s))}}else{const p=Math.max(0,h.start),v=Math.min(a.count,h.start+h.count);for(let y=p,m=v;y<m;y+=3){const g=y,T=y+1,P=y+2;s=Ro(this,i,e,Ni,a,l,c,f,u,g,T,P),s&&(s.faceIndex=Math.floor(y/3),t.push(s))}}}else if(n.isGeometry){const o=Array.isArray(i),a=n.vertices,l=n.faces;let c;const f=n.faceVertexUvs[0];f.length>0&&(c=f);for(let u=0,d=l.length;u<d;u++){const h=l[u],p=o?i[h.materialIndex]:i;if(p===void 0)continue;const v=a[h.a],y=a[h.b],m=a[h.c];if(s=Jh(this,p,e,Ni,v,y,m,Es),s){if(c&&c[u]){const g=c[u];wr.copy(g[0]),Mr.copy(g[1]),Sr.copy(g[2]),s.uv=_t.getUV(Es,v,y,m,wr,Mr,Sr,new le)}s.face=h,s.faceIndex=u,t.push(s)}}}}});function Jh(e,t,n,i,r,s,o,a){let l;if(t.side===ht?l=i.intersectTriangle(o,s,r,!0,a):l=i.intersectTriangle(r,s,o,t.side!==io,a),l===null)return null;Po.copy(a),Po.applyMatrix4(e.matrixWorld);const c=n.ray.origin.distanceTo(Po);return c<n.near||c>n.far?null:{distance:c,point:Po.clone(),object:e}}function Ro(e,t,n,i,r,s,o,a,l,c,f,u){si.fromBufferAttribute(r,c),oi.fromBufferAttribute(r,f),ai.fromBufferAttribute(r,u);const d=e.morphTargetInfluences;if(t.morphTargets&&s&&d){Ao.set(0,0,0),Lo.set(0,0,0),Co.set(0,0,0);for(let p=0,v=s.length;p<v;p++){const y=d[p],m=s[p];y!==0&&(Tl.fromBufferAttribute(m,c),El.fromBufferAttribute(m,f),Al.fromBufferAttribute(m,u),o?(Ao.addScaledVector(Tl,y),Lo.addScaledVector(El,y),Co.addScaledVector(Al,y)):(Ao.addScaledVector(Tl.sub(si),y),Lo.addScaledVector(El.sub(oi),y),Co.addScaledVector(Al.sub(ai),y)))}si.add(Ao),oi.add(Lo),ai.add(Co)}e.isSkinnedMesh&&(e.boneTransform(c,si),e.boneTransform(f,oi),e.boneTransform(u,ai));const h=Jh(e,t,n,i,si,oi,ai,Es);if(h){a&&(wr.fromBufferAttribute(a,c),Mr.fromBufferAttribute(a,f),Sr.fromBufferAttribute(a,u),h.uv=_t.getUV(Es,si,oi,ai,wr,Mr,Sr,new le)),l&&(wr.fromBufferAttribute(l,c),Mr.fromBufferAttribute(l,f),Sr.fromBufferAttribute(l,u),h.uv2=_t.getUV(Es,si,oi,ai,wr,Mr,Sr,new le));const p=new ac(c,f,u);_t.getNormal(si,oi,ai,p.normal),h.face=p}return h}class vu extends Be{constructor(t=1,n=1,i=1,r=1,s=1,o=1){super(),this.type="BoxBufferGeometry",this.parameters={width:t,height:n,depth:i,widthSegments:r,heightSegments:s,depthSegments:o};const a=this;r=Math.floor(r),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],f=[],u=[];let d=0,h=0;p("z","y","x",-1,-1,i,n,t,o,s,0),p("z","y","x",1,-1,i,n,-t,o,s,1),p("x","z","y",1,1,t,i,n,r,o,2),p("x","z","y",1,-1,t,i,-n,r,o,3),p("x","y","z",1,-1,t,n,i,r,s,4),p("x","y","z",-1,-1,t,n,-i,r,s,5),this.setIndex(l),this.setAttribute("position",new Ie(c,3)),this.setAttribute("normal",new Ie(f,3)),this.setAttribute("uv",new Ie(u,2));function p(v,y,m,g,T,P,A,M,N,B,W){const te=P/N,H=A/B,j=P/2,Y=A/2,X=M/2,q=N+1,$=B+1;let ne=0,oe=0;const fe=new z;for(let ge=0;ge<$;ge++){const he=ge*H-Y;for(let de=0;de<q;de++){const Me=de*te-j;fe[v]=Me*g,fe[y]=he*T,fe[m]=X,c.push(fe.x,fe.y,fe.z),fe[v]=0,fe[y]=0,fe[m]=M>0?1:-1,f.push(fe.x,fe.y,fe.z),u.push(de/N),u.push(1-ge/B),ne+=1}}for(let ge=0;ge<B;ge++)for(let he=0;he<N;he++){const de=d+he+q*ge,Me=d+he+q*(ge+1),ke=d+(he+1)+q*(ge+1),se=d+(he+1)+q*ge;l.push(de,Me,se),l.push(Me,ke,se),oe+=6}a.addGroup(h,oe,W),h+=oe,d+=ne}}}function zr(e){const t={};for(const n in e){t[n]={};for(const i in e[n]){const r=e[n][i];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture)?t[n][i]=r.clone():Array.isArray(r)?t[n][i]=r.slice():t[n][i]=r}}return t}function vt(e){const t={};for(let n=0;n<e.length;n++){const i=zr(e[n]);for(const r in i)t[r]=i[r]}return t}const ux={clone:zr,merge:vt};var fx=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,dx=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;function Dt(e){we.call(this),this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=fx,this.fragmentShader=dx,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}Dt.prototype=Object.create(we.prototype);Dt.prototype.constructor=Dt;Dt.prototype.isShaderMaterial=!0;Dt.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=zr(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this};Dt.prototype.toJSON=function(e){const t=we.prototype.toJSON.call(this,e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const s=this.uniforms[i].value;s&&s.isTexture?t.uniforms[i]={type:"t",value:s.toJSON(e).uuid}:s&&s.isColor?t.uniforms[i]={type:"c",value:s.getHex()}:s&&s.isVector2?t.uniforms[i]={type:"v2",value:s.toArray()}:s&&s.isVector3?t.uniforms[i]={type:"v3",value:s.toArray()}:s&&s.isVector4?t.uniforms[i]={type:"v4",value:s.toArray()}:s&&s.isMatrix3?t.uniforms[i]={type:"m3",value:s.toArray()}:s&&s.isMatrix4?t.uniforms[i]={type:"m4",value:s.toArray()}:t.uniforms[i]={value:s}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t};function Ti(){be.call(this),this.type="Camera",this.matrixWorldInverse=new Le,this.projectionMatrix=new Le,this.projectionMatrixInverse=new Le}Ti.prototype=Object.assign(Object.create(be.prototype),{constructor:Ti,isCamera:!0,copy:function(e,t){return be.prototype.copy.call(this,e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this},getWorldDirection:function(e){e===void 0&&(console.warn("THREE.Camera: .getWorldDirection() target is now required"),e=new z),this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()},updateMatrixWorld:function(e){be.prototype.updateMatrixWorld.call(this,e),this.matrixWorldInverse.copy(this.matrixWorld).invert()},updateWorldMatrix:function(e,t){be.prototype.updateWorldMatrix.call(this,e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()},clone:function(){return new this.constructor().copy(this)}});function lt(e=50,t=1,n=.1,i=2e3){Ti.call(this),this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}lt.prototype=Object.assign(Object.create(Ti.prototype),{constructor:lt,isPerspectiveCamera:!0,copy:function(e,t){return Ti.prototype.copy.call(this,e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this},setFocalLength:function(e){const t=.5*this.getFilmHeight()/e;this.fov=Ee.RAD2DEG*2*Math.atan(t),this.updateProjectionMatrix()},getFocalLength:function(){const e=Math.tan(Ee.DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/e},getEffectiveFOV:function(){return Ee.RAD2DEG*2*Math.atan(Math.tan(Ee.DEG2RAD*.5*this.fov)/this.zoom)},getFilmWidth:function(){return this.filmGauge*Math.min(this.aspect,1)},getFilmHeight:function(){return this.filmGauge/Math.max(this.aspect,1)},setViewOffset:function(e,t,n,i,r,s){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=this.near;let t=e*Math.tan(Ee.DEG2RAD*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,r=-.5*i;const s=this.view;if(this.view!==null&&this.view.enabled){const a=s.fullWidth,l=s.fullHeight;r+=s.offsetX*i/a,t-=s.offsetY*n/l,i*=s.width/a,n*=s.height/l}const o=this.filmOffset;o!==0&&(r+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-n,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(e){const t=be.prototype.toJSON.call(this,e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}});const cr=90,ur=1;function Ur(e,t,n){if(be.call(this),this.type="CubeCamera",n.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=n;const i=new lt(cr,ur,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new z(1,0,0)),this.add(i);const r=new lt(cr,ur,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new z(-1,0,0)),this.add(r);const s=new lt(cr,ur,e,t);s.layers=this.layers,s.up.set(0,0,1),s.lookAt(new z(0,1,0)),this.add(s);const o=new lt(cr,ur,e,t);o.layers=this.layers,o.up.set(0,0,-1),o.lookAt(new z(0,-1,0)),this.add(o);const a=new lt(cr,ur,e,t);a.layers=this.layers,a.up.set(0,-1,0),a.lookAt(new z(0,0,1)),this.add(a);const l=new lt(cr,ur,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new z(0,0,-1)),this.add(l),this.update=function(c,f){this.parent===null&&this.updateMatrixWorld();const u=c.xr.enabled,d=c.getRenderTarget();c.xr.enabled=!1;const h=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,c.setRenderTarget(n,0),c.render(f,i),c.setRenderTarget(n,1),c.render(f,r),c.setRenderTarget(n,2),c.render(f,s),c.setRenderTarget(n,3),c.render(f,o),c.setRenderTarget(n,4),c.render(f,a),n.texture.generateMipmaps=h,c.setRenderTarget(n,5),c.render(f,l),c.setRenderTarget(d),c.xr.enabled=u}}Ur.prototype=Object.create(be.prototype);Ur.prototype.constructor=Ur;function Ei(e,t,n,i,r,s,o,a,l,c){e=e!==void 0?e:[],t=t!==void 0?t:fu,o=o!==void 0?o:xi,qe.call(this,e,t,n,i,r,s,o,a,l,c),this.flipY=!1,this._needsFlipEnvMap=!0}Ei.prototype=Object.create(qe.prototype);Ei.prototype.constructor=Ei;Ei.prototype.isCubeTexture=!0;Object.defineProperty(Ei.prototype,"images",{get:function(){return this.image},set:function(e){this.image=e}});function Vi(e,t,n){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=n),mn.call(this,e,e,t),t=t||{},this.texture=new Ei(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture._needsFlipEnvMap=!1}Vi.prototype=Object.create(mn.prototype);Vi.prototype.constructor=Vi;Vi.prototype.isWebGLCubeRenderTarget=!0;Vi.prototype.fromEquirectangularTexture=function(e,t){this.texture.type=t.type,this.texture.format=pn,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

			varying vec3 vWorldDirection;

			vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

				return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

			}

			void main() {

				vWorldDirection = transformDirection( position, modelMatrix );

				#include <begin_vertex>
				#include <project_vertex>

			}
		`,fragmentShader:`

			uniform sampler2D tEquirect;

			varying vec3 vWorldDirection;

			#include <common>

			void main() {

				vec3 direction = normalize( vWorldDirection );

				vec2 sampleUV = equirectUv( direction );

				gl_FragColor = texture2D( tEquirect, sampleUV );

			}
		`},i=new vu(5,5,5),r=new Dt({name:"CubemapFromEquirect",uniforms:zr(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:ht,blending:ws});r.uniforms.tEquirect.value=t;const s=new rt(i,r),o=t.minFilter;return t.minFilter===Br&&(t.minFilter=ct),new Ur(1,10,this).update(e,s),t.minFilter=o,s.geometry.dispose(),s.material.dispose(),this};Vi.prototype.clear=function(e,t,n,i){const r=e.getRenderTarget();for(let s=0;s<6;s++)e.setRenderTarget(this,s),e.clear(t,n,i);e.setRenderTarget(r)};function Hr(e,t,n,i,r,s,o,a,l,c,f,u){qe.call(this,null,s,o,a,l,c,i,r,f,u),this.image={data:e||null,width:t||1,height:n||1},this.magFilter=l!==void 0?l:xt,this.minFilter=c!==void 0?c:xt,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}Hr.prototype=Object.create(qe.prototype);Hr.prototype.constructor=Hr;Hr.prototype.isDataTexture=!0;const fr=new Zn,Io=new z;class Va{constructor(t,n,i,r,s,o){this.planes=[t!==void 0?t:new Bn,n!==void 0?n:new Bn,i!==void 0?i:new Bn,r!==void 0?r:new Bn,s!==void 0?s:new Bn,o!==void 0?o:new Bn]}set(t,n,i,r,s,o){const a=this.planes;return a[0].copy(t),a[1].copy(n),a[2].copy(i),a[3].copy(r),a[4].copy(s),a[5].copy(o),this}clone(){return new this.constructor().copy(this)}copy(t){const n=this.planes;for(let i=0;i<6;i++)n[i].copy(t.planes[i]);return this}setFromProjectionMatrix(t){const n=this.planes,i=t.elements,r=i[0],s=i[1],o=i[2],a=i[3],l=i[4],c=i[5],f=i[6],u=i[7],d=i[8],h=i[9],p=i[10],v=i[11],y=i[12],m=i[13],g=i[14],T=i[15];return n[0].setComponents(a-r,u-l,v-d,T-y).normalize(),n[1].setComponents(a+r,u+l,v+d,T+y).normalize(),n[2].setComponents(a+s,u+c,v+h,T+m).normalize(),n[3].setComponents(a-s,u-c,v-h,T-m).normalize(),n[4].setComponents(a-o,u-f,v-p,T-g).normalize(),n[5].setComponents(a+o,u+f,v+p,T+g).normalize(),this}intersectsObject(t){const n=t.geometry;return n.boundingSphere===null&&n.computeBoundingSphere(),fr.copy(n.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(fr)}intersectsSprite(t){return fr.center.set(0,0,0),fr.radius=.7071067811865476,fr.applyMatrix4(t.matrixWorld),this.intersectsSphere(fr)}intersectsSphere(t){const n=this.planes,i=t.center,r=-t.radius;for(let s=0;s<6;s++)if(n[s].distanceToPoint(i)<r)return!1;return!0}intersectsBox(t){const n=this.planes;for(let i=0;i<6;i++){const r=n[i];if(Io.x=r.normal.x>0?t.max.x:t.min.x,Io.y=r.normal.y>0?t.max.y:t.min.y,Io.z=r.normal.z>0?t.max.z:t.min.z,r.distanceToPoint(Io)<0)return!1}return!0}containsPoint(t){const n=this.planes;for(let i=0;i<6;i++)if(n[i].distanceToPoint(t)<0)return!1;return!0}}function Zh(){let e=null,t=!1,n=null,i=null;function r(s,o){n(s,o),i=e.requestAnimationFrame(r)}return{start:function(){t!==!0&&n!==null&&(i=e.requestAnimationFrame(r),t=!0)},stop:function(){e.cancelAnimationFrame(i),t=!1},setAnimationLoop:function(s){n=s},setContext:function(s){e=s}}}function hx(e,t){const n=t.isWebGL2,i=new WeakMap;function r(c,f){const u=c.array,d=c.usage,h=e.createBuffer();e.bindBuffer(f,h),e.bufferData(f,u,d),c.onUploadCallback();let p=5126;return u instanceof Float32Array?p=5126:u instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):u instanceof Uint16Array?c.isFloat16BufferAttribute?n?p=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):p=5123:u instanceof Int16Array?p=5122:u instanceof Uint32Array?p=5125:u instanceof Int32Array?p=5124:u instanceof Int8Array?p=5120:u instanceof Uint8Array&&(p=5121),{buffer:h,type:p,bytesPerElement:u.BYTES_PER_ELEMENT,version:c.version}}function s(c,f,u){const d=f.array,h=f.updateRange;e.bindBuffer(u,c),h.count===-1?e.bufferSubData(u,0,d):(n?e.bufferSubData(u,h.offset*d.BYTES_PER_ELEMENT,d,h.offset,h.count):e.bufferSubData(u,h.offset*d.BYTES_PER_ELEMENT,d.subarray(h.offset,h.offset+h.count)),h.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),i.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const f=i.get(c);f&&(e.deleteBuffer(f.buffer),i.delete(c))}function l(c,f){if(c.isGLBufferAttribute){const d=i.get(c);(!d||d.version<c.version)&&i.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const u=i.get(c);u===void 0?i.set(c,r(c,f)):u.version<c.version&&(s(u.buffer,c,f),u.version=c.version)}return{get:o,remove:a,update:l}}class $h extends Be{constructor(t=1,n=1,i=1,r=1){super(),this.type="PlaneBufferGeometry",this.parameters={width:t,height:n,widthSegments:i,heightSegments:r};const s=t/2,o=n/2,a=Math.floor(i),l=Math.floor(r),c=a+1,f=l+1,u=t/a,d=n/l,h=[],p=[],v=[],y=[];for(let m=0;m<f;m++){const g=m*d-o;for(let T=0;T<c;T++){const P=T*u-s;p.push(P,-g,0),v.push(0,0,1),y.push(T/a),y.push(1-m/l)}}for(let m=0;m<l;m++)for(let g=0;g<a;g++){const T=g+c*m,P=g+c*(m+1),A=g+1+c*(m+1),M=g+1+c*m;h.push(T,P,M),h.push(P,A,M)}this.setIndex(h),this.setAttribute("position",new Ie(p,3)),this.setAttribute("normal",new Ie(v,3)),this.setAttribute("uv",new Ie(y,2))}}var px=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,mx=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,gx=`#ifdef ALPHATEST
	if ( diffuseColor.a < ALPHATEST ) discard;
#endif`,vx=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );
	#endif
#endif`,yx=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,xx="vec3 transformed = vec3( position );",_x=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bx=`vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	return vec2( -1.04, 1.04 ) * a004 + r.zw;
}
float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
#if defined ( PHYSICALLY_CORRECT_LIGHTS )
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
#else
	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );
	}
	return 1.0;
#endif
}
vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
	return ( 1.0 - specularColor ) * fresnel + specularColor;
}
vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;
	return Fr * fresnel + F0;
}
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	return 1.0 / ( gl * gv );
}
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( incidentLight.direction + viewDir );
	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( G * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	return specularColor * brdf.x + brdf.y;
}
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;
	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
	vec3 F = F_Schlick( specularColor, dotLH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}
float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}
#if defined( USE_SHEEN )
float D_Charlie(float roughness, float NoH) {
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125);	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}
float V_Neubelt(float NoV, float NoL) {
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}
vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {
	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;
	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );
	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );
}
#endif`,wx=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 );
		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,Mx=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,Sx=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,Tx=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Ex=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,Ax=`#ifdef USE_COLOR
	diffuseColor.rgb *= vColor;
#endif`,Lx=`#ifdef USE_COLOR
	varying vec3 vColor;
#endif`,Cx=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Px=`#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor.xyz *= color.xyz;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Rx=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	float distance = dot( planeNormal, point - pointOnPlane );
	return - distance * planeNormal + point;
}
float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return sign( dot( point - pointOnPlane, planeNormal ) );
}
vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {
	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,Ix=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Ox=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Nx=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Dx=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,Fx=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Bx=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,zx="gl_FragColor = linearToOutputTexel( gl_FragColor );",Ux=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}`,Hx=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifndef ENVMAP_TYPE_CUBE_UV
		envColor = envMapTexelToLinear( envColor );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,kx=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Gx=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Vx=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Wx=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,jx=`#ifdef USE_FOG
	fogDepth = - mvPosition.z;
#endif`,qx=`#ifdef USE_FOG
	varying float fogDepth;
#endif`,Xx=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Yx=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float fogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Jx=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,Zx=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
#endif`,$x=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Kx=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );
		#endif
	}
	#pragma unroll_loop_end
#endif`,Qx=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {
	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	return irradiance;
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {
		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );
		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );
		if ( angleCos > spotLight.coneCos ) {
			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );
			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;
		} else {
			directLight.color = vec3( 0.0 );
			directLight.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {
		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			irradiance *= PI;
		#endif
		return irradiance;
	}
#endif`,e_=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {
		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );
			#else
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
		#else
			vec4 envMapColor = vec4( 0.0 );
		#endif
		return PI * envMapColor.rgb * envMapIntensity;
	}
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {
		float maxMIPLevelScalar = float( maxMIPLevel );
		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
	}
	vec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( -viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
		#else
			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );
		#endif
		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );
		#ifdef ENVMAP_TYPE_CUBE
			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );
			#ifdef TEXTURE_LOD_EXT
				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );
			#else
				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );
			#endif
			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;
		#elif defined( ENVMAP_TYPE_CUBE_UV )
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
		#endif
		return envMapColor.rgb * envMapIntensity;
	}
#endif`,t_=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,n_=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,i_=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,r_=`varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,s_=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );
#ifdef REFLECTIVITY
	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );
#endif
#ifdef CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheen;
#endif`,o_=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;
#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif
};
#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {
	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		irradiance *= PI;
	#endif
	#ifdef CLEARCOAT
		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = ccDotNL * directLight.color;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			ccIrradiance *= PI;
		#endif
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
	#else
		float clearcoatDHR = 0.0;
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif
	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef CLEARCOAT
		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );
		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );
	#else
		float clearcoatDHR = 0.0;
	#endif
	float clearcoatInv = 1.0 - clearcoatDHR;
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,a_=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointDirectLightIrradiance( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotDirectLightIrradiance( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,l_=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );
	#ifdef CLEARCOAT
		clearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );
	#endif
#endif`,c_=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,u_=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,f_=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,d_=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,h_=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,p_=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,m_=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,g_=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,v_=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,y_=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,x_=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,__=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
#endif`,b_=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifndef USE_MORPHNORMALS
		uniform float morphTargetInfluences[ 8 ];
	#else
		uniform float morphTargetInfluences[ 4 ];
	#endif
#endif`,w_=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];
	#ifndef USE_MORPHNORMALS
		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];
	#endif
#endif`,M_=`#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,S_=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( -vViewPosition, normal, mapN );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );
#endif`,T_=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		float scale = sign( st1.t * st0.s - st0.t * st1.s );
		vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );
		vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );
		vec3 N = normalize( surf_norm );
		mat3 tsn = mat3( S, T, N );
		mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );
		return normalize( tsn * mapN );
	}
#endif`,E_=`#ifdef CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,A_=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );
	#endif
#endif`,L_=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,C_=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,P_=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,R_=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,I_=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,O_=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,N_=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,D_=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,F_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,B_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,z_=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,U_=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,H_=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,k_=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,G_=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,V_=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,W_=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,j_=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,q_=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,X_=`#ifndef saturate
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Y_=`#ifdef USE_TRANSMISSIONMAP
	totalTransmission *= texture2D( transmissionMap, vUv ).r;
#endif`,J_=`#ifdef USE_TRANSMISSIONMAP
	uniform sampler2D transmissionMap;
#endif`,Z_=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,$_=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,K_=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,Q_=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,e0=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,t0=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,n0=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`,i0=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,r0=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,s0=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,o0=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,a0=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,l0=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,c0=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,u0=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,f0=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,d0=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,h0=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,p0=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,m0=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,g0=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>
	#ifdef USE_ENVMAP
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,v0=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,y0=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,x0=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,_0=`#define MATCAP
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#ifndef FLAT_SHADED
		vNormal = normalize( transformedNormal );
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,b0=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,w0=`#define TOON
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,M0=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,S0=`#define PHONG
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,T0=`#define STANDARD
#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef TRANSMISSION
	uniform float transmission;
#endif
#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif
#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,E0=`#define STANDARD
varying vec3 vViewPosition;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,A0=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,L0=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,C0=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,P0=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,R0=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,I0=`#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,O0=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	gl_FragColor = vec4( outgoingLight, diffuseColor.a );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,N0=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`;const Ne={alphamap_fragment:px,alphamap_pars_fragment:mx,alphatest_fragment:gx,aomap_fragment:vx,aomap_pars_fragment:yx,begin_vertex:xx,beginnormal_vertex:_x,bsdfs:bx,bumpmap_pars_fragment:wx,clipping_planes_fragment:Mx,clipping_planes_pars_fragment:Sx,clipping_planes_pars_vertex:Tx,clipping_planes_vertex:Ex,color_fragment:Ax,color_pars_fragment:Lx,color_pars_vertex:Cx,color_vertex:Px,common:Rx,cube_uv_reflection_fragment:Ix,defaultnormal_vertex:Ox,displacementmap_pars_vertex:Nx,displacementmap_vertex:Dx,emissivemap_fragment:Fx,emissivemap_pars_fragment:Bx,encodings_fragment:zx,encodings_pars_fragment:Ux,envmap_fragment:Hx,envmap_common_pars_fragment:kx,envmap_pars_fragment:Gx,envmap_pars_vertex:Vx,envmap_physical_pars_fragment:e_,envmap_vertex:Wx,fog_vertex:jx,fog_pars_vertex:qx,fog_fragment:Xx,fog_pars_fragment:Yx,gradientmap_pars_fragment:Jx,lightmap_fragment:Zx,lightmap_pars_fragment:$x,lights_lambert_vertex:Kx,lights_pars_begin:Qx,lights_toon_fragment:t_,lights_toon_pars_fragment:n_,lights_phong_fragment:i_,lights_phong_pars_fragment:r_,lights_physical_fragment:s_,lights_physical_pars_fragment:o_,lights_fragment_begin:a_,lights_fragment_maps:l_,lights_fragment_end:c_,logdepthbuf_fragment:u_,logdepthbuf_pars_fragment:f_,logdepthbuf_pars_vertex:d_,logdepthbuf_vertex:h_,map_fragment:p_,map_pars_fragment:m_,map_particle_fragment:g_,map_particle_pars_fragment:v_,metalnessmap_fragment:y_,metalnessmap_pars_fragment:x_,morphnormal_vertex:__,morphtarget_pars_vertex:b_,morphtarget_vertex:w_,normal_fragment_begin:M_,normal_fragment_maps:S_,normalmap_pars_fragment:T_,clearcoat_normal_fragment_begin:E_,clearcoat_normal_fragment_maps:A_,clearcoat_pars_fragment:L_,packing:C_,premultiplied_alpha_fragment:P_,project_vertex:R_,dithering_fragment:I_,dithering_pars_fragment:O_,roughnessmap_fragment:N_,roughnessmap_pars_fragment:D_,shadowmap_pars_fragment:F_,shadowmap_pars_vertex:B_,shadowmap_vertex:z_,shadowmask_pars_fragment:U_,skinbase_vertex:H_,skinning_pars_vertex:k_,skinning_vertex:G_,skinnormal_vertex:V_,specularmap_fragment:W_,specularmap_pars_fragment:j_,tonemapping_fragment:q_,tonemapping_pars_fragment:X_,transmissionmap_fragment:Y_,transmissionmap_pars_fragment:J_,uv_pars_fragment:Z_,uv_pars_vertex:$_,uv_vertex:K_,uv2_pars_fragment:Q_,uv2_pars_vertex:e0,uv2_vertex:t0,worldpos_vertex:n0,background_frag:i0,background_vert:r0,cube_frag:s0,cube_vert:o0,depth_frag:a0,depth_vert:l0,distanceRGBA_frag:c0,distanceRGBA_vert:u0,equirect_frag:f0,equirect_vert:d0,linedashed_frag:h0,linedashed_vert:p0,meshbasic_frag:m0,meshbasic_vert:g0,meshlambert_frag:v0,meshlambert_vert:y0,meshmatcap_frag:x0,meshmatcap_vert:_0,meshtoon_frag:b0,meshtoon_vert:w0,meshphong_frag:M0,meshphong_vert:S0,meshphysical_frag:T0,meshphysical_vert:E0,normal_frag:A0,normal_vert:L0,points_frag:C0,points_vert:P0,shadow_frag:R0,shadow_vert:I0,sprite_frag:O0,sprite_vert:N0},me={common:{diffuse:{value:new xe(15658734)},opacity:{value:1},map:{value:null},uvTransform:{value:new It},uv2Transform:{value:new It},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},refractionRatio:{value:.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new le(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new xe(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new xe(15658734)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},uvTransform:{value:new It}},sprite:{diffuse:{value:new xe(15658734)},opacity:{value:1},center:{value:new le(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new It}}},bn={basic:{uniforms:vt([me.common,me.specularmap,me.envmap,me.aomap,me.lightmap,me.fog]),vertexShader:Ne.meshbasic_vert,fragmentShader:Ne.meshbasic_frag},lambert:{uniforms:vt([me.common,me.specularmap,me.envmap,me.aomap,me.lightmap,me.emissivemap,me.fog,me.lights,{emissive:{value:new xe(0)}}]),vertexShader:Ne.meshlambert_vert,fragmentShader:Ne.meshlambert_frag},phong:{uniforms:vt([me.common,me.specularmap,me.envmap,me.aomap,me.lightmap,me.emissivemap,me.bumpmap,me.normalmap,me.displacementmap,me.fog,me.lights,{emissive:{value:new xe(0)},specular:{value:new xe(1118481)},shininess:{value:30}}]),vertexShader:Ne.meshphong_vert,fragmentShader:Ne.meshphong_frag},standard:{uniforms:vt([me.common,me.envmap,me.aomap,me.lightmap,me.emissivemap,me.bumpmap,me.normalmap,me.displacementmap,me.roughnessmap,me.metalnessmap,me.fog,me.lights,{emissive:{value:new xe(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Ne.meshphysical_vert,fragmentShader:Ne.meshphysical_frag},toon:{uniforms:vt([me.common,me.aomap,me.lightmap,me.emissivemap,me.bumpmap,me.normalmap,me.displacementmap,me.gradientmap,me.fog,me.lights,{emissive:{value:new xe(0)}}]),vertexShader:Ne.meshtoon_vert,fragmentShader:Ne.meshtoon_frag},matcap:{uniforms:vt([me.common,me.bumpmap,me.normalmap,me.displacementmap,me.fog,{matcap:{value:null}}]),vertexShader:Ne.meshmatcap_vert,fragmentShader:Ne.meshmatcap_frag},points:{uniforms:vt([me.points,me.fog]),vertexShader:Ne.points_vert,fragmentShader:Ne.points_frag},dashed:{uniforms:vt([me.common,me.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Ne.linedashed_vert,fragmentShader:Ne.linedashed_frag},depth:{uniforms:vt([me.common,me.displacementmap]),vertexShader:Ne.depth_vert,fragmentShader:Ne.depth_frag},normal:{uniforms:vt([me.common,me.bumpmap,me.normalmap,me.displacementmap,{opacity:{value:1}}]),vertexShader:Ne.normal_vert,fragmentShader:Ne.normal_frag},sprite:{uniforms:vt([me.sprite,me.fog]),vertexShader:Ne.sprite_vert,fragmentShader:Ne.sprite_frag},background:{uniforms:{uvTransform:{value:new It},t2D:{value:null}},vertexShader:Ne.background_vert,fragmentShader:Ne.background_frag},cube:{uniforms:vt([me.envmap,{opacity:{value:1}}]),vertexShader:Ne.cube_vert,fragmentShader:Ne.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Ne.equirect_vert,fragmentShader:Ne.equirect_frag},distanceRGBA:{uniforms:vt([me.common,me.displacementmap,{referencePosition:{value:new z},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Ne.distanceRGBA_vert,fragmentShader:Ne.distanceRGBA_frag},shadow:{uniforms:vt([me.lights,me.fog,{color:{value:new xe(0)},opacity:{value:1}}]),vertexShader:Ne.shadow_vert,fragmentShader:Ne.shadow_frag}};bn.physical={uniforms:vt([bn.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new le(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new xe(0)},transmission:{value:0},transmissionMap:{value:null}}]),vertexShader:Ne.meshphysical_vert,fragmentShader:Ne.meshphysical_frag};function D0(e,t,n,i,r){const s=new xe(0);let o=0,a,l,c=null,f=0,u=null;function d(p,v,y,m){let g=v.isScene===!0?v.background:null;g&&g.isTexture&&(g=t.get(g));const T=e.xr,P=T.getSession&&T.getSession();P&&P.environmentBlendMode==="additive"&&(g=null),g===null?h(s,o):g&&g.isColor&&(h(g,1),m=!0),(e.autoClear||m)&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),g&&(g.isCubeTexture||g.isWebGLCubeRenderTarget||g.mapping===hu)?(l===void 0&&(l=new rt(new vu(1,1,1),new Dt({name:"BackgroundCubeMaterial",uniforms:zr(bn.cube.uniforms),vertexShader:bn.cube.vertexShader,fragmentShader:bn.cube.fragmentShader,side:ht,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(A,M,N){this.matrixWorld.copyPosition(N.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(l)),g.isWebGLCubeRenderTarget&&(g=g.texture),l.material.uniforms.envMap.value=g,l.material.uniforms.flipEnvMap.value=g.isCubeTexture&&g._needsFlipEnvMap?-1:1,(c!==g||f!==g.version||u!==e.toneMapping)&&(l.material.needsUpdate=!0,c=g,f=g.version,u=e.toneMapping),p.unshift(l,l.geometry,l.material,0,0,null)):g&&g.isTexture&&(a===void 0&&(a=new rt(new $h(2,2),new Dt({name:"BackgroundMaterial",uniforms:zr(bn.background.uniforms),vertexShader:bn.background.vertexShader,fragmentShader:bn.background.fragmentShader,side:no,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(a)),a.material.uniforms.t2D.value=g,g.matrixAutoUpdate===!0&&g.updateMatrix(),a.material.uniforms.uvTransform.value.copy(g.matrix),(c!==g||f!==g.version||u!==e.toneMapping)&&(a.material.needsUpdate=!0,c=g,f=g.version,u=e.toneMapping),p.unshift(a,a.geometry,a.material,0,0,null))}function h(p,v){n.buffers.color.setClear(p.r,p.g,p.b,v,r)}return{getClearColor:function(){return s},setClearColor:function(p,v=1){s.set(p),o=v,h(s,o)},getClearAlpha:function(){return o},setClearAlpha:function(p){o=p,h(s,o)},render:d}}function F0(e,t,n,i){const r=e.getParameter(34921),s=i.isWebGL2?null:t.get("OES_vertex_array_object"),o=i.isWebGL2||s!==null,a={},l=v(null);let c=l;function f(Y,X,q,$,ne){let oe=!1;if(o){const fe=p($,q,X);c!==fe&&(c=fe,d(c.object)),oe=y($,ne),oe&&m($,ne)}else{const fe=X.wireframe===!0;(c.geometry!==$.id||c.program!==q.id||c.wireframe!==fe)&&(c.geometry=$.id,c.program=q.id,c.wireframe=fe,oe=!0)}Y.isInstancedMesh===!0&&(oe=!0),ne!==null&&n.update(ne,34963),oe&&(N(Y,X,q,$),ne!==null&&e.bindBuffer(34963,n.get(ne).buffer))}function u(){return i.isWebGL2?e.createVertexArray():s.createVertexArrayOES()}function d(Y){return i.isWebGL2?e.bindVertexArray(Y):s.bindVertexArrayOES(Y)}function h(Y){return i.isWebGL2?e.deleteVertexArray(Y):s.deleteVertexArrayOES(Y)}function p(Y,X,q){const $=q.wireframe===!0;let ne=a[Y.id];ne===void 0&&(ne={},a[Y.id]=ne);let oe=ne[X.id];oe===void 0&&(oe={},ne[X.id]=oe);let fe=oe[$];return fe===void 0&&(fe=v(u()),oe[$]=fe),fe}function v(Y){const X=[],q=[],$=[];for(let ne=0;ne<r;ne++)X[ne]=0,q[ne]=0,$[ne]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:X,enabledAttributes:q,attributeDivisors:$,object:Y,attributes:{},index:null}}function y(Y,X){const q=c.attributes,$=Y.attributes;let ne=0;for(const oe in $){const fe=q[oe],ge=$[oe];if(fe===void 0||fe.attribute!==ge||fe.data!==ge.data)return!0;ne++}return c.attributesNum!==ne||c.index!==X}function m(Y,X){const q={},$=Y.attributes;let ne=0;for(const oe in $){const fe=$[oe],ge={};ge.attribute=fe,fe.data&&(ge.data=fe.data),q[oe]=ge,ne++}c.attributes=q,c.attributesNum=ne,c.index=X}function g(){const Y=c.newAttributes;for(let X=0,q=Y.length;X<q;X++)Y[X]=0}function T(Y){P(Y,0)}function P(Y,X){const q=c.newAttributes,$=c.enabledAttributes,ne=c.attributeDivisors;q[Y]=1,$[Y]===0&&(e.enableVertexAttribArray(Y),$[Y]=1),ne[Y]!==X&&((i.isWebGL2?e:t.get("ANGLE_instanced_arrays"))[i.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](Y,X),ne[Y]=X)}function A(){const Y=c.newAttributes,X=c.enabledAttributes;for(let q=0,$=X.length;q<$;q++)X[q]!==Y[q]&&(e.disableVertexAttribArray(q),X[q]=0)}function M(Y,X,q,$,ne,oe){i.isWebGL2===!0&&(q===5124||q===5125)?e.vertexAttribIPointer(Y,X,q,ne,oe):e.vertexAttribPointer(Y,X,q,$,ne,oe)}function N(Y,X,q,$){if(i.isWebGL2===!1&&(Y.isInstancedMesh||$.isInstancedBufferGeometry)&&t.get("ANGLE_instanced_arrays")===null)return;g();const ne=$.attributes,oe=q.getAttributes(),fe=X.defaultAttributeValues;for(const ge in oe){const he=oe[ge];if(he>=0){const de=ne[ge];if(de!==void 0){const Me=de.normalized,ke=de.itemSize,se=n.get(de);if(se===void 0)continue;const E=se.buffer,S=se.type,D=se.bytesPerElement;if(de.isInterleavedBufferAttribute){const R=de.data,U=R.stride,G=de.offset;R&&R.isInstancedInterleavedBuffer?(P(he,R.meshPerAttribute),$._maxInstanceCount===void 0&&($._maxInstanceCount=R.meshPerAttribute*R.count)):T(he),e.bindBuffer(34962,E),M(he,ke,S,Me,U*D,G*D)}else de.isInstancedBufferAttribute?(P(he,de.meshPerAttribute),$._maxInstanceCount===void 0&&($._maxInstanceCount=de.meshPerAttribute*de.count)):T(he),e.bindBuffer(34962,E),M(he,ke,S,Me,0,0)}else if(ge==="instanceMatrix"){const Me=n.get(Y.instanceMatrix);if(Me===void 0)continue;const ke=Me.buffer,se=Me.type;P(he+0,1),P(he+1,1),P(he+2,1),P(he+3,1),e.bindBuffer(34962,ke),e.vertexAttribPointer(he+0,4,se,!1,64,0),e.vertexAttribPointer(he+1,4,se,!1,64,16),e.vertexAttribPointer(he+2,4,se,!1,64,32),e.vertexAttribPointer(he+3,4,se,!1,64,48)}else if(ge==="instanceColor"){const Me=n.get(Y.instanceColor);if(Me===void 0)continue;const ke=Me.buffer,se=Me.type;P(he,1),e.bindBuffer(34962,ke),e.vertexAttribPointer(he,3,se,!1,12,0)}else if(fe!==void 0){const Me=fe[ge];if(Me!==void 0)switch(Me.length){case 2:e.vertexAttrib2fv(he,Me);break;case 3:e.vertexAttrib3fv(he,Me);break;case 4:e.vertexAttrib4fv(he,Me);break;default:e.vertexAttrib1fv(he,Me)}}}}A()}function B(){H();for(const Y in a){const X=a[Y];for(const q in X){const $=X[q];for(const ne in $)h($[ne].object),delete $[ne];delete X[q]}delete a[Y]}}function W(Y){if(a[Y.id]===void 0)return;const X=a[Y.id];for(const q in X){const $=X[q];for(const ne in $)h($[ne].object),delete $[ne];delete X[q]}delete a[Y.id]}function te(Y){for(const X in a){const q=a[X];if(q[Y.id]===void 0)continue;const $=q[Y.id];for(const ne in $)h($[ne].object),delete $[ne];delete q[Y.id]}}function H(){j(),c!==l&&(c=l,d(c.object))}function j(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:f,reset:H,resetDefaultState:j,dispose:B,releaseStatesOfGeometry:W,releaseStatesOfProgram:te,initAttributes:g,enableAttribute:T,disableUnusedAttributes:A}}function B0(e,t,n,i){const r=i.isWebGL2;let s;function o(c){s=c}function a(c,f){e.drawArrays(s,c,f),n.update(f,s,1)}function l(c,f,u){if(u===0)return;let d,h;if(r)d=e,h="drawArraysInstanced";else if(d=t.get("ANGLE_instanced_arrays"),h="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[h](s,c,f,u),n.update(f,s,u)}this.setMode=o,this.render=a,this.renderInstances=l}function z0(e,t,n){let i;function r(){if(i!==void 0)return i;const M=t.get("EXT_texture_filter_anisotropic");return M!==null?i=e.getParameter(M.MAX_TEXTURE_MAX_ANISOTROPY_EXT):i=0,i}function s(M){if(M==="highp"){if(e.getShaderPrecisionFormat(35633,36338).precision>0&&e.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";M="mediump"}return M==="mediump"&&e.getShaderPrecisionFormat(35633,36337).precision>0&&e.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext<"u"&&e instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext<"u"&&e instanceof WebGL2ComputeRenderingContext;let a=n.precision!==void 0?n.precision:"highp";const l=s(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=n.logarithmicDepthBuffer===!0,f=e.getParameter(34930),u=e.getParameter(35660),d=e.getParameter(3379),h=e.getParameter(34076),p=e.getParameter(34921),v=e.getParameter(36347),y=e.getParameter(36348),m=e.getParameter(36349),g=u>0,T=o||!!t.get("OES_texture_float"),P=g&&T,A=o?e.getParameter(36183):0;return{isWebGL2:o,getMaxAnisotropy:r,getMaxPrecision:s,precision:a,logarithmicDepthBuffer:c,maxTextures:f,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:h,maxAttributes:p,maxVertexUniforms:v,maxVaryings:y,maxFragmentUniforms:m,vertexTextures:g,floatFragmentTextures:T,floatVertexTextures:P,maxSamples:A}}function U0(e){const t=this;let n=null,i=0,r=!1,s=!1;const o=new Bn,a=new It,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(u,d,h){const p=u.length!==0||d||i!==0||r;return r=d,n=f(u,h,0),i=u.length,p},this.beginShadows=function(){s=!0,f(null)},this.endShadows=function(){s=!1,c()},this.setState=function(u,d,h){const p=u.clippingPlanes,v=u.clipIntersection,y=u.clipShadows,m=e.get(u);if(!r||p===null||p.length===0||s&&!y)s?f(null):c();else{const g=s?0:i,T=g*4;let P=m.clippingState||null;l.value=P,P=f(p,d,T,h);for(let A=0;A!==T;++A)P[A]=n[A];m.clippingState=P,this.numIntersection=v?this.numPlanes:0,this.numPlanes+=g}};function c(){l.value!==n&&(l.value=n,l.needsUpdate=i>0),t.numPlanes=i,t.numIntersection=0}function f(u,d,h,p){const v=u!==null?u.length:0;let y=null;if(v!==0){if(y=l.value,p!==!0||y===null){const m=h+v*4,g=d.matrixWorldInverse;a.getNormalMatrix(g),(y===null||y.length<m)&&(y=new Float32Array(m));for(let T=0,P=h;T!==v;++T,P+=4)o.copy(u[T]).applyMatrix4(g,a),o.normal.toArray(y,P),y[P+3]=o.constant}l.value=y,l.needsUpdate=!0}return t.numPlanes=v,t.numIntersection=0,y}}function H0(e){let t=new WeakMap;function n(o,a){return a===sf?o.mapping=fu:a===of&&(o.mapping=du),o}function i(o){if(o&&o.isTexture){const a=o.mapping;if(a===sf||a===of)if(t.has(o)){const l=t.get(o).texture;return n(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=e.getRenderList(),f=e.getRenderTarget(),u=new Vi(l.height/2);return u.fromEquirectangularTexture(e,o),t.set(o,u),e.setRenderTarget(f),e.setRenderList(c),o.addEventListener("dispose",r),n(u.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=t.get(a);l!==void 0&&(t.delete(a),l.dispose())}function s(){t=new WeakMap}return{get:i,dispose:s}}function k0(e){const t={};return{has:function(n){if(t[n]!==void 0)return t[n]!==null;let i;switch(n){case"WEBGL_depth_texture":i=e.getExtension("WEBGL_depth_texture")||e.getExtension("MOZ_WEBGL_depth_texture")||e.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=e.getExtension("EXT_texture_filter_anisotropic")||e.getExtension("MOZ_EXT_texture_filter_anisotropic")||e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=e.getExtension("WEBGL_compressed_texture_s3tc")||e.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=e.getExtension("WEBGL_compressed_texture_pvrtc")||e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=e.getExtension(n)}return t[n]=i,i!==null},get:function(n){return this.has(n)||console.warn("THREE.WebGLRenderer: "+n+" extension not supported."),t[n]}}}function G0(e,t,n,i){const r=new WeakMap,s=new WeakMap;function o(u){const d=u.target,h=r.get(d);h.index!==null&&t.remove(h.index);for(const v in h.attributes)t.remove(h.attributes[v]);d.removeEventListener("dispose",o),r.delete(d);const p=s.get(h);p&&(t.remove(p),s.delete(h)),i.releaseStatesOfGeometry(h),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,n.memory.geometries--}function a(u,d){let h=r.get(d);return h||(d.addEventListener("dispose",o),d.isBufferGeometry?h=d:d.isGeometry&&(d._bufferGeometry===void 0&&(d._bufferGeometry=new Be().setFromObject(u)),h=d._bufferGeometry),r.set(d,h),n.memory.geometries++,h)}function l(u){const d=u.attributes;for(const p in d)t.update(d[p],34962);const h=u.morphAttributes;for(const p in h){const v=h[p];for(let y=0,m=v.length;y<m;y++)t.update(v[y],34962)}}function c(u){const d=[],h=u.index,p=u.attributes.position;let v=0;if(h!==null){const g=h.array;v=h.version;for(let T=0,P=g.length;T<P;T+=3){const A=g[T+0],M=g[T+1],N=g[T+2];d.push(A,M,M,N,N,A)}}else{const g=p.array;v=p.version;for(let T=0,P=g.length/3-1;T<P;T+=3){const A=T+0,M=T+1,N=T+2;d.push(A,M,M,N,N,A)}}const y=new(Yh(d)>65535?Gs:ks)(d,1);y.version=v;const m=s.get(u);m&&t.remove(m),s.set(u,y)}function f(u){const d=s.get(u);if(d){const h=u.index;h!==null&&d.version<h.version&&c(u)}else c(u);return s.get(u)}return{get:a,update:l,getWireframeAttribute:f}}function V0(e,t,n,i){const r=i.isWebGL2;let s;function o(d){s=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function f(d,h){e.drawElements(s,h,a,d*l),n.update(h,s,1)}function u(d,h,p){if(p===0)return;let v,y;if(r)v=e,y="drawElementsInstanced";else if(v=t.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",v===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}v[y](s,h,a,d*l,p),n.update(h,s,p)}this.setMode=o,this.setIndex=c,this.render=f,this.renderInstances=u}function W0(e){const t={geometries:0,textures:0},n={frame:0,calls:0,triangles:0,points:0,lines:0};function i(s,o,a){switch(n.calls++,o){case 4:n.triangles+=a*(s/3);break;case 1:n.lines+=a*(s/2);break;case 3:n.lines+=a*(s-1);break;case 2:n.lines+=a*s;break;case 0:n.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){n.frame++,n.calls=0,n.triangles=0,n.points=0,n.lines=0}return{memory:t,render:n,programs:null,autoReset:!0,reset:r,update:i}}function j0(e,t){return e[0]-t[0]}function q0(e,t){return Math.abs(t[1])-Math.abs(e[1])}function X0(e){const t={},n=new Float32Array(8),i=[];for(let s=0;s<8;s++)i[s]=[s,0];function r(s,o,a,l){const c=s.morphTargetInfluences,f=c===void 0?0:c.length;let u=t[o.id];if(u===void 0){u=[];for(let y=0;y<f;y++)u[y]=[y,0];t[o.id]=u}for(let y=0;y<f;y++){const m=u[y];m[0]=y,m[1]=c[y]}u.sort(q0);for(let y=0;y<8;y++)y<f&&u[y][1]?(i[y][0]=u[y][0],i[y][1]=u[y][1]):(i[y][0]=Number.MAX_SAFE_INTEGER,i[y][1]=0);i.sort(j0);const d=a.morphTargets&&o.morphAttributes.position,h=a.morphNormals&&o.morphAttributes.normal;let p=0;for(let y=0;y<8;y++){const m=i[y],g=m[0],T=m[1];g!==Number.MAX_SAFE_INTEGER&&T?(d&&o.getAttribute("morphTarget"+y)!==d[g]&&o.setAttribute("morphTarget"+y,d[g]),h&&o.getAttribute("morphNormal"+y)!==h[g]&&o.setAttribute("morphNormal"+y,h[g]),n[y]=T,p+=T):(d&&o.hasAttribute("morphTarget"+y)===!0&&o.deleteAttribute("morphTarget"+y),h&&o.hasAttribute("morphNormal"+y)===!0&&o.deleteAttribute("morphNormal"+y),n[y]=0)}const v=o.morphTargetsRelative?1:1-p;l.getUniforms().setValue(e,"morphTargetBaseInfluence",v),l.getUniforms().setValue(e,"morphTargetInfluences",n)}return{update:r}}function Y0(e,t,n,i){let r=new WeakMap;function s(l){const c=i.render.frame,f=l.geometry,u=t.get(l,f);return r.get(u)!==c&&(f.isGeometry&&u.updateFromObject(l),t.update(u),r.set(u,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),n.update(l.instanceMatrix,34962),l.instanceColor!==null&&n.update(l.instanceColor,34962)),u}function o(){r=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),n.remove(c.instanceMatrix),c.instanceColor!==null&&n.remove(c.instanceColor)}return{update:s,dispose:o}}function Vs(e=null,t=1,n=1,i=1){qe.call(this,null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=xt,this.minFilter=xt,this.wrapR=Ct,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}Vs.prototype=Object.create(qe.prototype);Vs.prototype.constructor=Vs;Vs.prototype.isDataTexture2DArray=!0;function Ws(e=null,t=1,n=1,i=1){qe.call(this,null),this.image={data:e,width:t,height:n,depth:i},this.magFilter=xt,this.minFilter=xt,this.wrapR=Ct,this.generateMipmaps=!1,this.flipY=!1,this.needsUpdate=!0}Ws.prototype=Object.create(qe.prototype);Ws.prototype.constructor=Ws;Ws.prototype.isDataTexture3D=!0;const Kh=new qe,J0=new Vs,Z0=new Ws,Qh=new Ei,Pf=[],Rf=[],If=new Float32Array(16),Of=new Float32Array(9),Nf=new Float32Array(4);function es(e,t,n){const i=e[0];if(i<=0||i>0)return e;const r=t*n;let s=Pf[r];if(s===void 0&&(s=new Float32Array(r),Pf[r]=s),t!==0){i.toArray(s,0);for(let o=1,a=0;o!==t;++o)a+=n,e[o].toArray(s,a)}return s}function en(e,t){if(e.length!==t.length)return!1;for(let n=0,i=e.length;n<i;n++)if(e[n]!==t[n])return!1;return!0}function Wt(e,t){for(let n=0,i=t.length;n<i;n++)e[n]=t[n]}function ep(e,t){let n=Rf[t];n===void 0&&(n=new Int32Array(t),Rf[t]=n);for(let i=0;i!==t;++i)n[i]=e.allocateTextureUnit();return n}function $0(e,t){const n=this.cache;n[0]!==t&&(e.uniform1f(this.addr,t),n[0]=t)}function K0(e,t){const n=this.cache;if(t.x!==void 0)(n[0]!==t.x||n[1]!==t.y)&&(e.uniform2f(this.addr,t.x,t.y),n[0]=t.x,n[1]=t.y);else{if(en(n,t))return;e.uniform2fv(this.addr,t),Wt(n,t)}}function Q0(e,t){const n=this.cache;if(t.x!==void 0)(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z)&&(e.uniform3f(this.addr,t.x,t.y,t.z),n[0]=t.x,n[1]=t.y,n[2]=t.z);else if(t.r!==void 0)(n[0]!==t.r||n[1]!==t.g||n[2]!==t.b)&&(e.uniform3f(this.addr,t.r,t.g,t.b),n[0]=t.r,n[1]=t.g,n[2]=t.b);else{if(en(n,t))return;e.uniform3fv(this.addr,t),Wt(n,t)}}function eb(e,t){const n=this.cache;if(t.x!==void 0)(n[0]!==t.x||n[1]!==t.y||n[2]!==t.z||n[3]!==t.w)&&(e.uniform4f(this.addr,t.x,t.y,t.z,t.w),n[0]=t.x,n[1]=t.y,n[2]=t.z,n[3]=t.w);else{if(en(n,t))return;e.uniform4fv(this.addr,t),Wt(n,t)}}function tb(e,t){const n=this.cache,i=t.elements;if(i===void 0){if(en(n,t))return;e.uniformMatrix2fv(this.addr,!1,t),Wt(n,t)}else{if(en(n,i))return;Nf.set(i),e.uniformMatrix2fv(this.addr,!1,Nf),Wt(n,i)}}function nb(e,t){const n=this.cache,i=t.elements;if(i===void 0){if(en(n,t))return;e.uniformMatrix3fv(this.addr,!1,t),Wt(n,t)}else{if(en(n,i))return;Of.set(i),e.uniformMatrix3fv(this.addr,!1,Of),Wt(n,i)}}function ib(e,t){const n=this.cache,i=t.elements;if(i===void 0){if(en(n,t))return;e.uniformMatrix4fv(this.addr,!1,t),Wt(n,t)}else{if(en(n,i))return;If.set(i),e.uniformMatrix4fv(this.addr,!1,If),Wt(n,i)}}function rb(e,t,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),n.safeSetTexture2D(t||Kh,r)}function sb(e,t,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),n.setTexture2DArray(t||J0,r)}function ob(e,t,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),n.setTexture3D(t||Z0,r)}function ab(e,t,n){const i=this.cache,r=n.allocateTextureUnit();i[0]!==r&&(e.uniform1i(this.addr,r),i[0]=r),n.safeSetTextureCube(t||Qh,r)}function lb(e,t){const n=this.cache;n[0]!==t&&(e.uniform1i(this.addr,t),n[0]=t)}function cb(e,t){const n=this.cache;en(n,t)||(e.uniform2iv(this.addr,t),Wt(n,t))}function ub(e,t){const n=this.cache;en(n,t)||(e.uniform3iv(this.addr,t),Wt(n,t))}function fb(e,t){const n=this.cache;en(n,t)||(e.uniform4iv(this.addr,t),Wt(n,t))}function db(e,t){const n=this.cache;n[0]!==t&&(e.uniform1ui(this.addr,t),n[0]=t)}function hb(e){switch(e){case 5126:return $0;case 35664:return K0;case 35665:return Q0;case 35666:return eb;case 35674:return tb;case 35675:return nb;case 35676:return ib;case 5124:case 35670:return lb;case 35667:case 35671:return cb;case 35668:case 35672:return ub;case 35669:case 35673:return fb;case 5125:return db;case 35678:case 36198:case 36298:case 36306:case 35682:return rb;case 35679:case 36299:case 36307:return ob;case 35680:case 36300:case 36308:case 36293:return ab;case 36289:case 36303:case 36311:case 36292:return sb}}function pb(e,t){e.uniform1fv(this.addr,t)}function mb(e,t){e.uniform1iv(this.addr,t)}function gb(e,t){e.uniform2iv(this.addr,t)}function vb(e,t){e.uniform3iv(this.addr,t)}function yb(e,t){e.uniform4iv(this.addr,t)}function xb(e,t){const n=es(t,this.size,2);e.uniform2fv(this.addr,n)}function _b(e,t){const n=es(t,this.size,3);e.uniform3fv(this.addr,n)}function bb(e,t){const n=es(t,this.size,4);e.uniform4fv(this.addr,n)}function wb(e,t){const n=es(t,this.size,4);e.uniformMatrix2fv(this.addr,!1,n)}function Mb(e,t){const n=es(t,this.size,9);e.uniformMatrix3fv(this.addr,!1,n)}function Sb(e,t){const n=es(t,this.size,16);e.uniformMatrix4fv(this.addr,!1,n)}function Tb(e,t,n){const i=t.length,r=ep(n,i);e.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)n.safeSetTexture2D(t[s]||Kh,r[s])}function Eb(e,t,n){const i=t.length,r=ep(n,i);e.uniform1iv(this.addr,r);for(let s=0;s!==i;++s)n.safeSetTextureCube(t[s]||Qh,r[s])}function Ab(e){switch(e){case 5126:return pb;case 35664:return xb;case 35665:return _b;case 35666:return bb;case 35674:return wb;case 35675:return Mb;case 35676:return Sb;case 5124:case 35670:return mb;case 35667:case 35671:return gb;case 35668:case 35672:return vb;case 35669:case 35673:return yb;case 35678:case 36198:case 36298:case 36306:case 35682:return Tb;case 35680:case 36300:case 36308:case 36293:return Eb}}function Lb(e,t,n){this.id=e,this.addr=n,this.cache=[],this.setValue=hb(t.type)}function tp(e,t,n){this.id=e,this.addr=n,this.cache=[],this.size=t.size,this.setValue=Ab(t.type)}tp.prototype.updateCache=function(e){const t=this.cache;e instanceof Float32Array&&t.length!==e.length&&(this.cache=new Float32Array(e.length)),Wt(t,e)};function np(e){this.id=e,this.seq=[],this.map={}}np.prototype.setValue=function(e,t,n){const i=this.seq;for(let r=0,s=i.length;r!==s;++r){const o=i[r];o.setValue(e,t[o.id],n)}};const Ll=/(\w+)(\])?(\[|\.)?/g;function Df(e,t){e.seq.push(t),e.map[t.id]=t}function Cb(e,t,n){const i=e.name,r=i.length;for(Ll.lastIndex=0;;){const s=Ll.exec(i),o=Ll.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){Df(n,c===void 0?new Lb(a,e,t):new tp(a,e,t));break}else{let u=n.map[a];u===void 0&&(u=new np(a),Df(n,u)),n=u}}}function _i(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,35718);for(let i=0;i<n;++i){const r=e.getActiveUniform(t,i),s=e.getUniformLocation(t,r.name);Cb(r,s,this)}}_i.prototype.setValue=function(e,t,n,i){const r=this.map[t];r!==void 0&&r.setValue(e,n,i)};_i.prototype.setOptional=function(e,t,n){const i=t[n];i!==void 0&&this.setValue(e,n,i)};_i.upload=function(e,t,n,i){for(let r=0,s=t.length;r!==s;++r){const o=t[r],a=n[o.id];a.needsUpdate!==!1&&o.setValue(e,a.value,i)}};_i.seqWithValue=function(e,t){const n=[];for(let i=0,r=e.length;i!==r;++i){const s=e[i];s.id in t&&n.push(s)}return n};function Ff(e,t,n){const i=e.createShader(t);return e.shaderSource(i,n),e.compileShader(i),i}let Pb=0;function Rb(e){const t=e.split(`
`);for(let n=0;n<t.length;n++)t[n]=n+1+": "+t[n];return t.join(`
`)}function ip(e){switch(e){case ro:return["Linear","( value )"];case Us:return["sRGB","( value )"];case ky:return["RGBE","( value )"];case Vy:return["RGBM","( value, 7.0 )"];case Wy:return["RGBM","( value, 16.0 )"];case jy:return["RGBD","( value, 256.0 )"];case Hy:return["Gamma","( value, float( GAMMA_FACTOR ) )"];case Gy:return["LogLuv","( value )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",e),["Linear","( value )"]}}function Bf(e,t,n){const i=e.getShaderParameter(t,35713),r=e.getShaderInfoLog(t).trim();if(i&&r==="")return"";const s=e.getShaderSource(t);return"THREE.WebGLShader: gl.getShaderInfoLog() "+n+`
`+r+Rb(s)}function cs(e,t){const n=ip(t);return"vec4 "+e+"( vec4 value ) { return "+n[0]+"ToLinear"+n[1]+"; }"}function Ib(e,t){const n=ip(t);return"vec4 "+e+"( vec4 value ) { return LinearTo"+n[0]+n[1]+"; }"}function Ob(e,t){let n;switch(t){case Uv:n="Linear";break;case Hv:n="Reinhard";break;case kv:n="OptimizedCineon";break;case Gv:n="ACESFilmic";break;case Vv:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",t),n="Linear"}return"vec3 "+e+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function Nb(e){return[e.extensionDerivatives||e.envMapCubeUV||e.bumpMap||e.tangentSpaceNormalMap||e.clearcoatNormalMap||e.flatShading||e.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(e.extensionFragDepth||e.logarithmicDepthBuffer)&&e.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",e.extensionDrawBuffers&&e.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(e.extensionShaderTextureLOD||e.envMap)&&e.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(vs).join(`
`)}function Db(e){const t=[];for(const n in e){const i=e[n];i!==!1&&t.push("#define "+n+" "+i)}return t.join(`
`)}function Fb(e,t){const n={},i=e.getProgramParameter(t,35721);for(let r=0;r<i;r++){const o=e.getActiveAttrib(t,r).name;n[o]=e.getAttribLocation(t,o)}return n}function vs(e){return e!==""}function zf(e,t){return e.replace(/NUM_DIR_LIGHTS/g,t.numDirLights).replace(/NUM_SPOT_LIGHTS/g,t.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,t.numPointLights).replace(/NUM_HEMI_LIGHTS/g,t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,t.numPointLightShadows)}function Uf(e,t){return e.replace(/NUM_CLIPPING_PLANES/g,t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,t.numClippingPlanes-t.numClipIntersection)}const Bb=/^[ \t]*#include +<([\w\d./]+)>/gm;function pc(e){return e.replace(Bb,zb)}function zb(e,t){const n=Ne[t];if(n===void 0)throw new Error("Can not resolve #include <"+t+">");return pc(n)}const Ub=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,Hb=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function Hf(e){return e.replace(Hb,rp).replace(Ub,kb)}function kb(e,t,n,i){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),rp(e,t,n,i)}function rp(e,t,n,i){let r="";for(let s=parseInt(t);s<parseInt(n);s++)r+=i.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return r}function kf(e){let t="precision "+e.precision+` float;
precision `+e.precision+" int;";return e.precision==="highp"?t+=`
#define HIGH_PRECISION`:e.precision==="mediump"?t+=`
#define MEDIUM_PRECISION`:e.precision==="lowp"&&(t+=`
#define LOW_PRECISION`),t}function Gb(e){let t="SHADOWMAP_TYPE_BASIC";return e.shadowMapType===Uh?t="SHADOWMAP_TYPE_PCF":e.shadowMapType===vv?t="SHADOWMAP_TYPE_PCF_SOFT":e.shadowMapType===gs&&(t="SHADOWMAP_TYPE_VSM"),t}function Vb(e){let t="ENVMAP_TYPE_CUBE";if(e.envMap)switch(e.envMapMode){case fu:case du:t="ENVMAP_TYPE_CUBE";break;case hu:case pu:t="ENVMAP_TYPE_CUBE_UV";break}return t}function Wb(e){let t="ENVMAP_MODE_REFLECTION";if(e.envMap)switch(e.envMapMode){case du:case pu:t="ENVMAP_MODE_REFRACTION";break}return t}function jb(e){let t="ENVMAP_BLENDING_NONE";if(e.envMap)switch(e.combine){case ka:t="ENVMAP_BLENDING_MULTIPLY";break;case Bv:t="ENVMAP_BLENDING_MIX";break;case zv:t="ENVMAP_BLENDING_ADD";break}return t}function qb(e,t,n,i){const r=e.getContext(),s=n.defines;let o=n.vertexShader,a=n.fragmentShader;const l=Gb(n),c=Vb(n),f=Wb(n),u=jb(n),d=e.gammaFactor>0?e.gammaFactor:1,h=n.isWebGL2?"":Nb(n),p=Db(s),v=r.createProgram();let y,m,g=n.glslVersion?"#version "+n.glslVersion+`
`:"";n.isRawShaderMaterial?(y=[p].filter(vs).join(`
`),y.length>0&&(y+=`
`),m=[h,p].filter(vs).join(`
`),m.length>0&&(m+=`
`)):(y=[kf(n),"#define SHADER_NAME "+n.shaderName,p,n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+n.maxBones,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+f:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.displacementMap&&n.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.useVertexTexture?"#define BONE_TEXTURE":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&n.flatShading===!1?"#define USE_MORPHNORMALS":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#ifdef USE_COLOR","	attribute vec3 color;","#endif","#ifdef USE_MORPHTARGETS","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(vs).join(`
`),m=[h,kf(n),"#define SHADER_NAME "+n.shaderName,p,n.alphaTest?"#define ALPHATEST "+n.alphaTest+(n.alphaTest%1?"":".0"):"","#define GAMMA_FACTOR "+d,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+f:"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMap&&n.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",n.normalMap&&n.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.sheen?"#define USE_SHEEN":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.vertexTangents?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexUvs?"#define USE_UV":"",n.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",n.logarithmicDepthBuffer&&n.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(n.extensionShaderTextureLOD||n.envMap)&&n.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==Ss?"#define TONE_MAPPING":"",n.toneMapping!==Ss?Ne.tonemapping_pars_fragment:"",n.toneMapping!==Ss?Ob("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",Ne.encodings_pars_fragment,n.map?cs("mapTexelToLinear",n.mapEncoding):"",n.matcap?cs("matcapTexelToLinear",n.matcapEncoding):"",n.envMap?cs("envMapTexelToLinear",n.envMapEncoding):"",n.emissiveMap?cs("emissiveMapTexelToLinear",n.emissiveMapEncoding):"",n.lightMap?cs("lightMapTexelToLinear",n.lightMapEncoding):"",Ib("linearToOutputTexel",n.outputEncoding),n.depthPacking?"#define DEPTH_PACKING "+n.depthPacking:"",`
`].filter(vs).join(`
`)),o=pc(o),o=zf(o,n),o=Uf(o,n),a=pc(a),a=zf(a,n),a=Uf(a,n),o=Hf(o),a=Hf(a),n.isWebGL2&&n.isRawShaderMaterial!==!0&&(g=`#version 300 es
`,y=["#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,m=["#define varying in",n.glslVersion===yf?"":"out highp vec4 pc_fragColor;",n.glslVersion===yf?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+m);const T=g+y+o,P=g+m+a,A=Ff(r,35633,T),M=Ff(r,35632,P);if(r.attachShader(v,A),r.attachShader(v,M),n.index0AttributeName!==void 0?r.bindAttribLocation(v,0,n.index0AttributeName):n.morphTargets===!0&&r.bindAttribLocation(v,0,"position"),r.linkProgram(v),e.debug.checkShaderErrors){const W=r.getProgramInfoLog(v).trim(),te=r.getShaderInfoLog(A).trim(),H=r.getShaderInfoLog(M).trim();let j=!0,Y=!0;if(r.getProgramParameter(v,35714)===!1){j=!1;const X=Bf(r,A,"vertex"),q=Bf(r,M,"fragment");console.error("THREE.WebGLProgram: shader error: ",r.getError(),"35715",r.getProgramParameter(v,35715),"gl.getProgramInfoLog",W,X,q)}else W!==""?console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",W):(te===""||H==="")&&(Y=!1);Y&&(this.diagnostics={runnable:j,programLog:W,vertexShader:{log:te,prefix:y},fragmentShader:{log:H,prefix:m}})}r.deleteShader(A),r.deleteShader(M);let N;this.getUniforms=function(){return N===void 0&&(N=new _i(r,v)),N};let B;return this.getAttributes=function(){return B===void 0&&(B=Fb(r,v)),B},this.destroy=function(){i.releaseStatesOfProgram(this),r.deleteProgram(v),this.program=void 0},this.name=n.shaderName,this.id=Pb++,this.cacheKey=t,this.usedTimes=1,this.program=v,this.vertexShader=A,this.fragmentShader=M,this}function Xb(e,t,n,i,r,s){const o=[],a=i.isWebGL2,l=i.logarithmicDepthBuffer,c=i.floatVertexTextures,f=i.maxVertexUniforms,u=i.vertexTextures;let d=i.precision;const h={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},p=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen","transmissionMap"];function v(M){const B=M.skeleton.bones;if(c)return 1024;{const te=Math.floor((f-20)/4),H=Math.min(te,B.length);return H<B.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+B.length+" bones. This GPU supports "+H+"."),0):H}}function y(M){let N;return M&&M.isTexture?N=M.encoding:M&&M.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),N=M.texture.encoding):N=ro,N}function m(M,N,B,W,te){const H=W.fog,j=M.isMeshStandardMaterial?W.environment:null,Y=t.get(M.envMap||j),X=h[M.type],q=te.isSkinnedMesh?v(te):0;M.precision!==null&&(d=i.getMaxPrecision(M.precision),d!==M.precision&&console.warn("THREE.WebGLProgram.getParameters:",M.precision,"not supported, using",d,"instead."));let $,ne;if(X){const ge=bn[X];$=ge.vertexShader,ne=ge.fragmentShader}else $=M.vertexShader,ne=M.fragmentShader;const oe=e.getRenderTarget();return{isWebGL2:a,shaderID:X,shaderName:M.type,vertexShader:$,fragmentShader:ne,defines:M.defines,isRawShaderMaterial:M.isRawShaderMaterial===!0,glslVersion:M.glslVersion,precision:d,instancing:te.isInstancedMesh===!0,instancingColor:te.isInstancedMesh===!0&&te.instanceColor!==null,supportsVertexTextures:u,outputEncoding:oe!==null?y(oe.texture):e.outputEncoding,map:!!M.map,mapEncoding:y(M.map),matcap:!!M.matcap,matcapEncoding:y(M.matcap),envMap:!!Y,envMapMode:Y&&Y.mapping,envMapEncoding:y(Y),envMapCubeUV:!!Y&&(Y.mapping===hu||Y.mapping===pu),lightMap:!!M.lightMap,lightMapEncoding:y(M.lightMap),aoMap:!!M.aoMap,emissiveMap:!!M.emissiveMap,emissiveMapEncoding:y(M.emissiveMap),bumpMap:!!M.bumpMap,normalMap:!!M.normalMap,objectSpaceNormalMap:M.normalMapType===Yy,tangentSpaceNormalMap:M.normalMapType===Zi,clearcoatMap:!!M.clearcoatMap,clearcoatRoughnessMap:!!M.clearcoatRoughnessMap,clearcoatNormalMap:!!M.clearcoatNormalMap,displacementMap:!!M.displacementMap,roughnessMap:!!M.roughnessMap,metalnessMap:!!M.metalnessMap,specularMap:!!M.specularMap,alphaMap:!!M.alphaMap,gradientMap:!!M.gradientMap,sheen:!!M.sheen,transmissionMap:!!M.transmissionMap,combine:M.combine,vertexTangents:M.normalMap&&M.vertexTangents,vertexColors:M.vertexColors,vertexUvs:!!M.map||!!M.bumpMap||!!M.normalMap||!!M.specularMap||!!M.alphaMap||!!M.emissiveMap||!!M.roughnessMap||!!M.metalnessMap||!!M.clearcoatMap||!!M.clearcoatRoughnessMap||!!M.clearcoatNormalMap||!!M.displacementMap||!!M.transmissionMap,uvsVertexOnly:!(!!M.map||!!M.bumpMap||!!M.normalMap||!!M.specularMap||!!M.alphaMap||!!M.emissiveMap||!!M.roughnessMap||!!M.metalnessMap||!!M.clearcoatNormalMap||!!M.transmissionMap)&&!!M.displacementMap,fog:!!H,useFog:M.fog,fogExp2:H&&H.isFogExp2,flatShading:M.flatShading,sizeAttenuation:M.sizeAttenuation,logarithmicDepthBuffer:l,skinning:M.skinning&&q>0,maxBones:q,useVertexTexture:c,morphTargets:M.morphTargets,morphNormals:M.morphNormals,maxMorphTargets:e.maxMorphTargets,maxMorphNormals:e.maxMorphNormals,numDirLights:N.directional.length,numPointLights:N.point.length,numSpotLights:N.spot.length,numRectAreaLights:N.rectArea.length,numHemiLights:N.hemi.length,numDirLightShadows:N.directionalShadowMap.length,numPointLightShadows:N.pointShadowMap.length,numSpotLightShadows:N.spotShadowMap.length,numClippingPlanes:s.numPlanes,numClipIntersection:s.numIntersection,dithering:M.dithering,shadowMapEnabled:e.shadowMap.enabled&&B.length>0,shadowMapType:e.shadowMap.type,toneMapping:M.toneMapped?e.toneMapping:Ss,physicallyCorrectLights:e.physicallyCorrectLights,premultipliedAlpha:M.premultipliedAlpha,alphaTest:M.alphaTest,doubleSided:M.side===io,flipSided:M.side===ht,depthPacking:M.depthPacking!==void 0?M.depthPacking:!1,index0AttributeName:M.index0AttributeName,extensionDerivatives:M.extensions&&M.extensions.derivatives,extensionFragDepth:M.extensions&&M.extensions.fragDepth,extensionDrawBuffers:M.extensions&&M.extensions.drawBuffers,extensionShaderTextureLOD:M.extensions&&M.extensions.shaderTextureLOD,rendererExtensionFragDepth:a||n.has("EXT_frag_depth"),rendererExtensionDrawBuffers:a||n.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:a||n.has("EXT_shader_texture_lod"),customProgramCacheKey:M.customProgramCacheKey()}}function g(M){const N=[];if(M.shaderID?N.push(M.shaderID):(N.push(M.fragmentShader),N.push(M.vertexShader)),M.defines!==void 0)for(const B in M.defines)N.push(B),N.push(M.defines[B]);if(M.isRawShaderMaterial===!1){for(let B=0;B<p.length;B++)N.push(M[p[B]]);N.push(e.outputEncoding),N.push(e.gammaFactor)}return N.push(M.customProgramCacheKey),N.join()}function T(M){const N=h[M.type];let B;if(N){const W=bn[N];B=ux.clone(W.uniforms)}else B=M.uniforms;return B}function P(M,N){let B;for(let W=0,te=o.length;W<te;W++){const H=o[W];if(H.cacheKey===N){B=H,++B.usedTimes;break}}return B===void 0&&(B=new qb(e,N,M,r),o.push(B)),B}function A(M){if(--M.usedTimes===0){const N=o.indexOf(M);o[N]=o[o.length-1],o.pop(),M.destroy()}}return{getParameters:m,getProgramCacheKey:g,getUniforms:T,acquireProgram:P,releaseProgram:A,programs:o}}function Yb(){let e=new WeakMap;function t(s){let o=e.get(s);return o===void 0&&(o={},e.set(s,o)),o}function n(s){e.delete(s)}function i(s,o,a){e.get(s)[o]=a}function r(){e=new WeakMap}return{get:t,remove:n,update:i,dispose:r}}function Jb(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.program!==t.program?e.program.id-t.program.id:e.material.id!==t.material.id?e.material.id-t.material.id:e.z!==t.z?e.z-t.z:e.id-t.id}function Zb(e,t){return e.groupOrder!==t.groupOrder?e.groupOrder-t.groupOrder:e.renderOrder!==t.renderOrder?e.renderOrder-t.renderOrder:e.z!==t.z?t.z-e.z:e.id-t.id}function Gf(e){const t=[];let n=0;const i=[],r=[],s={id:-1};function o(){n=0,i.length=0,r.length=0}function a(d,h,p,v,y,m){let g=t[n];const T=e.get(p);return g===void 0?(g={id:d.id,object:d,geometry:h,material:p,program:T.program||s,groupOrder:v,renderOrder:d.renderOrder,z:y,group:m},t[n]=g):(g.id=d.id,g.object=d,g.geometry=h,g.material=p,g.program=T.program||s,g.groupOrder=v,g.renderOrder=d.renderOrder,g.z=y,g.group=m),n++,g}function l(d,h,p,v,y,m){const g=a(d,h,p,v,y,m);(p.transparent===!0?r:i).push(g)}function c(d,h,p,v,y,m){const g=a(d,h,p,v,y,m);(p.transparent===!0?r:i).unshift(g)}function f(d,h){i.length>1&&i.sort(d||Jb),r.length>1&&r.sort(h||Zb)}function u(){for(let d=n,h=t.length;d<h;d++){const p=t[d];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.program=null,p.group=null}}return{opaque:i,transparent:r,init:o,push:l,unshift:c,finish:u,sort:f}}function $b(e){let t=new WeakMap;function n(r,s){const o=t.get(r);let a;return o===void 0?(a=new Gf(e),t.set(r,new WeakMap),t.get(r).set(s,a)):(a=o.get(s),a===void 0&&(a=new Gf(e),o.set(s,a))),a}function i(){t=new WeakMap}return{get:n,dispose:i}}function Kb(){const e={};return{get:function(t){if(e[t.id]!==void 0)return e[t.id];let n;switch(t.type){case"DirectionalLight":n={direction:new z,color:new xe};break;case"SpotLight":n={position:new z,direction:new z,color:new xe,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new z,color:new xe,distance:0,decay:0};break;case"HemisphereLight":n={direction:new z,skyColor:new xe,groundColor:new xe};break;case"RectAreaLight":n={color:new xe,position:new z,halfWidth:new z,halfHeight:new z};break}return e[t.id]=n,n}}}function Qb(){const e={};return{get:function(t){if(e[t.id]!==void 0)return e[t.id];let n;switch(t.type){case"DirectionalLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new le};break;case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new le};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new le,shadowCameraNear:1,shadowCameraFar:1e3};break}return e[t.id]=n,n}}}let ew=0;function tw(e,t){return(t.castShadow?1:0)-(e.castShadow?1:0)}function nw(e,t){const n=new Kb,i=Qb(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let f=0;f<9;f++)r.probe.push(new z);const s=new z,o=new Le,a=new Le;function l(f){let u=0,d=0,h=0;for(let N=0;N<9;N++)r.probe[N].set(0,0,0);let p=0,v=0,y=0,m=0,g=0,T=0,P=0,A=0;f.sort(tw);for(let N=0,B=f.length;N<B;N++){const W=f[N],te=W.color,H=W.intensity,j=W.distance,Y=W.shadow&&W.shadow.map?W.shadow.map.texture:null;if(W.isAmbientLight)u+=te.r*H,d+=te.g*H,h+=te.b*H;else if(W.isLightProbe)for(let X=0;X<9;X++)r.probe[X].addScaledVector(W.sh.coefficients[X],H);else if(W.isDirectionalLight){const X=n.get(W);if(X.color.copy(W.color).multiplyScalar(W.intensity),W.castShadow){const q=W.shadow,$=i.get(W);$.shadowBias=q.bias,$.shadowNormalBias=q.normalBias,$.shadowRadius=q.radius,$.shadowMapSize=q.mapSize,r.directionalShadow[p]=$,r.directionalShadowMap[p]=Y,r.directionalShadowMatrix[p]=W.shadow.matrix,T++}r.directional[p]=X,p++}else if(W.isSpotLight){const X=n.get(W);if(X.position.setFromMatrixPosition(W.matrixWorld),X.color.copy(te).multiplyScalar(H),X.distance=j,X.coneCos=Math.cos(W.angle),X.penumbraCos=Math.cos(W.angle*(1-W.penumbra)),X.decay=W.decay,W.castShadow){const q=W.shadow,$=i.get(W);$.shadowBias=q.bias,$.shadowNormalBias=q.normalBias,$.shadowRadius=q.radius,$.shadowMapSize=q.mapSize,r.spotShadow[y]=$,r.spotShadowMap[y]=Y,r.spotShadowMatrix[y]=W.shadow.matrix,A++}r.spot[y]=X,y++}else if(W.isRectAreaLight){const X=n.get(W);X.color.copy(te).multiplyScalar(H),X.halfWidth.set(W.width*.5,0,0),X.halfHeight.set(0,W.height*.5,0),r.rectArea[m]=X,m++}else if(W.isPointLight){const X=n.get(W);if(X.color.copy(W.color).multiplyScalar(W.intensity),X.distance=W.distance,X.decay=W.decay,W.castShadow){const q=W.shadow,$=i.get(W);$.shadowBias=q.bias,$.shadowNormalBias=q.normalBias,$.shadowRadius=q.radius,$.shadowMapSize=q.mapSize,$.shadowCameraNear=q.camera.near,$.shadowCameraFar=q.camera.far,r.pointShadow[v]=$,r.pointShadowMap[v]=Y,r.pointShadowMatrix[v]=W.shadow.matrix,P++}r.point[v]=X,v++}else if(W.isHemisphereLight){const X=n.get(W);X.skyColor.copy(W.color).multiplyScalar(H),X.groundColor.copy(W.groundColor).multiplyScalar(H),r.hemi[g]=X,g++}}m>0&&(t.isWebGL2||e.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=me.LTC_FLOAT_1,r.rectAreaLTC2=me.LTC_FLOAT_2):e.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=me.LTC_HALF_1,r.rectAreaLTC2=me.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=u,r.ambient[1]=d,r.ambient[2]=h;const M=r.hash;(M.directionalLength!==p||M.pointLength!==v||M.spotLength!==y||M.rectAreaLength!==m||M.hemiLength!==g||M.numDirectionalShadows!==T||M.numPointShadows!==P||M.numSpotShadows!==A)&&(r.directional.length=p,r.spot.length=y,r.rectArea.length=m,r.point.length=v,r.hemi.length=g,r.directionalShadow.length=T,r.directionalShadowMap.length=T,r.pointShadow.length=P,r.pointShadowMap.length=P,r.spotShadow.length=A,r.spotShadowMap.length=A,r.directionalShadowMatrix.length=T,r.pointShadowMatrix.length=P,r.spotShadowMatrix.length=A,M.directionalLength=p,M.pointLength=v,M.spotLength=y,M.rectAreaLength=m,M.hemiLength=g,M.numDirectionalShadows=T,M.numPointShadows=P,M.numSpotShadows=A,r.version=ew++)}function c(f,u){let d=0,h=0,p=0,v=0,y=0;const m=u.matrixWorldInverse;for(let g=0,T=f.length;g<T;g++){const P=f[g];if(P.isDirectionalLight){const A=r.directional[d];A.direction.setFromMatrixPosition(P.matrixWorld),s.setFromMatrixPosition(P.target.matrixWorld),A.direction.sub(s),A.direction.transformDirection(m),d++}else if(P.isSpotLight){const A=r.spot[p];A.position.setFromMatrixPosition(P.matrixWorld),A.position.applyMatrix4(m),A.direction.setFromMatrixPosition(P.matrixWorld),s.setFromMatrixPosition(P.target.matrixWorld),A.direction.sub(s),A.direction.transformDirection(m),p++}else if(P.isRectAreaLight){const A=r.rectArea[v];A.position.setFromMatrixPosition(P.matrixWorld),A.position.applyMatrix4(m),a.identity(),o.copy(P.matrixWorld),o.premultiply(m),a.extractRotation(o),A.halfWidth.set(P.width*.5,0,0),A.halfHeight.set(0,P.height*.5,0),A.halfWidth.applyMatrix4(a),A.halfHeight.applyMatrix4(a),v++}else if(P.isPointLight){const A=r.point[h];A.position.setFromMatrixPosition(P.matrixWorld),A.position.applyMatrix4(m),h++}else if(P.isHemisphereLight){const A=r.hemi[y];A.direction.setFromMatrixPosition(P.matrixWorld),A.direction.transformDirection(m),A.direction.normalize(),y++}}}return{setup:l,setupView:c,state:r}}function Vf(e,t){const n=new nw(e,t),i=[],r=[];function s(){i.length=0,r.length=0}function o(u){i.push(u)}function a(u){r.push(u)}function l(){n.setup(i)}function c(u){n.setupView(i,u)}return{init:s,state:{lightsArray:i,shadowsArray:r,lights:n},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function iw(e,t){let n=new WeakMap;function i(s,o=0){let a;return n.has(s)===!1?(a=new Vf(e,t),n.set(s,[]),n.get(s).push(a)):o>=n.get(s).length?(a=new Vf(e,t),n.get(s).push(a)):a=n.get(s)[o],a}function r(){n=new WeakMap}return{get:i,dispose:r}}function Wi(e){we.call(this),this.type="MeshDepthMaterial",this.depthPacking=qy,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}Wi.prototype=Object.create(we.prototype);Wi.prototype.constructor=Wi;Wi.prototype.isMeshDepthMaterial=!0;Wi.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.depthPacking=e.depthPacking,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this};function ji(e){we.call(this),this.type="MeshDistanceMaterial",this.referencePosition=new z,this.nearDistance=1,this.farDistance=1e3,this.skinning=!1,this.morphTargets=!1,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}ji.prototype=Object.create(we.prototype);ji.prototype.constructor=ji;ji.prototype.isMeshDistanceMaterial=!0;ji.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this};var rw=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	float mean = 0.0;
	float squared_mean = 0.0;
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );
	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`,sw=`void main() {
	gl_Position = vec4( position, 1.0 );
}`;function sp(e,t,n){let i=new Va;const r=new le,s=new le,o=new Ge,a=[],l=[],c={},f={0:ht,1:no,2:io},u=new Dt({defines:{SAMPLE_RATE:2/8,HALF_SAMPLE_RATE:1/8},uniforms:{shadow_pass:{value:null},resolution:{value:new le},radius:{value:4}},vertexShader:sw,fragmentShader:rw}),d=u.clone();d.defines.HORIZONTAL_PASS=1;const h=new Be;h.setAttribute("position",new Se(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const p=new rt(h,u),v=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Uh,this.render=function(A,M,N){if(v.enabled===!1||v.autoUpdate===!1&&v.needsUpdate===!1||A.length===0)return;const B=e.getRenderTarget(),W=e.getActiveCubeFace(),te=e.getActiveMipmapLevel(),H=e.state;H.setBlending(ws),H.buffers.color.setClear(1,1,1,1),H.buffers.depth.setTest(!0),H.setScissorTest(!1);for(let j=0,Y=A.length;j<Y;j++){const X=A[j],q=X.shadow;if(q===void 0){console.warn("THREE.WebGLShadowMap:",X,"has no shadow.");continue}if(q.autoUpdate===!1&&q.needsUpdate===!1)continue;r.copy(q.mapSize);const $=q.getFrameExtents();if(r.multiply($),s.copy(q.mapSize),(r.x>n||r.y>n)&&(r.x>n&&(s.x=Math.floor(n/$.x),r.x=s.x*$.x,q.mapSize.x=s.x),r.y>n&&(s.y=Math.floor(n/$.y),r.y=s.y*$.y,q.mapSize.y=s.y)),q.map===null&&!q.isPointLightShadow&&this.type===gs){const oe={minFilter:ct,magFilter:ct,format:pn};q.map=new mn(r.x,r.y,oe),q.map.texture.name=X.name+".shadowMap",q.mapPass=new mn(r.x,r.y,oe),q.camera.updateProjectionMatrix()}if(q.map===null){const oe={minFilter:xt,magFilter:xt,format:pn};q.map=new mn(r.x,r.y,oe),q.map.texture.name=X.name+".shadowMap",q.camera.updateProjectionMatrix()}e.setRenderTarget(q.map),e.clear();const ne=q.getViewportCount();for(let oe=0;oe<ne;oe++){const fe=q.getViewport(oe);o.set(s.x*fe.x,s.y*fe.y,s.x*fe.z,s.y*fe.w),H.viewport(o),q.updateMatrices(X,oe),i=q.getFrustum(),P(M,N,q.camera,X,this.type)}!q.isPointLightShadow&&this.type===gs&&y(q,N),q.needsUpdate=!1}v.needsUpdate=!1,e.setRenderTarget(B,W,te)};function y(A,M){const N=t.update(p);u.uniforms.shadow_pass.value=A.map.texture,u.uniforms.resolution.value=A.mapSize,u.uniforms.radius.value=A.radius,e.setRenderTarget(A.mapPass),e.clear(),e.renderBufferDirect(M,null,N,u,p,null),d.uniforms.shadow_pass.value=A.mapPass.texture,d.uniforms.resolution.value=A.mapSize,d.uniforms.radius.value=A.radius,e.setRenderTarget(A.map),e.clear(),e.renderBufferDirect(M,null,N,d,p,null)}function m(A,M,N){const B=A<<0|M<<1|N<<2;let W=a[B];return W===void 0&&(W=new Wi({depthPacking:Xy,morphTargets:A,skinning:M}),a[B]=W),W}function g(A,M,N){const B=A<<0|M<<1|N<<2;let W=l[B];return W===void 0&&(W=new ji({morphTargets:A,skinning:M}),l[B]=W),W}function T(A,M,N,B,W,te,H){let j=null,Y=m,X=A.customDepthMaterial;if(B.isPointLight===!0&&(Y=g,X=A.customDistanceMaterial),X===void 0){let q=!1;N.morphTargets===!0&&(q=M.morphAttributes&&M.morphAttributes.position&&M.morphAttributes.position.length>0);let $=!1;A.isSkinnedMesh===!0&&(N.skinning===!0?$=!0:console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",A));const ne=A.isInstancedMesh===!0;j=Y(q,$,ne)}else j=X;if(e.localClippingEnabled&&N.clipShadows===!0&&N.clippingPlanes.length!==0){const q=j.uuid,$=N.uuid;let ne=c[q];ne===void 0&&(ne={},c[q]=ne);let oe=ne[$];oe===void 0&&(oe=j.clone(),ne[$]=oe),j=oe}return j.visible=N.visible,j.wireframe=N.wireframe,H===gs?j.side=N.shadowSide!==null?N.shadowSide:N.side:j.side=N.shadowSide!==null?N.shadowSide:f[N.side],j.clipShadows=N.clipShadows,j.clippingPlanes=N.clippingPlanes,j.clipIntersection=N.clipIntersection,j.wireframeLinewidth=N.wireframeLinewidth,j.linewidth=N.linewidth,B.isPointLight===!0&&j.isMeshDistanceMaterial===!0&&(j.referencePosition.setFromMatrixPosition(B.matrixWorld),j.nearDistance=W,j.farDistance=te),j}function P(A,M,N,B,W){if(A.visible===!1)return;if(A.layers.test(M.layers)&&(A.isMesh||A.isLine||A.isPoints)&&(A.castShadow||A.receiveShadow&&W===gs)&&(!A.frustumCulled||i.intersectsObject(A))){A.modelViewMatrix.multiplyMatrices(N.matrixWorldInverse,A.matrixWorld);const j=t.update(A),Y=A.material;if(Array.isArray(Y)){const X=j.groups;for(let q=0,$=X.length;q<$;q++){const ne=X[q],oe=Y[ne.materialIndex];if(oe&&oe.visible){const fe=T(A,j,oe,B,N.near,N.far,W);e.renderBufferDirect(N,null,j,fe,A,ne)}}}else if(Y.visible){const X=T(A,j,Y,B,N.near,N.far,W);e.renderBufferDirect(N,null,j,X,A,null)}}const H=A.children;for(let j=0,Y=H.length;j<Y;j++)P(H[j],M,N,B,W)}}function ow(e,t,n){const i=n.isWebGL2;function r(){let C=!1;const J=new Ge;let Z=null;const K=new Ge(0,0,0,0);return{setMask:function(Q){Z!==Q&&!C&&(e.colorMask(Q,Q,Q,Q),Z=Q)},setLocked:function(Q){C=Q},setClear:function(Q,ae,ue,pe,ce){ce===!0&&(Q*=pe,ae*=pe,ue*=pe),J.set(Q,ae,ue,pe),K.equals(J)===!1&&(e.clearColor(Q,ae,ue,pe),K.copy(J))},reset:function(){C=!1,Z=null,K.set(-1,0,0,0)}}}function s(){let C=!1,J=null,Z=null,K=null;return{setTest:function(Q){Q?ge(2929):he(2929)},setMask:function(Q){J!==Q&&!C&&(e.depthMask(Q),J=Q)},setFunc:function(Q){if(Z!==Q){if(Q)switch(Q){case Pv:e.depthFunc(512);break;case Rv:e.depthFunc(519);break;case Iv:e.depthFunc(513);break;case rc:e.depthFunc(515);break;case Ov:e.depthFunc(514);break;case Nv:e.depthFunc(518);break;case Dv:e.depthFunc(516);break;case Fv:e.depthFunc(517);break;default:e.depthFunc(515)}else e.depthFunc(515);Z=Q}},setLocked:function(Q){C=Q},setClear:function(Q){K!==Q&&(e.clearDepth(Q),K=Q)},reset:function(){C=!1,J=null,Z=null,K=null}}}function o(){let C=!1,J=null,Z=null,K=null,Q=null,ae=null,ue=null,pe=null,ce=null;return{setTest:function(ye){C||(ye?ge(2960):he(2960))},setMask:function(ye){J!==ye&&!C&&(e.stencilMask(ye),J=ye)},setFunc:function(ye,Te,Ke){(Z!==ye||K!==Te||Q!==Ke)&&(e.stencilFunc(ye,Te,Ke),Z=ye,K=Te,Q=Ke)},setOp:function(ye,Te,Ke){(ae!==ye||ue!==Te||pe!==Ke)&&(e.stencilOp(ye,Te,Ke),ae=ye,ue=Te,pe=Ke)},setLocked:function(ye){C=ye},setClear:function(ye){ce!==ye&&(e.clearStencil(ye),ce=ye)},reset:function(){C=!1,J=null,Z=null,K=null,Q=null,ae=null,ue=null,pe=null,ce=null}}}const a=new r,l=new s,c=new o;let f={},u=null,d=null,h=null,p=null,v=null,y=null,m=null,g=null,T=null,P=!1,A=null,M=null,N=null,B=null,W=null;const te=e.getParameter(35661);let H=!1,j=0;const Y=e.getParameter(7938);Y.indexOf("WebGL")!==-1?(j=parseFloat(/^WebGL (\d)/.exec(Y)[1]),H=j>=1):Y.indexOf("OpenGL ES")!==-1&&(j=parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]),H=j>=2);let X=null,q={};const $=new Ge,ne=new Ge;function oe(C,J,Z){const K=new Uint8Array(4),Q=e.createTexture();e.bindTexture(C,Q),e.texParameteri(C,10241,9728),e.texParameteri(C,10240,9728);for(let ae=0;ae<Z;ae++)e.texImage2D(J+ae,0,6408,1,1,0,6408,5121,K);return Q}const fe={};fe[3553]=oe(3553,3553,1),fe[34067]=oe(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),ge(2929),l.setFunc(rc),S(!1),D(Qu),ge(2884),se(ws);function ge(C){f[C]!==!0&&(e.enable(C),f[C]=!0)}function he(C){f[C]!==!1&&(e.disable(C),f[C]=!1)}function de(C){return u!==C?(e.useProgram(C),u=C,!0):!1}const Me={[vr]:32774,[xv]:32778,[_v]:32779};if(i)Me[nf]=32775,Me[rf]=32776;else{const C=t.get("EXT_blend_minmax");C!==null&&(Me[nf]=C.MIN_EXT,Me[rf]=C.MAX_EXT)}const ke={[bv]:0,[wv]:1,[Mv]:768,[kh]:770,[Cv]:776,[Av]:774,[Tv]:772,[Sv]:769,[Gh]:771,[Lv]:775,[Ev]:773};function se(C,J,Z,K,Q,ae,ue,pe){if(C===ws){d&&(he(3042),d=!1);return}if(d||(ge(3042),d=!0),C!==yv){if(C!==h||pe!==P){if((p!==vr||m!==vr)&&(e.blendEquation(32774),p=vr,m=vr),pe)switch(C){case Ms:e.blendFuncSeparate(1,771,1,771);break;case ic:e.blendFunc(1,1);break;case ef:e.blendFuncSeparate(0,0,769,771);break;case tf:e.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",C);break}else switch(C){case Ms:e.blendFuncSeparate(770,771,1,771);break;case ic:e.blendFunc(770,1);break;case ef:e.blendFunc(0,769);break;case tf:e.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",C);break}v=null,y=null,g=null,T=null,h=C,P=pe}return}Q=Q||J,ae=ae||Z,ue=ue||K,(J!==p||Q!==m)&&(e.blendEquationSeparate(Me[J],Me[Q]),p=J,m=Q),(Z!==v||K!==y||ae!==g||ue!==T)&&(e.blendFuncSeparate(ke[Z],ke[K],ke[ae],ke[ue]),v=Z,y=K,g=ae,T=ue),h=C,P=null}function E(C,J){C.side===io?he(2884):ge(2884);let Z=C.side===ht;J&&(Z=!Z),S(Z),C.blending===Ms&&C.transparent===!1?se(ws):se(C.blending,C.blendEquation,C.blendSrc,C.blendDst,C.blendEquationAlpha,C.blendSrcAlpha,C.blendDstAlpha,C.premultipliedAlpha),l.setFunc(C.depthFunc),l.setTest(C.depthTest),l.setMask(C.depthWrite),a.setMask(C.colorWrite);const K=C.stencilWrite;c.setTest(K),K&&(c.setMask(C.stencilWriteMask),c.setFunc(C.stencilFunc,C.stencilRef,C.stencilFuncMask),c.setOp(C.stencilFail,C.stencilZFail,C.stencilZPass)),U(C.polygonOffset,C.polygonOffsetFactor,C.polygonOffsetUnits)}function S(C){A!==C&&(C?e.frontFace(2304):e.frontFace(2305),A=C)}function D(C){C!==mv?(ge(2884),C!==M&&(C===Qu?e.cullFace(1029):C===gv?e.cullFace(1028):e.cullFace(1032))):he(2884),M=C}function R(C){C!==N&&(H&&e.lineWidth(C),N=C)}function U(C,J,Z){C?(ge(32823),(B!==J||W!==Z)&&(e.polygonOffset(J,Z),B=J,W=Z)):he(32823)}function G(C){C?ge(3089):he(3089)}function x(C){C===void 0&&(C=33984+te-1),X!==C&&(e.activeTexture(C),X=C)}function _(C,J){X===null&&x();let Z=q[X];Z===void 0&&(Z={type:void 0,texture:void 0},q[X]=Z),(Z.type!==C||Z.texture!==J)&&(e.bindTexture(C,J||fe[C]),Z.type=C,Z.texture=J)}function L(){const C=q[X];C!==void 0&&C.type!==void 0&&(e.bindTexture(C.type,null),C.type=void 0,C.texture=void 0)}function F(){try{e.compressedTexImage2D.apply(e,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function O(){try{e.texImage2D.apply(e,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function b(){try{e.texImage3D.apply(e,arguments)}catch(C){console.error("THREE.WebGLState:",C)}}function w(C){$.equals(C)===!1&&(e.scissor(C.x,C.y,C.z,C.w),$.copy(C))}function V(C){ne.equals(C)===!1&&(e.viewport(C.x,C.y,C.z,C.w),ne.copy(C))}function k(){f={},X=null,q={},u=null,d=null,h=null,p=null,v=null,y=null,m=null,g=null,T=null,P=!1,A=null,M=null,N=null,B=null,W=null,a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:ge,disable:he,useProgram:de,setBlending:se,setMaterial:E,setFlipSided:S,setCullFace:D,setLineWidth:R,setPolygonOffset:U,setScissorTest:G,activeTexture:x,bindTexture:_,unbindTexture:L,compressedTexImage2D:F,texImage2D:O,texImage3D:b,scissor:w,viewport:V,reset:k}}function aw(e,t,n,i,r,s,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,f=r.maxTextureSize,u=r.maxSamples,d=new WeakMap;let h,p=!1;try{p=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function v(b,w){return p?new OffscreenCanvas(b,w):document.createElementNS("http://www.w3.org/1999/xhtml","canvas")}function y(b,w,V,k){let C=1;if((b.width>k||b.height>k)&&(C=k/Math.max(b.width,b.height)),C<1||w===!0)if(typeof HTMLImageElement<"u"&&b instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&b instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&b instanceof ImageBitmap){const J=w?Ee.floorPowerOfTwo:Math.floor,Z=J(C*b.width),K=J(C*b.height);h===void 0&&(h=v(Z,K));const Q=V?v(Z,K):h;return Q.width=Z,Q.height=K,Q.getContext("2d").drawImage(b,0,0,Z,K),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+b.width+"x"+b.height+") to ("+Z+"x"+K+")."),Q}else return"data"in b&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+b.width+"x"+b.height+")."),b;return b}function m(b){return Ee.isPowerOfTwo(b.width)&&Ee.isPowerOfTwo(b.height)}function g(b){return a?!1:b.wrapS!==Ct||b.wrapT!==Ct||b.minFilter!==xt&&b.minFilter!==ct}function T(b,w){return b.generateMipmaps&&w&&b.minFilter!==xt&&b.minFilter!==ct}function P(b,w,V,k){e.generateMipmap(b);const C=i.get(w);C.__maxMipLevel=Math.log(Math.max(V,k))*Math.LOG2E}function A(b,w,V){if(a===!1)return w;if(b!==null){if(e[b]!==void 0)return e[b];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+b+"'")}let k=w;return w===6403&&(V===5126&&(k=33326),V===5131&&(k=33325),V===5121&&(k=33321)),w===6407&&(V===5126&&(k=34837),V===5131&&(k=34843),V===5121&&(k=32849)),w===6408&&(V===5126&&(k=34836),V===5131&&(k=34842),V===5121&&(k=32856)),(k===33325||k===33326||k===34842||k===34836)&&t.get("EXT_color_buffer_float"),k}function M(b){return b===xt||b===sc||b===oc?9728:9729}function N(b){const w=b.target;w.removeEventListener("dispose",N),W(w),w.isVideoTexture&&d.delete(w),o.memory.textures--}function B(b){const w=b.target;w.removeEventListener("dispose",B),te(w),o.memory.textures--}function W(b){const w=i.get(b);w.__webglInit!==void 0&&(e.deleteTexture(w.__webglTexture),i.remove(b))}function te(b){const w=i.get(b),V=i.get(b.texture);if(!!b){if(V.__webglTexture!==void 0&&e.deleteTexture(V.__webglTexture),b.depthTexture&&b.depthTexture.dispose(),b.isWebGLCubeRenderTarget)for(let k=0;k<6;k++)e.deleteFramebuffer(w.__webglFramebuffer[k]),w.__webglDepthbuffer&&e.deleteRenderbuffer(w.__webglDepthbuffer[k]);else e.deleteFramebuffer(w.__webglFramebuffer),w.__webglDepthbuffer&&e.deleteRenderbuffer(w.__webglDepthbuffer),w.__webglMultisampledFramebuffer&&e.deleteFramebuffer(w.__webglMultisampledFramebuffer),w.__webglColorRenderbuffer&&e.deleteRenderbuffer(w.__webglColorRenderbuffer),w.__webglDepthRenderbuffer&&e.deleteRenderbuffer(w.__webglDepthRenderbuffer);i.remove(b.texture),i.remove(b)}}let H=0;function j(){H=0}function Y(){const b=H;return b>=l&&console.warn("THREE.WebGLTextures: Trying to use "+b+" texture units while this GPU supports only "+l),H+=1,b}function X(b,w){const V=i.get(b);if(b.isVideoTexture&&x(b),b.version>0&&V.__version!==b.version){const k=b.image;if(k===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(k.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{de(V,b,w);return}}n.activeTexture(33984+w),n.bindTexture(3553,V.__webglTexture)}function q(b,w){const V=i.get(b);if(b.version>0&&V.__version!==b.version){de(V,b,w);return}n.activeTexture(33984+w),n.bindTexture(35866,V.__webglTexture)}function $(b,w){const V=i.get(b);if(b.version>0&&V.__version!==b.version){de(V,b,w);return}n.activeTexture(33984+w),n.bindTexture(32879,V.__webglTexture)}function ne(b,w){const V=i.get(b);if(b.version>0&&V.__version!==b.version){Me(V,b,w);return}n.activeTexture(33984+w),n.bindTexture(34067,V.__webglTexture)}const oe={[Un]:10497,[Ct]:33071,[ua]:33648},fe={[xt]:9728,[sc]:9984,[oc]:9986,[ct]:9729,[Wh]:9985,[Br]:9987};function ge(b,w,V){V?(e.texParameteri(b,10242,oe[w.wrapS]),e.texParameteri(b,10243,oe[w.wrapT]),(b===32879||b===35866)&&e.texParameteri(b,32882,oe[w.wrapR]),e.texParameteri(b,10240,fe[w.magFilter]),e.texParameteri(b,10241,fe[w.minFilter])):(e.texParameteri(b,10242,33071),e.texParameteri(b,10243,33071),(b===32879||b===35866)&&e.texParameteri(b,32882,33071),(w.wrapS!==Ct||w.wrapT!==Ct)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),e.texParameteri(b,10240,M(w.magFilter)),e.texParameteri(b,10241,M(w.minFilter)),w.minFilter!==xt&&w.minFilter!==ct&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));const k=t.get("EXT_texture_filter_anisotropic");if(k){if(w.type===di&&t.get("OES_texture_float_linear")===null||w.type===da&&(a||t.get("OES_texture_half_float_linear"))===null)return;(w.anisotropy>1||i.get(w).__currentAnisotropy)&&(e.texParameterf(b,k.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(w.anisotropy,r.getMaxAnisotropy())),i.get(w).__currentAnisotropy=w.anisotropy)}}function he(b,w){b.__webglInit===void 0&&(b.__webglInit=!0,w.addEventListener("dispose",N),b.__webglTexture=e.createTexture(),o.memory.textures++)}function de(b,w,V){let k=3553;w.isDataTexture2DArray&&(k=35866),w.isDataTexture3D&&(k=32879),he(b,w),n.activeTexture(33984+V),n.bindTexture(k,b.__webglTexture),e.pixelStorei(37440,w.flipY),e.pixelStorei(37441,w.premultiplyAlpha),e.pixelStorei(3317,w.unpackAlignment);const C=g(w)&&m(w.image)===!1,J=y(w.image,C,!1,f),Z=m(J)||a,K=s.convert(w.format);let Q=s.convert(w.type),ae=A(w.internalFormat,K,Q);ge(k,w,Z);let ue;const pe=w.mipmaps;if(w.isDepthTexture)ae=6402,a?w.type===di?ae=36012:w.type===ra?ae=33190:w.type===Ts?ae=35056:ae=33189:w.type===di&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),w.format===Cr&&ae===6402&&w.type!==fa&&w.type!==ra&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),w.type=fa,Q=s.convert(w.type)),w.format===Bs&&ae===6402&&(ae=34041,w.type!==Ts&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),w.type=Ts,Q=s.convert(w.type))),n.texImage2D(3553,0,ae,J.width,J.height,0,K,Q,null);else if(w.isDataTexture)if(pe.length>0&&Z){for(let ce=0,ye=pe.length;ce<ye;ce++)ue=pe[ce],n.texImage2D(3553,ce,ae,ue.width,ue.height,0,K,Q,ue.data);w.generateMipmaps=!1,b.__maxMipLevel=pe.length-1}else n.texImage2D(3553,0,ae,J.width,J.height,0,K,Q,J.data),b.__maxMipLevel=0;else if(w.isCompressedTexture){for(let ce=0,ye=pe.length;ce<ye;ce++)ue=pe[ce],w.format!==pn&&w.format!==xi?K!==null?n.compressedTexImage2D(3553,ce,ae,ue.width,ue.height,0,ue.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):n.texImage2D(3553,ce,ae,ue.width,ue.height,0,K,Q,ue.data);b.__maxMipLevel=pe.length-1}else if(w.isDataTexture2DArray)n.texImage3D(35866,0,ae,J.width,J.height,J.depth,0,K,Q,J.data),b.__maxMipLevel=0;else if(w.isDataTexture3D)n.texImage3D(32879,0,ae,J.width,J.height,J.depth,0,K,Q,J.data),b.__maxMipLevel=0;else if(pe.length>0&&Z){for(let ce=0,ye=pe.length;ce<ye;ce++)ue=pe[ce],n.texImage2D(3553,ce,ae,K,Q,ue);w.generateMipmaps=!1,b.__maxMipLevel=pe.length-1}else n.texImage2D(3553,0,ae,K,Q,J),b.__maxMipLevel=0;T(w,Z)&&P(k,w,J.width,J.height),b.__version=w.version,w.onUpdate&&w.onUpdate(w)}function Me(b,w,V){if(w.image.length!==6)return;he(b,w),n.activeTexture(33984+V),n.bindTexture(34067,b.__webglTexture),e.pixelStorei(37440,w.flipY);const k=w&&(w.isCompressedTexture||w.image[0].isCompressedTexture),C=w.image[0]&&w.image[0].isDataTexture,J=[];for(let ce=0;ce<6;ce++)!k&&!C?J[ce]=y(w.image[ce],!1,!0,c):J[ce]=C?w.image[ce].image:w.image[ce];const Z=J[0],K=m(Z)||a,Q=s.convert(w.format),ae=s.convert(w.type),ue=A(w.internalFormat,Q,ae);ge(34067,w,K);let pe;if(k){for(let ce=0;ce<6;ce++){pe=J[ce].mipmaps;for(let ye=0;ye<pe.length;ye++){const Te=pe[ye];w.format!==pn&&w.format!==xi?Q!==null?n.compressedTexImage2D(34069+ce,ye,ue,Te.width,Te.height,0,Te.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):n.texImage2D(34069+ce,ye,ue,Te.width,Te.height,0,Q,ae,Te.data)}}b.__maxMipLevel=pe.length-1}else{pe=w.mipmaps;for(let ce=0;ce<6;ce++)if(C){n.texImage2D(34069+ce,0,ue,J[ce].width,J[ce].height,0,Q,ae,J[ce].data);for(let ye=0;ye<pe.length;ye++){const Ke=pe[ye].image[ce].image;n.texImage2D(34069+ce,ye+1,ue,Ke.width,Ke.height,0,Q,ae,Ke.data)}}else{n.texImage2D(34069+ce,0,ue,Q,ae,J[ce]);for(let ye=0;ye<pe.length;ye++){const Te=pe[ye];n.texImage2D(34069+ce,ye+1,ue,Q,ae,Te.image[ce])}}b.__maxMipLevel=pe.length}T(w,K)&&P(34067,w,Z.width,Z.height),b.__version=w.version,w.onUpdate&&w.onUpdate(w)}function ke(b,w,V,k){const C=s.convert(w.texture.format),J=s.convert(w.texture.type),Z=A(w.texture.internalFormat,C,J);n.texImage2D(k,0,Z,w.width,w.height,0,C,J,null),e.bindFramebuffer(36160,b),e.framebufferTexture2D(36160,V,k,i.get(w.texture).__webglTexture,0),e.bindFramebuffer(36160,null)}function se(b,w,V){if(e.bindRenderbuffer(36161,b),w.depthBuffer&&!w.stencilBuffer){let k=33189;if(V){const C=w.depthTexture;C&&C.isDepthTexture&&(C.type===di?k=36012:C.type===ra&&(k=33190));const J=G(w);e.renderbufferStorageMultisample(36161,J,k,w.width,w.height)}else e.renderbufferStorage(36161,k,w.width,w.height);e.framebufferRenderbuffer(36160,36096,36161,b)}else if(w.depthBuffer&&w.stencilBuffer){if(V){const k=G(w);e.renderbufferStorageMultisample(36161,k,35056,w.width,w.height)}else e.renderbufferStorage(36161,34041,w.width,w.height);e.framebufferRenderbuffer(36160,33306,36161,b)}else{const k=s.convert(w.texture.format),C=s.convert(w.texture.type),J=A(w.texture.internalFormat,k,C);if(V){const Z=G(w);e.renderbufferStorageMultisample(36161,Z,J,w.width,w.height)}else e.renderbufferStorage(36161,J,w.width,w.height)}e.bindRenderbuffer(36161,null)}function E(b,w){if(w&&w.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(e.bindFramebuffer(36160,b),!(w.depthTexture&&w.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!i.get(w.depthTexture).__webglTexture||w.depthTexture.image.width!==w.width||w.depthTexture.image.height!==w.height)&&(w.depthTexture.image.width=w.width,w.depthTexture.image.height=w.height,w.depthTexture.needsUpdate=!0),X(w.depthTexture,0);const k=i.get(w.depthTexture).__webglTexture;if(w.depthTexture.format===Cr)e.framebufferTexture2D(36160,36096,3553,k,0);else if(w.depthTexture.format===Bs)e.framebufferTexture2D(36160,33306,3553,k,0);else throw new Error("Unknown depthTexture format")}function S(b){const w=i.get(b),V=b.isWebGLCubeRenderTarget===!0;if(b.depthTexture){if(V)throw new Error("target.depthTexture not supported in Cube render targets");E(w.__webglFramebuffer,b)}else if(V){w.__webglDepthbuffer=[];for(let k=0;k<6;k++)e.bindFramebuffer(36160,w.__webglFramebuffer[k]),w.__webglDepthbuffer[k]=e.createRenderbuffer(),se(w.__webglDepthbuffer[k],b,!1)}else e.bindFramebuffer(36160,w.__webglFramebuffer),w.__webglDepthbuffer=e.createRenderbuffer(),se(w.__webglDepthbuffer,b,!1);e.bindFramebuffer(36160,null)}function D(b){const w=i.get(b),V=i.get(b.texture);b.addEventListener("dispose",B),V.__webglTexture=e.createTexture(),o.memory.textures++;const k=b.isWebGLCubeRenderTarget===!0,C=b.isWebGLMultisampleRenderTarget===!0,J=m(b)||a;if(a&&b.texture.format===xi&&(b.texture.type===di||b.texture.type===da)&&(b.texture.format=pn,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),k){w.__webglFramebuffer=[];for(let Z=0;Z<6;Z++)w.__webglFramebuffer[Z]=e.createFramebuffer()}else if(w.__webglFramebuffer=e.createFramebuffer(),C)if(a){w.__webglMultisampledFramebuffer=e.createFramebuffer(),w.__webglColorRenderbuffer=e.createRenderbuffer(),e.bindRenderbuffer(36161,w.__webglColorRenderbuffer);const Z=s.convert(b.texture.format),K=s.convert(b.texture.type),Q=A(b.texture.internalFormat,Z,K),ae=G(b);e.renderbufferStorageMultisample(36161,ae,Q,b.width,b.height),e.bindFramebuffer(36160,w.__webglMultisampledFramebuffer),e.framebufferRenderbuffer(36160,36064,36161,w.__webglColorRenderbuffer),e.bindRenderbuffer(36161,null),b.depthBuffer&&(w.__webglDepthRenderbuffer=e.createRenderbuffer(),se(w.__webglDepthRenderbuffer,b,!0)),e.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(k){n.bindTexture(34067,V.__webglTexture),ge(34067,b.texture,J);for(let Z=0;Z<6;Z++)ke(w.__webglFramebuffer[Z],b,36064,34069+Z);T(b.texture,J)&&P(34067,b.texture,b.width,b.height),n.bindTexture(34067,null)}else n.bindTexture(3553,V.__webglTexture),ge(3553,b.texture,J),ke(w.__webglFramebuffer,b,36064,3553),T(b.texture,J)&&P(3553,b.texture,b.width,b.height),n.bindTexture(3553,null);b.depthBuffer&&S(b)}function R(b){const w=b.texture,V=m(b)||a;if(T(w,V)){const k=b.isWebGLCubeRenderTarget?34067:3553,C=i.get(w).__webglTexture;n.bindTexture(k,C),P(k,w,b.width,b.height),n.bindTexture(k,null)}}function U(b){if(b.isWebGLMultisampleRenderTarget)if(a){const w=i.get(b);e.bindFramebuffer(36008,w.__webglMultisampledFramebuffer),e.bindFramebuffer(36009,w.__webglFramebuffer);const V=b.width,k=b.height;let C=16384;b.depthBuffer&&(C|=256),b.stencilBuffer&&(C|=1024),e.blitFramebuffer(0,0,V,k,0,0,V,k,C,9728),e.bindFramebuffer(36160,w.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function G(b){return a&&b.isWebGLMultisampleRenderTarget?Math.min(u,b.samples):0}function x(b){const w=o.render.frame;d.get(b)!==w&&(d.set(b,w),b.update())}let _=!1,L=!1;function F(b,w){b&&b.isWebGLRenderTarget&&(_===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),_=!0),b=b.texture),X(b,w)}function O(b,w){b&&b.isWebGLCubeRenderTarget&&(L===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),L=!0),b=b.texture),ne(b,w)}this.allocateTextureUnit=Y,this.resetTextureUnits=j,this.setTexture2D=X,this.setTexture2DArray=q,this.setTexture3D=$,this.setTextureCube=ne,this.setupRenderTarget=D,this.updateRenderTargetMipmap=R,this.updateMultisampleRenderTarget=U,this.safeSetTexture2D=F,this.safeSetTextureCube=O}function lw(e,t,n){const i=n.isWebGL2;function r(s){let o;if(s===mu)return 5121;if(s===Xv)return 32819;if(s===Yv)return 32820;if(s===Jv)return 33635;if(s===Wv)return 5120;if(s===jv)return 5122;if(s===fa)return 5123;if(s===qv)return 5124;if(s===ra)return 5125;if(s===di)return 5126;if(s===da)return i?5131:(o=t.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(s===Zv)return 6406;if(s===xi)return 6407;if(s===pn)return 6408;if(s===$v)return 6409;if(s===Kv)return 6410;if(s===Cr)return 6402;if(s===Bs)return 34041;if(s===Qv)return 6403;if(s===ey)return 36244;if(s===ty)return 33319;if(s===ny)return 33320;if(s===iy)return 36248;if(s===ry)return 36249;if(s===af||s===lf||s===cf||s===uf)if(o=t.get("WEBGL_compressed_texture_s3tc"),o!==null){if(s===af)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(s===lf)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(s===cf)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(s===uf)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(s===ff||s===df||s===hf||s===pf)if(o=t.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(s===ff)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(s===df)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(s===hf)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(s===pf)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(s===sy)return o=t.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((s===mf||s===gf)&&(o=t.get("WEBGL_compressed_texture_etc"),o!==null)){if(s===mf)return o.COMPRESSED_RGB8_ETC2;if(s===gf)return o.COMPRESSED_RGBA8_ETC2_EAC}if(s===oy||s===ay||s===ly||s===cy||s===uy||s===fy||s===dy||s===hy||s===py||s===my||s===gy||s===vy||s===yy||s===xy||s===by||s===wy||s===My||s===Sy||s===Ty||s===Ey||s===Ay||s===Ly||s===Cy||s===Py||s===Ry||s===Iy||s===Oy||s===Ny)return o=t.get("WEBGL_compressed_texture_astc"),o!==null?s:null;if(s===_y)return o=t.get("EXT_texture_compression_bptc"),o!==null?s:null;if(s===Ts)return i?34042:(o=t.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}function mc(e=[]){lt.call(this),this.cameras=e}mc.prototype=Object.assign(Object.create(lt.prototype),{constructor:mc,isArrayCamera:!0});function Sn(){be.call(this),this.type="Group"}Sn.prototype=Object.assign(Object.create(be.prototype),{constructor:Sn,isGroup:!0});function As(){this._targetRay=null,this._grip=null,this._hand=null}Object.assign(As.prototype,{constructor:As,getHandSpace:function(){if(this._hand===null&&(this._hand=new Sn,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints=[],this._hand.inputState={pinching:!1},window.XRHand))for(let e=0;e<=window.XRHand.LITTLE_PHALANX_TIP;e++){const t=new Sn;t.matrixAutoUpdate=!1,t.visible=!1,this._hand.joints.push(t),this._hand.add(t)}return this._hand},getTargetRaySpace:function(){return this._targetRay===null&&(this._targetRay=new Sn,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1),this._targetRay},getGripSpace:function(){return this._grip===null&&(this._grip=new Sn,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1),this._grip},dispatchEvent:function(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this},disconnect:function(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this},update:function(e,t,n){let i=null,r=null,s=null;const o=this._targetRay,a=this._grip,l=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(l&&e.hand){s=!0;for(let c=0;c<=window.XRHand.LITTLE_PHALANX_TIP;c++)if(e.hand[c]){const f=t.getJointPose(e.hand[c],n),u=l.joints[c];f!==null&&(u.matrix.fromArray(f.transform.matrix),u.matrix.decompose(u.position,u.rotation,u.scale),u.jointRadius=f.radius),u.visible=f!==null;const d=l.joints[window.XRHand.INDEX_PHALANX_TIP],h=l.joints[window.XRHand.THUMB_PHALANX_TIP],p=d.position.distanceTo(h.position),v=.02,y=.005;l.inputState.pinching&&p>v+y?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&p<=v-y&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}}else o!==null&&(i=t.getPose(e.targetRaySpace,n),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale))),a!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,n),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale)));return o!==null&&(o.visible=i!==null),a!==null&&(a.visible=r!==null),l!==null&&(l.visible=s!==null),this}});function op(e,t){const n=this;let i=null,r=1,s=null,o="local-floor",a=null;const l=[],c=new Map,f=new lt;f.layers.enable(1),f.viewport=new Ge;const u=new lt;u.layers.enable(2),u.viewport=new Ge;const d=[f,u],h=new mc;h.layers.enable(1),h.layers.enable(2);let p=null,v=null;this.enabled=!1,this.isPresenting=!1,this.getController=function(H){let j=l[H];return j===void 0&&(j=new As,l[H]=j),j.getTargetRaySpace()},this.getControllerGrip=function(H){let j=l[H];return j===void 0&&(j=new As,l[H]=j),j.getGripSpace()},this.getHand=function(H){let j=l[H];return j===void 0&&(j=new As,l[H]=j),j.getHandSpace()};function y(H){const j=c.get(H.inputSource);j&&j.dispatchEvent({type:H.type,data:H.inputSource})}function m(){c.forEach(function(H,j){H.disconnect(j)}),c.clear(),e.setFramebuffer(null),e.setRenderTarget(e.getRenderTarget()),te.stop(),n.isPresenting=!1,n.dispatchEvent({type:"sessionend"})}function g(H){s=H,te.setContext(i),te.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}this.setFramebufferScaleFactor=function(H){r=H,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(H){o=H,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return s},this.getSession=function(){return i},this.setSession=function(H){if(i=H,i!==null){i.addEventListener("select",y),i.addEventListener("selectstart",y),i.addEventListener("selectend",y),i.addEventListener("squeeze",y),i.addEventListener("squeezestart",y),i.addEventListener("squeezeend",y),i.addEventListener("end",m);const j=t.getContextAttributes();j.xrCompatible!==!0&&t.makeXRCompatible();const Y={antialias:j.antialias,alpha:j.alpha,depth:j.depth,stencil:j.stencil,framebufferScaleFactor:r},X=new XRWebGLLayer(i,t,Y);i.updateRenderState({baseLayer:X}),i.requestReferenceSpace(o).then(g),i.addEventListener("inputsourceschange",T)}};function T(H){const j=i.inputSources;for(let Y=0;Y<l.length;Y++)c.set(j[Y],l[Y]);for(let Y=0;Y<H.removed.length;Y++){const X=H.removed[Y],q=c.get(X);q&&(q.dispatchEvent({type:"disconnected",data:X}),c.delete(X))}for(let Y=0;Y<H.added.length;Y++){const X=H.added[Y],q=c.get(X);q&&q.dispatchEvent({type:"connected",data:X})}}const P=new z,A=new z;function M(H,j,Y){P.setFromMatrixPosition(j.matrixWorld),A.setFromMatrixPosition(Y.matrixWorld);const X=P.distanceTo(A),q=j.projectionMatrix.elements,$=Y.projectionMatrix.elements,ne=q[14]/(q[10]-1),oe=q[14]/(q[10]+1),fe=(q[9]+1)/q[5],ge=(q[9]-1)/q[5],he=(q[8]-1)/q[0],de=($[8]+1)/$[0],Me=ne*he,ke=ne*de,se=X/(-he+de),E=se*-he;j.matrixWorld.decompose(H.position,H.quaternion,H.scale),H.translateX(E),H.translateZ(se),H.matrixWorld.compose(H.position,H.quaternion,H.scale),H.matrixWorldInverse.copy(H.matrixWorld).invert();const S=ne+se,D=oe+se,R=Me-E,U=ke+(X-E),G=fe*oe/D*S,x=ge*oe/D*S;H.projectionMatrix.makePerspective(R,U,G,x,S,D)}function N(H,j){j===null?H.matrixWorld.copy(H.matrix):H.matrixWorld.multiplyMatrices(j.matrixWorld,H.matrix),H.matrixWorldInverse.copy(H.matrixWorld).invert()}this.getCamera=function(H){h.near=u.near=f.near=H.near,h.far=u.far=f.far=H.far,(p!==h.near||v!==h.far)&&(i.updateRenderState({depthNear:h.near,depthFar:h.far}),p=h.near,v=h.far);const j=H.parent,Y=h.cameras;N(h,j);for(let q=0;q<Y.length;q++)N(Y[q],j);H.matrixWorld.copy(h.matrixWorld);const X=H.children;for(let q=0,$=X.length;q<$;q++)X[q].updateMatrixWorld(!0);return Y.length===2?M(h,f,u):h.projectionMatrix.copy(f.projectionMatrix),h};let B=null;function W(H,j){if(a=j.getViewerPose(s),a!==null){const X=a.views,q=i.renderState.baseLayer;e.setFramebuffer(q.framebuffer);let $=!1;X.length!==h.cameras.length&&(h.cameras.length=0,$=!0);for(let ne=0;ne<X.length;ne++){const oe=X[ne],fe=q.getViewport(oe),ge=d[ne];ge.matrix.fromArray(oe.transform.matrix),ge.projectionMatrix.fromArray(oe.projectionMatrix),ge.viewport.set(fe.x,fe.y,fe.width,fe.height),ne===0&&h.matrix.copy(ge.matrix),$===!0&&h.cameras.push(ge)}}const Y=i.inputSources;for(let X=0;X<l.length;X++){const q=l[X],$=Y[X];q.update($,j,s)}B&&B(H,j)}const te=new Zh;te.setAnimationLoop(W),this.setAnimationLoop=function(H){B=H},this.dispose=function(){}}Object.assign(op.prototype,Yn.prototype);function cw(e){function t(m,g){m.fogColor.value.copy(g.color),g.isFog?(m.fogNear.value=g.near,m.fogFar.value=g.far):g.isFogExp2&&(m.fogDensity.value=g.density)}function n(m,g,T,P){g.isMeshBasicMaterial?i(m,g):g.isMeshLambertMaterial?(i(m,g),l(m,g)):g.isMeshToonMaterial?(i(m,g),f(m,g)):g.isMeshPhongMaterial?(i(m,g),c(m,g)):g.isMeshStandardMaterial?(i(m,g),g.isMeshPhysicalMaterial?d(m,g):u(m,g)):g.isMeshMatcapMaterial?(i(m,g),h(m,g)):g.isMeshDepthMaterial?(i(m,g),p(m,g)):g.isMeshDistanceMaterial?(i(m,g),v(m,g)):g.isMeshNormalMaterial?(i(m,g),y(m,g)):g.isLineBasicMaterial?(r(m,g),g.isLineDashedMaterial&&s(m,g)):g.isPointsMaterial?o(m,g,T,P):g.isSpriteMaterial?a(m,g):g.isShadowMaterial?(m.color.value.copy(g.color),m.opacity.value=g.opacity):g.isShaderMaterial&&(g.uniformsNeedUpdate=!1)}function i(m,g){m.opacity.value=g.opacity,g.color&&m.diffuse.value.copy(g.color),g.emissive&&m.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),g.map&&(m.map.value=g.map),g.alphaMap&&(m.alphaMap.value=g.alphaMap),g.specularMap&&(m.specularMap.value=g.specularMap);const T=e.get(g).envMap;if(T){m.envMap.value=T,m.flipEnvMap.value=T.isCubeTexture&&T._needsFlipEnvMap?-1:1,m.reflectivity.value=g.reflectivity,m.refractionRatio.value=g.refractionRatio;const M=e.get(T).__maxMipLevel;M!==void 0&&(m.maxMipLevel.value=M)}g.lightMap&&(m.lightMap.value=g.lightMap,m.lightMapIntensity.value=g.lightMapIntensity),g.aoMap&&(m.aoMap.value=g.aoMap,m.aoMapIntensity.value=g.aoMapIntensity);let P;g.map?P=g.map:g.specularMap?P=g.specularMap:g.displacementMap?P=g.displacementMap:g.normalMap?P=g.normalMap:g.bumpMap?P=g.bumpMap:g.roughnessMap?P=g.roughnessMap:g.metalnessMap?P=g.metalnessMap:g.alphaMap?P=g.alphaMap:g.emissiveMap?P=g.emissiveMap:g.clearcoatMap?P=g.clearcoatMap:g.clearcoatNormalMap?P=g.clearcoatNormalMap:g.clearcoatRoughnessMap&&(P=g.clearcoatRoughnessMap),P!==void 0&&(P.isWebGLRenderTarget&&(P=P.texture),P.matrixAutoUpdate===!0&&P.updateMatrix(),m.uvTransform.value.copy(P.matrix));let A;g.aoMap?A=g.aoMap:g.lightMap&&(A=g.lightMap),A!==void 0&&(A.isWebGLRenderTarget&&(A=A.texture),A.matrixAutoUpdate===!0&&A.updateMatrix(),m.uv2Transform.value.copy(A.matrix))}function r(m,g){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity}function s(m,g){m.dashSize.value=g.dashSize,m.totalSize.value=g.dashSize+g.gapSize,m.scale.value=g.scale}function o(m,g,T,P){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity,m.size.value=g.size*T,m.scale.value=P*.5,g.map&&(m.map.value=g.map),g.alphaMap&&(m.alphaMap.value=g.alphaMap);let A;g.map?A=g.map:g.alphaMap&&(A=g.alphaMap),A!==void 0&&(A.matrixAutoUpdate===!0&&A.updateMatrix(),m.uvTransform.value.copy(A.matrix))}function a(m,g){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity,m.rotation.value=g.rotation,g.map&&(m.map.value=g.map),g.alphaMap&&(m.alphaMap.value=g.alphaMap);let T;g.map?T=g.map:g.alphaMap&&(T=g.alphaMap),T!==void 0&&(T.matrixAutoUpdate===!0&&T.updateMatrix(),m.uvTransform.value.copy(T.matrix))}function l(m,g){g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap)}function c(m,g){m.specular.value.copy(g.specular),m.shininess.value=Math.max(g.shininess,1e-4),g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap),g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===ht&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===ht&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}function f(m,g){g.gradientMap&&(m.gradientMap.value=g.gradientMap),g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap),g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===ht&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===ht&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}function u(m,g){m.roughness.value=g.roughness,m.metalness.value=g.metalness,g.roughnessMap&&(m.roughnessMap.value=g.roughnessMap),g.metalnessMap&&(m.metalnessMap.value=g.metalnessMap),g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap),g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===ht&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===ht&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias),e.get(g).envMap&&(m.envMapIntensity.value=g.envMapIntensity)}function d(m,g){u(m,g),m.reflectivity.value=g.reflectivity,m.clearcoat.value=g.clearcoat,m.clearcoatRoughness.value=g.clearcoatRoughness,g.sheen&&m.sheen.value.copy(g.sheen),g.clearcoatMap&&(m.clearcoatMap.value=g.clearcoatMap),g.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=g.clearcoatRoughnessMap),g.clearcoatNormalMap&&(m.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),m.clearcoatNormalMap.value=g.clearcoatNormalMap,g.side===ht&&m.clearcoatNormalScale.value.negate()),m.transmission.value=g.transmission,g.transmissionMap&&(m.transmissionMap.value=g.transmissionMap)}function h(m,g){g.matcap&&(m.matcap.value=g.matcap),g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===ht&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===ht&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}function p(m,g){g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}function v(m,g){g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias),m.referencePosition.value.copy(g.referencePosition),m.nearDistance.value=g.nearDistance,m.farDistance.value=g.farDistance}function y(m,g){g.bumpMap&&(m.bumpMap.value=g.bumpMap,m.bumpScale.value=g.bumpScale,g.side===ht&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,m.normalScale.value.copy(g.normalScale),g.side===ht&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias)}return{refreshFogUniforms:t,refreshMaterialUniforms:n}}function uw(){const e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");return e.style.display="block",e}function ao(e){e=e||{};const t=e.canvas!==void 0?e.canvas:uw(),n=e.context!==void 0?e.context:null,i=e.alpha!==void 0?e.alpha:!1,r=e.depth!==void 0?e.depth:!0,s=e.stencil!==void 0?e.stencil:!0,o=e.antialias!==void 0?e.antialias:!1,a=e.premultipliedAlpha!==void 0?e.premultipliedAlpha:!0,l=e.preserveDrawingBuffer!==void 0?e.preserveDrawingBuffer:!1,c=e.powerPreference!==void 0?e.powerPreference:"default",f=e.failIfMajorPerformanceCaveat!==void 0?e.failIfMajorPerformanceCaveat:!1;let u=null,d=null;const h=[];this.domElement=t,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=ro,this.physicallyCorrectLights=!1,this.toneMapping=Ss,this.toneMappingExposure=1,this.maxMorphTargets=8,this.maxMorphNormals=4;const p=this;let v=!1,y=null,m=0,g=0,T=null,P=null,A=-1,M=null;const N=new Ge,B=new Ge;let W=null,te=t.width,H=t.height,j=1,Y=null,X=null;const q=new Ge(0,0,te,H),$=new Ge(0,0,te,H);let ne=!1;const oe=new Va;let fe=!1,ge=!1;const he=new Le,de=new z,Me={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function ke(){return T===null?j:1}let se=n;function E(I,ie){for(let ee=0;ee<I.length;ee++){const re=I[ee],ve=t.getContext(re,ie);if(ve!==null)return ve}return null}try{const I={alpha:i,depth:r,stencil:s,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:f};if(t.addEventListener("webglcontextlost",Te,!1),t.addEventListener("webglcontextrestored",Ke,!1),se===null){const ie=["webgl2","webgl","experimental-webgl"];if(p.isWebGL1Renderer===!0&&ie.shift(),se=E(ie,I),se===null)throw E(ie)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}se.getShaderPrecisionFormat===void 0&&(se.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(I){throw console.error("THREE.WebGLRenderer: "+I.message),I}let S,D,R,U,G,x,_,L,F,O,b,w,V,k,C,J,Z,K,Q,ae,ue;function pe(){S=new k0(se),D=new z0(se,S,e),D.isWebGL2===!1&&(S.get("WEBGL_depth_texture"),S.get("OES_texture_float"),S.get("OES_texture_half_float"),S.get("OES_texture_half_float_linear"),S.get("OES_standard_derivatives"),S.get("OES_element_index_uint"),S.get("OES_vertex_array_object"),S.get("ANGLE_instanced_arrays")),S.get("OES_texture_float_linear"),ae=new lw(se,S,D),R=new ow(se,S,D),R.scissor(B.copy($).multiplyScalar(j).floor()),R.viewport(N.copy(q).multiplyScalar(j).floor()),U=new W0,G=new Yb,x=new aw(se,S,R,G,D,ae,U),_=new H0(p),L=new hx(se,D),ue=new F0(se,S,L,D),F=new G0(se,L,U,ue),O=new Y0(se,F,L,U),Z=new X0(se),C=new U0(G),b=new Xb(p,_,S,D,ue,C),w=new cw(G),V=new $b(G),k=new iw(S,D),J=new D0(p,_,R,O,a),K=new B0(se,S,U,D),Q=new V0(se,S,U,D),U.programs=b.programs,p.capabilities=D,p.extensions=S,p.properties=G,p.renderLists=V,p.state=R,p.info=U}pe();const ce=new op(p,se);this.xr=ce;const ye=new sp(p,O,D.maxTextureSize);this.shadowMap=ye,this.getContext=function(){return se},this.getContextAttributes=function(){return se.getContextAttributes()},this.forceContextLoss=function(){const I=S.get("WEBGL_lose_context");I&&I.loseContext()},this.forceContextRestore=function(){const I=S.get("WEBGL_lose_context");I&&I.restoreContext()},this.getPixelRatio=function(){return j},this.setPixelRatio=function(I){I!==void 0&&(j=I,this.setSize(te,H,!1))},this.getSize=function(I){return I===void 0&&(console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"),I=new le),I.set(te,H)},this.setSize=function(I,ie,ee){if(ce.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}te=I,H=ie,t.width=Math.floor(I*j),t.height=Math.floor(ie*j),ee!==!1&&(t.style.width=I+"px",t.style.height=ie+"px"),this.setViewport(0,0,I,ie)},this.getDrawingBufferSize=function(I){return I===void 0&&(console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),I=new le),I.set(te*j,H*j).floor()},this.setDrawingBufferSize=function(I,ie,ee){te=I,H=ie,j=ee,t.width=Math.floor(I*ee),t.height=Math.floor(ie*ee),this.setViewport(0,0,I,ie)},this.getCurrentViewport=function(I){return I===void 0&&(console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),I=new Ge),I.copy(N)},this.getViewport=function(I){return I.copy(q)},this.setViewport=function(I,ie,ee,re){I.isVector4?q.set(I.x,I.y,I.z,I.w):q.set(I,ie,ee,re),R.viewport(N.copy(q).multiplyScalar(j).floor())},this.getScissor=function(I){return I.copy($)},this.setScissor=function(I,ie,ee,re){I.isVector4?$.set(I.x,I.y,I.z,I.w):$.set(I,ie,ee,re),R.scissor(B.copy($).multiplyScalar(j).floor())},this.getScissorTest=function(){return ne},this.setScissorTest=function(I){R.setScissorTest(ne=I)},this.setOpaqueSort=function(I){Y=I},this.setTransparentSort=function(I){X=I},this.getClearColor=function(I){return I===void 0&&(console.warn("WebGLRenderer: .getClearColor() now requires a Color as an argument"),I=new xe),I.copy(J.getClearColor())},this.setClearColor=function(){J.setClearColor.apply(J,arguments)},this.getClearAlpha=function(){return J.getClearAlpha()},this.setClearAlpha=function(){J.setClearAlpha.apply(J,arguments)},this.clear=function(I,ie,ee){let re=0;(I===void 0||I)&&(re|=16384),(ie===void 0||ie)&&(re|=256),(ee===void 0||ee)&&(re|=1024),se.clear(re)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Te,!1),t.removeEventListener("webglcontextrestored",Ke,!1),V.dispose(),k.dispose(),G.dispose(),_.dispose(),O.dispose(),ue.dispose(),ce.dispose(),gn.stop()};function Te(I){I.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),v=!0}function Ke(){console.log("THREE.WebGLRenderer: Context Restored."),v=!1,pe()}function gt(I){const ie=I.target;ie.removeEventListener("dispose",gt),$n(ie)}function $n(I){tt(I),G.remove(I)}function tt(I){const ie=G.get(I).program;ie!==void 0&&b.releaseProgram(ie)}function ft(I,ie){I.render(function(ee){p.renderBufferImmediate(ee,ie)})}this.renderBufferImmediate=function(I,ie){ue.initAttributes();const ee=G.get(I);I.hasPositions&&!ee.position&&(ee.position=se.createBuffer()),I.hasNormals&&!ee.normal&&(ee.normal=se.createBuffer()),I.hasUvs&&!ee.uv&&(ee.uv=se.createBuffer()),I.hasColors&&!ee.color&&(ee.color=se.createBuffer());const re=ie.getAttributes();I.hasPositions&&(se.bindBuffer(34962,ee.position),se.bufferData(34962,I.positionArray,35048),ue.enableAttribute(re.position),se.vertexAttribPointer(re.position,3,5126,!1,0,0)),I.hasNormals&&(se.bindBuffer(34962,ee.normal),se.bufferData(34962,I.normalArray,35048),ue.enableAttribute(re.normal),se.vertexAttribPointer(re.normal,3,5126,!1,0,0)),I.hasUvs&&(se.bindBuffer(34962,ee.uv),se.bufferData(34962,I.uvArray,35048),ue.enableAttribute(re.uv),se.vertexAttribPointer(re.uv,2,5126,!1,0,0)),I.hasColors&&(se.bindBuffer(34962,ee.color),se.bufferData(34962,I.colorArray,35048),ue.enableAttribute(re.color),se.vertexAttribPointer(re.color,3,5126,!1,0,0)),ue.disableUnusedAttributes(),se.drawArrays(4,0,I.count),I.count=0},this.renderBufferDirect=function(I,ie,ee,re,ve,De){ie===null&&(ie=Me);const Pe=ve.isMesh&&ve.matrixWorld.determinant()<0,Fe=Ki(I,ie,re,ve);R.setMaterial(re,Pe);let Re=ee.index;const nt=ee.attributes.position;if(Re===null){if(nt===void 0||nt.count===0)return}else if(Re.count===0)return;let Qe=1;re.wireframe===!0&&(Re=F.getWireframeAttribute(ee),Qe=2),(re.morphTargets||re.morphNormals)&&Z.update(ve,ee,re,Fe),ue.setup(ve,re,Fe,ee,Re);let Ce,Ve=K;Re!==null&&(Ce=L.get(Re),Ve=Q,Ve.setIndex(Ce));const Pn=Re!==null?Re.count:nt.count,We=ee.drawRange.start*Qe,Ci=ee.drawRange.count*Qe,ot=De!==null?De.start*Qe:0,Ya=De!==null?De.count*Qe:1/0,Et=Math.max(We,ot),is=Math.min(Pn,We+Ci,ot+Ya)-1,Qi=Math.max(0,is-Et+1);if(Qi!==0){if(ve.isMesh)re.wireframe===!0?(R.setLineWidth(re.wireframeLinewidth*ke()),Ve.setMode(1)):Ve.setMode(4);else if(ve.isLine){let rs=re.linewidth;rs===void 0&&(rs=1),R.setLineWidth(rs*ke()),ve.isLineSegments?Ve.setMode(1):ve.isLineLoop?Ve.setMode(2):Ve.setMode(3)}else ve.isPoints?Ve.setMode(0):ve.isSprite&&Ve.setMode(4);if(ve.isInstancedMesh)Ve.renderInstances(Et,Qi,ve.count);else if(ee.isInstancedBufferGeometry){const rs=Math.min(ee.instanceCount,ee._maxInstanceCount);Ve.renderInstances(Et,Qi,rs)}else Ve.render(Et,Qi)}},this.compile=function(I,ie){d=k.get(I),d.init(),I.traverseVisible(function(re){re.isLight&&re.layers.test(ie.layers)&&(d.pushLight(re),re.castShadow&&d.pushShadow(re))}),d.setupLights();const ee=new WeakMap;I.traverse(function(re){const ve=re.material;if(ve)if(Array.isArray(ve))for(let De=0;De<ve.length;De++){const Pe=ve[De];ee.has(Pe)===!1&&(st(Pe,I,re),ee.set(Pe))}else ee.has(ve)===!1&&(st(ve,I,re),ee.set(ve))})};let Kn=null;function qa(I){ce.isPresenting||Kn&&Kn(I)}const gn=new Zh;gn.setAnimationLoop(qa),typeof window<"u"&&gn.setContext(window),this.setAnimationLoop=function(I){Kn=I,ce.setAnimationLoop(I),I===null?gn.stop():gn.start()},this.render=function(I,ie){let ee,re;if(arguments[2]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."),ee=arguments[2]),arguments[3]!==void 0&&(console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."),re=arguments[3]),ie!==void 0&&ie.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(v===!0)return;ue.resetDefaultState(),A=-1,M=null,I.autoUpdate===!0&&I.updateMatrixWorld(),ie.parent===null&&ie.updateMatrixWorld(),ce.enabled===!0&&ce.isPresenting===!0&&(ie=ce.getCamera(ie)),I.isScene===!0&&I.onBeforeRender(p,I,ie,ee||T),d=k.get(I,h.length),d.init(),h.push(d),he.multiplyMatrices(ie.projectionMatrix,ie.matrixWorldInverse),oe.setFromProjectionMatrix(he),ge=this.localClippingEnabled,fe=C.init(this.clippingPlanes,ge,ie),u=V.get(I,ie),u.init(),Jt(I,ie,0,p.sortObjects),u.finish(),p.sortObjects===!0&&u.sort(Y,X),fe===!0&&C.beginShadows();const ve=d.state.shadowsArray;ye.render(ve,I,ie),d.setupLights(),d.setupLightsView(ie),fe===!0&&C.endShadows(),this.info.autoReset===!0&&this.info.reset(),ee!==void 0&&this.setRenderTarget(ee),J.render(u,I,ie,re);const De=u.opaque,Pe=u.transparent;De.length>0&&Qn(De,I,ie),Pe.length>0&&Qn(Pe,I,ie),I.isScene===!0&&I.onAfterRender(p,I,ie),T!==null&&(x.updateRenderTargetMipmap(T),x.updateMultisampleRenderTarget(T)),R.buffers.depth.setTest(!0),R.buffers.depth.setMask(!0),R.buffers.color.setMask(!0),R.setPolygonOffset(!1),h.pop(),h.length>0?d=h[h.length-1]:d=null,u=null};function Jt(I,ie,ee,re){if(I.visible===!1)return;if(I.layers.test(ie.layers)){if(I.isGroup)ee=I.renderOrder;else if(I.isLOD)I.autoUpdate===!0&&I.update(ie);else if(I.isLight)d.pushLight(I),I.castShadow&&d.pushShadow(I);else if(I.isSprite){if(!I.frustumCulled||oe.intersectsSprite(I)){re&&de.setFromMatrixPosition(I.matrixWorld).applyMatrix4(he);const Pe=O.update(I),Fe=I.material;Fe.visible&&u.push(I,Pe,Fe,ee,de.z,null)}}else if(I.isImmediateRenderObject)re&&de.setFromMatrixPosition(I.matrixWorld).applyMatrix4(he),u.push(I,null,I.material,ee,de.z,null);else if((I.isMesh||I.isLine||I.isPoints)&&(I.isSkinnedMesh&&I.skeleton.frame!==U.render.frame&&(I.skeleton.update(),I.skeleton.frame=U.render.frame),!I.frustumCulled||oe.intersectsObject(I))){re&&de.setFromMatrixPosition(I.matrixWorld).applyMatrix4(he);const Pe=O.update(I),Fe=I.material;if(Array.isArray(Fe)){const Re=Pe.groups;for(let nt=0,Qe=Re.length;nt<Qe;nt++){const Ce=Re[nt],Ve=Fe[Ce.materialIndex];Ve&&Ve.visible&&u.push(I,Pe,Ve,ee,de.z,Ce)}}else Fe.visible&&u.push(I,Pe,Fe,ee,de.z,null)}}const De=I.children;for(let Pe=0,Fe=De.length;Pe<Fe;Pe++)Jt(De[Pe],ie,ee,re)}function Qn(I,ie,ee){const re=ie.isScene===!0?ie.overrideMaterial:null;for(let ve=0,De=I.length;ve<De;ve++){const Pe=I[ve],Fe=Pe.object,Re=Pe.geometry,nt=re===null?Pe.material:re,Qe=Pe.group;if(ee.isArrayCamera){const Ce=ee.cameras;for(let Ve=0,Pn=Ce.length;Ve<Pn;Ve++){const We=Ce[Ve];Fe.layers.test(We.layers)&&(R.viewport(N.copy(We.viewport)),d.setupLightsView(We),ts(Fe,ie,We,Re,nt,Qe))}}else ts(Fe,ie,ee,Re,nt,Qe)}}function ts(I,ie,ee,re,ve,De){if(I.onBeforeRender(p,ie,ee,re,ve,De),I.modelViewMatrix.multiplyMatrices(ee.matrixWorldInverse,I.matrixWorld),I.normalMatrix.getNormalMatrix(I.modelViewMatrix),I.isImmediateRenderObject){const Pe=Ki(ee,ie,ve,I);R.setMaterial(ve),ue.reset(),ft(I,Pe)}else p.renderBufferDirect(ee,ie,re,ve,I,De);I.onAfterRender(p,ie,ee,re,ve,De)}function st(I,ie,ee){ie.isScene!==!0&&(ie=Me);const re=G.get(I),ve=d.state.lights,De=d.state.shadowsArray,Pe=ve.state.version,Fe=b.getParameters(I,ve.state,De,ie,ee),Re=b.getProgramCacheKey(Fe);let nt=re.program,Qe=!0;if(nt===void 0)I.addEventListener("dispose",gt);else if(nt.cacheKey!==Re)tt(I);else if(re.lightsStateVersion!==Pe)Qe=!1;else if(Fe.shaderID!==void 0){const We=I.isMeshStandardMaterial?ie.environment:null;re.envMap=_.get(I.envMap||We);return}else Qe=!1;Qe&&(Fe.uniforms=b.getUniforms(I),I.onBeforeCompile(Fe,p),nt=b.acquireProgram(Fe,Re),re.program=nt,re.uniforms=Fe.uniforms,re.outputEncoding=Fe.outputEncoding);const Ce=re.uniforms;(!I.isShaderMaterial&&!I.isRawShaderMaterial||I.clipping===!0)&&(re.numClippingPlanes=C.numPlanes,re.numIntersection=C.numIntersection,Ce.clippingPlanes=C.uniform),re.environment=I.isMeshStandardMaterial?ie.environment:null,re.fog=ie.fog,re.envMap=_.get(I.envMap||re.environment),re.needsLights=Xa(I),re.lightsStateVersion=Pe,re.needsLights&&(Ce.ambientLightColor.value=ve.state.ambient,Ce.lightProbe.value=ve.state.probe,Ce.directionalLights.value=ve.state.directional,Ce.directionalLightShadows.value=ve.state.directionalShadow,Ce.spotLights.value=ve.state.spot,Ce.spotLightShadows.value=ve.state.spotShadow,Ce.rectAreaLights.value=ve.state.rectArea,Ce.ltc_1.value=ve.state.rectAreaLTC1,Ce.ltc_2.value=ve.state.rectAreaLTC2,Ce.pointLights.value=ve.state.point,Ce.pointLightShadows.value=ve.state.pointShadow,Ce.hemisphereLights.value=ve.state.hemi,Ce.directionalShadowMap.value=ve.state.directionalShadowMap,Ce.directionalShadowMatrix.value=ve.state.directionalShadowMatrix,Ce.spotShadowMap.value=ve.state.spotShadowMap,Ce.spotShadowMatrix.value=ve.state.spotShadowMatrix,Ce.pointShadowMap.value=ve.state.pointShadowMap,Ce.pointShadowMatrix.value=ve.state.pointShadowMatrix);const Ve=re.program.getUniforms(),Pn=_i.seqWithValue(Ve.seq,Ce);re.uniformsList=Pn}function Ki(I,ie,ee,re){ie.isScene!==!0&&(ie=Me),x.resetTextureUnits();const ve=ie.fog,De=ee.isMeshStandardMaterial?ie.environment:null,Pe=T===null?p.outputEncoding:T.texture.encoding,Fe=_.get(ee.envMap||De),Re=G.get(ee),nt=d.state.lights;if(fe===!0&&(ge===!0||I!==M)){const ot=I===M&&ee.id===A;C.setState(ee,I,ot)}ee.version===Re.__version?(ee.fog&&Re.fog!==ve||Re.environment!==De||Re.needsLights&&Re.lightsStateVersion!==nt.state.version||Re.numClippingPlanes!==void 0&&(Re.numClippingPlanes!==C.numPlanes||Re.numIntersection!==C.numIntersection)||Re.outputEncoding!==Pe||Re.envMap!==Fe)&&st(ee,ie,re):(st(ee,ie,re),Re.__version=ee.version);let Qe=!1,Ce=!1,Ve=!1;const Pn=Re.program,We=Pn.getUniforms(),Ci=Re.uniforms;if(R.useProgram(Pn.program)&&(Qe=!0,Ce=!0,Ve=!0),ee.id!==A&&(A=ee.id,Ce=!0),Qe||M!==I){if(We.setValue(se,"projectionMatrix",I.projectionMatrix),D.logarithmicDepthBuffer&&We.setValue(se,"logDepthBufFC",2/(Math.log(I.far+1)/Math.LN2)),M!==I&&(M=I,Ce=!0,Ve=!0),ee.isShaderMaterial||ee.isMeshPhongMaterial||ee.isMeshToonMaterial||ee.isMeshStandardMaterial||ee.envMap){const ot=We.map.cameraPosition;ot!==void 0&&ot.setValue(se,de.setFromMatrixPosition(I.matrixWorld))}(ee.isMeshPhongMaterial||ee.isMeshToonMaterial||ee.isMeshLambertMaterial||ee.isMeshBasicMaterial||ee.isMeshStandardMaterial||ee.isShaderMaterial)&&We.setValue(se,"isOrthographic",I.isOrthographicCamera===!0),(ee.isMeshPhongMaterial||ee.isMeshToonMaterial||ee.isMeshLambertMaterial||ee.isMeshBasicMaterial||ee.isMeshStandardMaterial||ee.isShaderMaterial||ee.isShadowMaterial||ee.skinning)&&We.setValue(se,"viewMatrix",I.matrixWorldInverse)}if(ee.skinning){We.setOptional(se,re,"bindMatrix"),We.setOptional(se,re,"bindMatrixInverse");const ot=re.skeleton;if(ot){const Ya=ot.bones;if(D.floatVertexTextures){if(ot.boneTexture===null){let Et=Math.sqrt(Ya.length*4);Et=Ee.ceilPowerOfTwo(Et),Et=Math.max(Et,4);const is=new Float32Array(Et*Et*4);is.set(ot.boneMatrices);const Qi=new Hr(is,Et,Et,pn,di);ot.boneMatrices=is,ot.boneTexture=Qi,ot.boneTextureSize=Et}We.setValue(se,"boneTexture",ot.boneTexture,x),We.setValue(se,"boneTextureSize",ot.boneTextureSize)}else We.setOptional(se,ot,"boneMatrices")}}return(Ce||Re.receiveShadow!==re.receiveShadow)&&(Re.receiveShadow=re.receiveShadow,We.setValue(se,"receiveShadow",re.receiveShadow)),Ce&&(We.setValue(se,"toneMappingExposure",p.toneMappingExposure),Re.needsLights&&ns(Ci,Ve),ve&&ee.fog&&w.refreshFogUniforms(Ci,ve),w.refreshMaterialUniforms(Ci,ee,j,H),_i.upload(se,Re.uniformsList,Ci,x)),ee.isShaderMaterial&&ee.uniformsNeedUpdate===!0&&(_i.upload(se,Re.uniformsList,Ci,x),ee.uniformsNeedUpdate=!1),ee.isSpriteMaterial&&We.setValue(se,"center",re.center),We.setValue(se,"modelViewMatrix",re.modelViewMatrix),We.setValue(se,"normalMatrix",re.normalMatrix),We.setValue(se,"modelMatrix",re.matrixWorld),Pn}function ns(I,ie){I.ambientLightColor.needsUpdate=ie,I.lightProbe.needsUpdate=ie,I.directionalLights.needsUpdate=ie,I.directionalLightShadows.needsUpdate=ie,I.pointLights.needsUpdate=ie,I.pointLightShadows.needsUpdate=ie,I.spotLights.needsUpdate=ie,I.spotLightShadows.needsUpdate=ie,I.rectAreaLights.needsUpdate=ie,I.hemisphereLights.needsUpdate=ie}function Xa(I){return I.isMeshLambertMaterial||I.isMeshToonMaterial||I.isMeshPhongMaterial||I.isMeshStandardMaterial||I.isShadowMaterial||I.isShaderMaterial&&I.lights===!0}this.setFramebuffer=function(I){y!==I&&T===null&&se.bindFramebuffer(36160,I),y=I},this.getActiveCubeFace=function(){return m},this.getActiveMipmapLevel=function(){return g},this.getRenderList=function(){return u},this.setRenderList=function(I){u=I},this.getRenderTarget=function(){return T},this.setRenderTarget=function(I,ie=0,ee=0){T=I,m=ie,g=ee,I&&G.get(I).__webglFramebuffer===void 0&&x.setupRenderTarget(I);let re=y,ve=!1;if(I){const De=G.get(I).__webglFramebuffer;I.isWebGLCubeRenderTarget?(re=De[ie],ve=!0):I.isWebGLMultisampleRenderTarget?re=G.get(I).__webglMultisampledFramebuffer:re=De,N.copy(I.viewport),B.copy(I.scissor),W=I.scissorTest}else N.copy(q).multiplyScalar(j).floor(),B.copy($).multiplyScalar(j).floor(),W=ne;if(P!==re&&(se.bindFramebuffer(36160,re),P=re),R.viewport(N),R.scissor(B),R.setScissorTest(W),ve){const De=G.get(I.texture);se.framebufferTexture2D(36160,36064,34069+ie,De.__webglTexture,ee)}},this.readRenderTargetPixels=function(I,ie,ee,re,ve,De,Pe){if(!(I&&I.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Fe=G.get(I).__webglFramebuffer;if(I.isWebGLCubeRenderTarget&&Pe!==void 0&&(Fe=Fe[Pe]),Fe){let Re=!1;Fe!==P&&(se.bindFramebuffer(36160,Fe),Re=!0);try{const nt=I.texture,Qe=nt.format,Ce=nt.type;if(Qe!==pn&&ae.convert(Qe)!==se.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(Ce!==mu&&ae.convert(Ce)!==se.getParameter(35738)&&!(Ce===di&&(D.isWebGL2||S.get("OES_texture_float")||S.get("WEBGL_color_buffer_float")))&&!(Ce===da&&(D.isWebGL2?S.get("EXT_color_buffer_float"):S.get("EXT_color_buffer_half_float")))){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}se.checkFramebufferStatus(36160)===36053?ie>=0&&ie<=I.width-re&&ee>=0&&ee<=I.height-ve&&se.readPixels(ie,ee,re,ve,ae.convert(Qe),ae.convert(Ce),De):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{Re&&se.bindFramebuffer(36160,P)}}},this.copyFramebufferToTexture=function(I,ie,ee=0){const re=Math.pow(2,-ee),ve=Math.floor(ie.image.width*re),De=Math.floor(ie.image.height*re),Pe=ae.convert(ie.format);x.setTexture2D(ie,0),se.copyTexImage2D(3553,ee,Pe,I.x,I.y,ve,De,0),R.unbindTexture()},this.copyTextureToTexture=function(I,ie,ee,re=0){const ve=ie.image.width,De=ie.image.height,Pe=ae.convert(ee.format),Fe=ae.convert(ee.type);x.setTexture2D(ee,0),se.pixelStorei(37440,ee.flipY),se.pixelStorei(37441,ee.premultiplyAlpha),se.pixelStorei(3317,ee.unpackAlignment),ie.isDataTexture?se.texSubImage2D(3553,re,I.x,I.y,ve,De,Pe,Fe,ie.image.data):ie.isCompressedTexture?se.compressedTexSubImage2D(3553,re,I.x,I.y,ie.mipmaps[0].width,ie.mipmaps[0].height,Pe,ie.mipmaps[0].data):se.texSubImage2D(3553,re,I.x,I.y,Pe,Fe,ie.image),re===0&&ee.generateMipmaps&&se.generateMipmap(3553),R.unbindTexture()},this.initTexture=function(I){x.setTexture2D(I,0),R.unbindTexture()},this.resetState=function(){R.reset(),ue.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}function Wf(e){ao.call(this,e)}Wf.prototype=Object.assign(Object.create(ao.prototype),{constructor:Wf,isWebGL1Renderer:!0});class ap extends be{constructor(){super(),Object.defineProperty(this,"isScene",{value:!0}),this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(t,n){return super.copy(t,n),t.background!==null&&(this.background=t.background.clone()),t.environment!==null&&(this.environment=t.environment.clone()),t.fog!==null&&(this.fog=t.fog.clone()),t.overrideMaterial!==null&&(this.overrideMaterial=t.overrideMaterial.clone()),this.autoUpdate=t.autoUpdate,this.matrixAutoUpdate=t.matrixAutoUpdate,this}toJSON(t){const n=super.toJSON(t);return this.background!==null&&(n.object.background=this.background.toJSON(t)),this.environment!==null&&(n.object.environment=this.environment.toJSON(t)),this.fog!==null&&(n.object.fog=this.fog.toJSON()),n}}function kt(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Ga,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ee.generateUUID()}Object.defineProperty(kt.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}});Object.assign(kt.prototype,{isInterleavedBuffer:!0,onUploadCallback:function(){},setUsage:function(e){return this.usage=e,this},copy:function(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this},copyAt:function(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[n+i];return this},set:function(e,t=0){return this.array.set(e,t),this},clone:function(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ee.generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new kt(t,this.stride);return n.setUsage(this.usage),n},onUpload:function(e){return this.onUploadCallback=e,this},toJSON:function(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ee.generateUUID()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}});const Di=new z;function Ai(e,t,n,i){this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i===!0}Object.defineProperties(Ai.prototype,{count:{get:function(){return this.data.count}},array:{get:function(){return this.data.array}},needsUpdate:{set:function(e){this.data.needsUpdate=e}}});Object.assign(Ai.prototype,{isInterleavedBufferAttribute:!0,applyMatrix4:function(e){for(let t=0,n=this.data.count;t<n;t++)Di.x=this.getX(t),Di.y=this.getY(t),Di.z=this.getZ(t),Di.applyMatrix4(e),this.setXYZ(t,Di.x,Di.y,Di.z);return this},setX:function(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this},setY:function(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this},setZ:function(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this},setW:function(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this},getX:function(e){return this.data.array[e*this.data.stride+this.offset]},getY:function(e){return this.data.array[e*this.data.stride+this.offset+1]},getZ:function(e){return this.data.array[e*this.data.stride+this.offset+2]},getW:function(e){return this.data.array[e*this.data.stride+this.offset+3]},setXY:function(e,t,n){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this},setXYZ:function(e,t,n,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this},setXYZW:function(e,t,n,i,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=r,this},clone:function(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new Se(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Ai(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)},toJSON:function(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}});function qi(e){we.call(this),this.type="SpriteMaterial",this.color=new xe(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}qi.prototype=Object.create(we.prototype);qi.prototype.constructor=qi;qi.prototype.isSpriteMaterial=!0;qi.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this};let dr;const us=new z,hr=new z,pr=new z,mr=new le,fs=new le,lp=new Le,Oo=new z,ds=new z,No=new z,jf=new le,Cl=new le,qf=new le;function Xf(e){if(be.call(this),this.type="Sprite",dr===void 0){dr=new Be;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),n=new kt(t,5);dr.setIndex([0,1,2,0,2,3]),dr.setAttribute("position",new Ai(n,3,0,!1)),dr.setAttribute("uv",new Ai(n,2,3,!1))}this.geometry=dr,this.material=e!==void 0?e:new qi,this.center=new le(.5,.5)}Xf.prototype=Object.assign(Object.create(be.prototype),{constructor:Xf,isSprite:!0,raycast:function(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),hr.setFromMatrixScale(this.matrixWorld),lp.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),pr.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&hr.multiplyScalar(-pr.z);const n=this.material.rotation;let i,r;n!==0&&(r=Math.cos(n),i=Math.sin(n));const s=this.center;Do(Oo.set(-.5,-.5,0),pr,s,hr,i,r),Do(ds.set(.5,-.5,0),pr,s,hr,i,r),Do(No.set(.5,.5,0),pr,s,hr,i,r),jf.set(0,0),Cl.set(1,0),qf.set(1,1);let o=e.ray.intersectTriangle(Oo,ds,No,!1,us);if(o===null&&(Do(ds.set(-.5,.5,0),pr,s,hr,i,r),Cl.set(0,1),o=e.ray.intersectTriangle(Oo,No,ds,!1,us),o===null))return;const a=e.ray.origin.distanceTo(us);a<e.near||a>e.far||t.push({distance:a,point:us.clone(),uv:_t.getUV(us,Oo,ds,No,jf,Cl,qf,new le),face:null,object:this})},copy:function(e){return be.prototype.copy.call(this,e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}});function Do(e,t,n,i,r,s){mr.subVectors(e,n).addScalar(.5).multiply(i),r!==void 0?(fs.x=s*mr.x-r*mr.y,fs.y=r*mr.x+s*mr.y):fs.copy(mr),e.copy(t),e.x+=fs.x,e.y+=fs.y,e.applyMatrix4(lp)}const Fo=new z,Yf=new z;function gc(){be.call(this),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}gc.prototype=Object.assign(Object.create(be.prototype),{constructor:gc,isLOD:!0,copy:function(e){be.prototype.copy.call(this,e,!1);const t=e.levels;for(let n=0,i=t.length;n<i;n++){const r=t[n];this.addLevel(r.object.clone(),r.distance)}return this.autoUpdate=e.autoUpdate,this},addLevel:function(e,t=0){t=Math.abs(t);const n=this.levels;let i;for(i=0;i<n.length&&!(t<n[i].distance);i++);return n.splice(i,0,{distance:t,object:e}),this.add(e),this},getCurrentLevel:function(){return this._currentLevel},getObjectForDistance:function(e){const t=this.levels;if(t.length>0){let n,i;for(n=1,i=t.length;n<i&&!(e<t[n].distance);n++);return t[n-1].object}return null},raycast:function(e,t){if(this.levels.length>0){Fo.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(Fo);this.getObjectForDistance(i).raycast(e,t)}},update:function(e){const t=this.levels;if(t.length>1){Fo.setFromMatrixPosition(e.matrixWorld),Yf.setFromMatrixPosition(this.matrixWorld);const n=Fo.distanceTo(Yf)/e.zoom;t[0].object.visible=!0;let i,r;for(i=1,r=t.length;i<r&&n>=t[i].distance;i++)t[i-1].object.visible=!1,t[i].object.visible=!0;for(this._currentLevel=i-1;i<r;i++)t[i].object.visible=!1}},toJSON:function(e){const t=be.prototype.toJSON.call(this,e);this.autoUpdate===!1&&(t.object.autoUpdate=!1),t.object.levels=[];const n=this.levels;for(let i=0,r=n.length;i<r;i++){const s=n[i];t.object.levels.push({object:s.object.uuid,distance:s.distance})}return t}});const Jf=new z,Zf=new Ge,$f=new Ge,fw=new z,Kf=new Le;function ma(e,t){e&&e.isGeometry&&console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."),rt.call(this,e,t),this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Le,this.bindMatrixInverse=new Le}ma.prototype=Object.assign(Object.create(rt.prototype),{constructor:ma,isSkinnedMesh:!0,copy:function(e){return rt.prototype.copy.call(this,e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this},bind:function(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()},pose:function(){this.skeleton.pose()},normalizeSkinWeights:function(){const e=new Ge,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.x=t.getX(n),e.y=t.getY(n),e.z=t.getZ(n),e.w=t.getW(n);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}},updateMatrixWorld:function(e){rt.prototype.updateMatrixWorld.call(this,e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)},boneTransform:function(e,t){const n=this.skeleton,i=this.geometry;Zf.fromBufferAttribute(i.attributes.skinIndex,e),$f.fromBufferAttribute(i.attributes.skinWeight,e),Jf.fromBufferAttribute(i.attributes.position,e).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const s=$f.getComponent(r);if(s!==0){const o=Zf.getComponent(r);Kf.multiplyMatrices(n.bones[o].matrixWorld,n.boneInverses[o]),t.addScaledVector(fw.copy(Jf).applyMatrix4(Kf),s)}}return t.applyMatrix4(this.bindMatrixInverse)}});function ga(){be.call(this),this.type="Bone"}ga.prototype=Object.assign(Object.create(be.prototype),{constructor:ga,isBone:!0});const Qf=new Le,dw=new Le;function va(e=[],t=[]){this.uuid=Ee.generateUUID(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}Object.assign(va.prototype,{init:function(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new Le)}},calculateInverses:function(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new Le;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}},pose:function(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}},update:function(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,s=e.length;r<s;r++){const o=e[r]?e[r].matrixWorld:dw;Qf.multiplyMatrices(o,t[r]),Qf.toArray(n,r*16)}i!==null&&(i.needsUpdate=!0)},clone:function(){return new va(this.bones,this.boneInverses)},getBoneByName:function(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}},dispose:function(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)},fromJSON:function(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const r=e.bones[n];let s=t[r];s===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),s=new ga),this.bones.push(s),this.boneInverses.push(new Le().fromArray(e.boneInverses[n]))}return this.init(),this},toJSON:function(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,r=t.length;i<r;i++){const s=t[i];e.bones.push(s.uuid);const o=n[i];e.boneInverses.push(o.toArray())}return e}});const ed=new Le,td=new Le,Bo=[],hs=new rt;function nd(e,t,n){rt.call(this,e,t),this.instanceMatrix=new Se(new Float32Array(n*16),16),this.instanceColor=null,this.count=n,this.frustumCulled=!1}nd.prototype=Object.assign(Object.create(rt.prototype),{constructor:nd,isInstancedMesh:!0,copy:function(e){return rt.prototype.copy.call(this,e),this.instanceMatrix.copy(e.instanceMatrix),this.count=e.count,this},getColorAt:function(e,t){t.fromArray(this.instanceColor.array,e*3)},getMatrixAt:function(e,t){t.fromArray(this.instanceMatrix.array,e*16)},raycast:function(e,t){const n=this.matrixWorld,i=this.count;if(hs.geometry=this.geometry,hs.material=this.material,hs.material!==void 0)for(let r=0;r<i;r++){this.getMatrixAt(r,ed),td.multiplyMatrices(n,ed),hs.matrixWorld=td,hs.raycast(e,Bo);for(let s=0,o=Bo.length;s<o;s++){const a=Bo[s];a.instanceId=r,a.object=this,t.push(a)}Bo.length=0}},setColorAt:function(e,t){this.instanceColor===null&&(this.instanceColor=new Se(new Float32Array(this.count*3),3)),t.toArray(this.instanceColor.array,e*3)},setMatrixAt:function(e,t){t.toArray(this.instanceMatrix.array,e*16)},updateMorphTargets:function(){},dispose:function(){this.dispatchEvent({type:"dispose"})}});function Tt(e){we.call(this),this.type="LineBasicMaterial",this.color=new xe(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.morphTargets=!1,this.setValues(e)}Tt.prototype=Object.create(we.prototype);Tt.prototype.constructor=Tt;Tt.prototype.isLineBasicMaterial=!0;Tt.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.morphTargets=e.morphTargets,this};const id=new z,rd=new z,sd=new Le,zo=new so,Uo=new Zn;function kn(e=new Be,t=new Tt){be.call(this),this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}kn.prototype=Object.assign(Object.create(be.prototype),{constructor:kn,isLine:!0,copy:function(e){return be.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,r=t.count;i<r;i++)id.fromBufferAttribute(t,i-1),rd.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=id.distanceTo(rd);e.setAttribute("lineDistance",new Ie(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;n[0]=0;for(let i=1,r=t.length;i<r;i++)n[i]=n[i-1],n[i]+=t[i-1].distanceTo(t[i])}return this},raycast:function(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold;if(n.boundingSphere===null&&n.computeBoundingSphere(),Uo.copy(n.boundingSphere),Uo.applyMatrix4(i),Uo.radius+=r,e.ray.intersectsSphere(Uo)===!1)return;sd.copy(i).invert(),zo.copy(e.ray).applyMatrix4(sd);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s,a=new z,l=new z,c=new z,f=new z,u=this.isLineSegments?2:1;if(n.isBufferGeometry){const d=n.index,p=n.attributes.position;if(d!==null){const v=d.array;for(let y=0,m=v.length-1;y<m;y+=u){const g=v[y],T=v[y+1];if(a.fromBufferAttribute(p,g),l.fromBufferAttribute(p,T),zo.distanceSqToSegment(a,l,f,c)>o)continue;f.applyMatrix4(this.matrixWorld);const A=e.ray.origin.distanceTo(f);A<e.near||A>e.far||t.push({distance:A,point:c.clone().applyMatrix4(this.matrixWorld),index:y,face:null,faceIndex:null,object:this})}}else for(let v=0,y=p.count-1;v<y;v+=u){if(a.fromBufferAttribute(p,v),l.fromBufferAttribute(p,v+1),zo.distanceSqToSegment(a,l,f,c)>o)continue;f.applyMatrix4(this.matrixWorld);const g=e.ray.origin.distanceTo(f);g<e.near||g>e.far||t.push({distance:g,point:c.clone().applyMatrix4(this.matrixWorld),index:v,face:null,faceIndex:null,object:this})}}else if(n.isGeometry){const d=n.vertices,h=d.length;for(let p=0;p<h-1;p+=u){if(zo.distanceSqToSegment(d[p],d[p+1],f,c)>o)continue;f.applyMatrix4(this.matrixWorld);const y=e.ray.origin.distanceTo(f);y<e.near||y>e.far||t.push({distance:y,point:c.clone().applyMatrix4(this.matrixWorld),index:p,face:null,faceIndex:null,object:this})}}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});const Ho=new z,ko=new z;function kr(e,t){kn.call(this,e,t),this.type="LineSegments"}kr.prototype=Object.assign(Object.create(kn.prototype),{constructor:kr,isLineSegments:!0,computeLineDistances:function(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,r=t.count;i<r;i+=2)Ho.fromBufferAttribute(t,i),ko.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+Ho.distanceTo(ko);e.setAttribute("lineDistance",new Ie(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else if(e.isGeometry){const t=e.vertices,n=e.lineDistances;for(let i=0,r=t.length;i<r;i+=2)Ho.copy(t[i]),ko.copy(t[i+1]),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+Ho.distanceTo(ko)}return this}});function vc(e,t){kn.call(this,e,t),this.type="LineLoop"}vc.prototype=Object.assign(Object.create(kn.prototype),{constructor:vc,isLineLoop:!0});function Gn(e){we.call(this),this.type="PointsMaterial",this.color=new xe(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.morphTargets=!1,this.setValues(e)}Gn.prototype=Object.create(we.prototype);Gn.prototype.constructor=Gn;Gn.prototype.isPointsMaterial=!0;Gn.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.morphTargets=e.morphTargets,this};const od=new Le,yc=new so,Go=new Zn,Vo=new z;function ya(e=new Be,t=new Gn){be.call(this),this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}ya.prototype=Object.assign(Object.create(be.prototype),{constructor:ya,isPoints:!0,copy:function(e){return be.prototype.copy.call(this,e),this.material=e.material,this.geometry=e.geometry,this},raycast:function(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold;if(n.boundingSphere===null&&n.computeBoundingSphere(),Go.copy(n.boundingSphere),Go.applyMatrix4(i),Go.radius+=r,e.ray.intersectsSphere(Go)===!1)return;od.copy(i).invert(),yc.copy(e.ray).applyMatrix4(od);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),o=s*s;if(n.isBufferGeometry){const a=n.index,c=n.attributes.position;if(a!==null){const f=a.array;for(let u=0,d=f.length;u<d;u++){const h=f[u];Vo.fromBufferAttribute(c,h),Pl(Vo,h,o,i,e,t,this)}}else for(let f=0,u=c.count;f<u;f++)Vo.fromBufferAttribute(c,f),Pl(Vo,f,o,i,e,t,this)}else{const a=n.vertices;for(let l=0,c=a.length;l<c;l++)Pl(a[l],l,o,i,e,t,this)}},updateMorphTargets:function(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}});function Pl(e,t,n,i,r,s,o){const a=yc.distanceSqToPoint(e);if(a<n){const l=new z;yc.closestPointToPoint(e,l),l.applyMatrix4(i);const c=r.ray.origin.distanceTo(l);if(c<r.near||c>r.far)return;s.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:t,face:null,object:o})}}function ad(e,t,n,i,r,s,o,a,l){qe.call(this,e,t,n,i,r,s,o,a,l),this.format=o!==void 0?o:xi,this.minFilter=s!==void 0?s:ct,this.magFilter=r!==void 0?r:ct,this.generateMipmaps=!1;const c=this;function f(){c.needsUpdate=!0,e.requestVideoFrameCallback(f)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(f)}ad.prototype=Object.assign(Object.create(qe.prototype),{constructor:ad,clone:function(){return new this.constructor(this.image).copy(this)},isVideoTexture:!0,update:function(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}});function js(e,t,n,i,r,s,o,a,l,c,f,u){qe.call(this,null,s,o,a,l,c,i,r,f,u),this.image={width:t,height:n},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}js.prototype=Object.create(qe.prototype);js.prototype.constructor=js;js.prototype.isCompressedTexture=!0;function qs(e,t,n,i,r,s,o,a,l){qe.call(this,e,t,n,i,r,s,o,a,l),this.needsUpdate=!0}qs.prototype=Object.create(qe.prototype);qs.prototype.constructor=qs;qs.prototype.isCanvasTexture=!0;function xa(e,t,n,i,r,s,o,a,l,c){if(c=c!==void 0?c:Cr,c!==Cr&&c!==Bs)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&c===Cr&&(n=fa),n===void 0&&c===Bs&&(n=Ts),qe.call(this,null,i,r,s,o,a,c,n,l),this.image={width:e,height:t},this.magFilter=o!==void 0?o:xt,this.minFilter=a!==void 0?a:xt,this.flipY=!1,this.generateMipmaps=!1}xa.prototype=Object.create(qe.prototype);xa.prototype.constructor=xa;xa.prototype.isDepthTexture=!0;let hw=0;const xn=new Le,Rl=new be,Wo=new z;function Ot(){Object.defineProperty(this,"id",{value:hw+=2}),this.uuid=Ee.generateUUID(),this.name="",this.type="Geometry",this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.elementsNeedUpdate=!1,this.verticesNeedUpdate=!1,this.uvsNeedUpdate=!1,this.normalsNeedUpdate=!1,this.colorsNeedUpdate=!1,this.lineDistancesNeedUpdate=!1,this.groupsNeedUpdate=!1}Ot.prototype=Object.assign(Object.create(Yn.prototype),{constructor:Ot,isGeometry:!0,applyMatrix4:function(e){const t=new It().getNormalMatrix(e);for(let n=0,i=this.vertices.length;n<i;n++)this.vertices[n].applyMatrix4(e);for(let n=0,i=this.faces.length;n<i;n++){const r=this.faces[n];r.normal.applyMatrix3(t).normalize();for(let s=0,o=r.vertexNormals.length;s<o;s++)r.vertexNormals[s].applyMatrix3(t).normalize()}return this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this.verticesNeedUpdate=!0,this.normalsNeedUpdate=!0,this},rotateX:function(e){return xn.makeRotationX(e),this.applyMatrix4(xn),this},rotateY:function(e){return xn.makeRotationY(e),this.applyMatrix4(xn),this},rotateZ:function(e){return xn.makeRotationZ(e),this.applyMatrix4(xn),this},translate:function(e,t,n){return xn.makeTranslation(e,t,n),this.applyMatrix4(xn),this},scale:function(e,t,n){return xn.makeScale(e,t,n),this.applyMatrix4(xn),this},lookAt:function(e){return Rl.lookAt(e),Rl.updateMatrix(),this.applyMatrix4(Rl.matrix),this},fromBufferGeometry:function(e){const t=this,n=e.index!==null?e.index:void 0,i=e.attributes;if(i.position===void 0)return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."),this;const r=i.position,s=i.normal,o=i.color,a=i.uv,l=i.uv2;l!==void 0&&(this.faceVertexUvs[1]=[]);for(let u=0;u<r.count;u++)t.vertices.push(new z().fromBufferAttribute(r,u)),o!==void 0&&t.colors.push(new xe().fromBufferAttribute(o,u));function c(u,d,h,p){const v=o===void 0?[]:[t.colors[u].clone(),t.colors[d].clone(),t.colors[h].clone()],y=s===void 0?[]:[new z().fromBufferAttribute(s,u),new z().fromBufferAttribute(s,d),new z().fromBufferAttribute(s,h)],m=new ac(u,d,h,y,v,p);t.faces.push(m),a!==void 0&&t.faceVertexUvs[0].push([new le().fromBufferAttribute(a,u),new le().fromBufferAttribute(a,d),new le().fromBufferAttribute(a,h)]),l!==void 0&&t.faceVertexUvs[1].push([new le().fromBufferAttribute(l,u),new le().fromBufferAttribute(l,d),new le().fromBufferAttribute(l,h)])}const f=e.groups;if(f.length>0)for(let u=0;u<f.length;u++){const d=f[u],h=d.start,p=d.count;for(let v=h,y=h+p;v<y;v+=3)n!==void 0?c(n.getX(v),n.getX(v+1),n.getX(v+2),d.materialIndex):c(v,v+1,v+2,d.materialIndex)}else if(n!==void 0)for(let u=0;u<n.count;u+=3)c(n.getX(u),n.getX(u+1),n.getX(u+2));else for(let u=0;u<r.count;u+=3)c(u,u+1,u+2);return this.computeFaceNormals(),e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this},center:function(){return this.computeBoundingBox(),this.boundingBox.getCenter(Wo).negate(),this.translate(Wo.x,Wo.y,Wo.z),this},normalize:function(){this.computeBoundingSphere();const e=this.boundingSphere.center,t=this.boundingSphere.radius,n=t===0?1:1/t,i=new Le;return i.set(n,0,0,-n*e.x,0,n,0,-n*e.y,0,0,n,-n*e.z,0,0,0,1),this.applyMatrix4(i),this},computeFaceNormals:function(){const e=new z,t=new z;for(let n=0,i=this.faces.length;n<i;n++){const r=this.faces[n],s=this.vertices[r.a],o=this.vertices[r.b],a=this.vertices[r.c];e.subVectors(a,o),t.subVectors(s,o),e.cross(t),e.normalize(),r.normal.copy(e)}},computeVertexNormals:function(e=!0){const t=new Array(this.vertices.length);for(let n=0,i=this.vertices.length;n<i;n++)t[n]=new z;if(e){const n=new z,i=new z;for(let r=0,s=this.faces.length;r<s;r++){const o=this.faces[r],a=this.vertices[o.a],l=this.vertices[o.b],c=this.vertices[o.c];n.subVectors(c,l),i.subVectors(a,l),n.cross(i),t[o.a].add(n),t[o.b].add(n),t[o.c].add(n)}}else{this.computeFaceNormals();for(let n=0,i=this.faces.length;n<i;n++){const r=this.faces[n];t[r.a].add(r.normal),t[r.b].add(r.normal),t[r.c].add(r.normal)}}for(let n=0,i=this.vertices.length;n<i;n++)t[n].normalize();for(let n=0,i=this.faces.length;n<i;n++){const r=this.faces[n],s=r.vertexNormals;s.length===3?(s[0].copy(t[r.a]),s[1].copy(t[r.b]),s[2].copy(t[r.c])):(s[0]=t[r.a].clone(),s[1]=t[r.b].clone(),s[2]=t[r.c].clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeFlatVertexNormals:function(){this.computeFaceNormals();for(let e=0,t=this.faces.length;e<t;e++){const n=this.faces[e],i=n.vertexNormals;i.length===3?(i[0].copy(n.normal),i[1].copy(n.normal),i[2].copy(n.normal)):(i[0]=n.normal.clone(),i[1]=n.normal.clone(),i[2]=n.normal.clone())}this.faces.length>0&&(this.normalsNeedUpdate=!0)},computeMorphNormals:function(){for(let t=0,n=this.faces.length;t<n;t++){const i=this.faces[t];i.__originalFaceNormal?i.__originalFaceNormal.copy(i.normal):i.__originalFaceNormal=i.normal.clone(),i.__originalVertexNormals||(i.__originalVertexNormals=[]);for(let r=0,s=i.vertexNormals.length;r<s;r++)i.__originalVertexNormals[r]?i.__originalVertexNormals[r].copy(i.vertexNormals[r]):i.__originalVertexNormals[r]=i.vertexNormals[r].clone()}const e=new Ot;e.faces=this.faces;for(let t=0,n=this.morphTargets.length;t<n;t++){if(!this.morphNormals[t]){this.morphNormals[t]={},this.morphNormals[t].faceNormals=[],this.morphNormals[t].vertexNormals=[];const r=this.morphNormals[t].faceNormals,s=this.morphNormals[t].vertexNormals;for(let o=0,a=this.faces.length;o<a;o++){const l=new z,c={a:new z,b:new z,c:new z};r.push(l),s.push(c)}}const i=this.morphNormals[t];e.vertices=this.morphTargets[t].vertices,e.computeFaceNormals(),e.computeVertexNormals();for(let r=0,s=this.faces.length;r<s;r++){const o=this.faces[r],a=i.faceNormals[r],l=i.vertexNormals[r];a.copy(o.normal),l.a.copy(o.vertexNormals[0]),l.b.copy(o.vertexNormals[1]),l.c.copy(o.vertexNormals[2])}}for(let t=0,n=this.faces.length;t<n;t++){const i=this.faces[t];i.normal=i.__originalFaceNormal,i.vertexNormals=i.__originalVertexNormals}},computeBoundingBox:function(){this.boundingBox===null&&(this.boundingBox=new Jn),this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){this.boundingSphere===null&&(this.boundingSphere=new Zn),this.boundingSphere.setFromPoints(this.vertices)},merge:function(e,t,n=0){if(!(e&&e.isGeometry)){console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",e);return}let i;const r=this.vertices.length,s=this.vertices,o=e.vertices,a=this.faces,l=e.faces,c=this.colors,f=e.colors;t!==void 0&&(i=new It().getNormalMatrix(t));for(let u=0,d=o.length;u<d;u++){const p=o[u].clone();t!==void 0&&p.applyMatrix4(t),s.push(p)}for(let u=0,d=f.length;u<d;u++)c.push(f[u].clone());for(let u=0,d=l.length;u<d;u++){const h=l[u];let p,v;const y=h.vertexNormals,m=h.vertexColors,g=new ac(h.a+r,h.b+r,h.c+r);g.normal.copy(h.normal),i!==void 0&&g.normal.applyMatrix3(i).normalize();for(let T=0,P=y.length;T<P;T++)p=y[T].clone(),i!==void 0&&p.applyMatrix3(i).normalize(),g.vertexNormals.push(p);g.color.copy(h.color);for(let T=0,P=m.length;T<P;T++)v=m[T],g.vertexColors.push(v.clone());g.materialIndex=h.materialIndex+n,a.push(g)}for(let u=0,d=e.faceVertexUvs.length;u<d;u++){const h=e.faceVertexUvs[u];this.faceVertexUvs[u]===void 0&&(this.faceVertexUvs[u]=[]);for(let p=0,v=h.length;p<v;p++){const y=h[p],m=[];for(let g=0,T=y.length;g<T;g++)m.push(y[g].clone());this.faceVertexUvs[u].push(m)}}},mergeMesh:function(e){if(!(e&&e.isMesh)){console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.",e);return}e.matrixAutoUpdate&&e.updateMatrix(),this.merge(e.geometry,e.matrix)},mergeVertices:function(e=4){const t={},n=[],i=[],r=Math.pow(10,e);for(let a=0,l=this.vertices.length;a<l;a++){const c=this.vertices[a],f=Math.round(c.x*r)+"_"+Math.round(c.y*r)+"_"+Math.round(c.z*r);t[f]===void 0?(t[f]=a,n.push(this.vertices[a]),i[a]=n.length-1):i[a]=i[t[f]]}const s=[];for(let a=0,l=this.faces.length;a<l;a++){const c=this.faces[a];c.a=i[c.a],c.b=i[c.b],c.c=i[c.c];const f=[c.a,c.b,c.c];for(let u=0;u<3;u++)if(f[u]===f[(u+1)%3]){s.push(a);break}}for(let a=s.length-1;a>=0;a--){const l=s[a];this.faces.splice(l,1);for(let c=0,f=this.faceVertexUvs.length;c<f;c++)this.faceVertexUvs[c].splice(l,1)}const o=this.vertices.length-n.length;return this.vertices=n,o},setFromPoints:function(e){this.vertices=[];for(let t=0,n=e.length;t<n;t++){const i=e[t];this.vertices.push(new z(i.x,i.y,i.z||0))}return this},sortFacesByMaterialIndex:function(){const e=this.faces,t=e.length;for(let a=0;a<t;a++)e[a]._id=a;function n(a,l){return a.materialIndex-l.materialIndex}e.sort(n);const i=this.faceVertexUvs[0],r=this.faceVertexUvs[1];let s,o;i&&i.length===t&&(s=[]),r&&r.length===t&&(o=[]);for(let a=0;a<t;a++){const l=e[a]._id;s&&s.push(i[l]),o&&o.push(r[l])}s&&(this.faceVertexUvs[0]=s),o&&(this.faceVertexUvs[1]=o)},toJSON:function(){const e={metadata:{version:4.5,type:"Geometry",generator:"Geometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),this.parameters!==void 0){const h=this.parameters;for(const p in h)h[p]!==void 0&&(e[p]=h[p]);return e}const t=[];for(let h=0;h<this.vertices.length;h++){const p=this.vertices[h];t.push(p.x,p.y,p.z)}const n=[],i=[],r={},s=[],o={},a=[],l={};for(let h=0;h<this.faces.length;h++){const p=this.faces[h],v=!0,y=!1,m=this.faceVertexUvs[0][h]!==void 0,g=p.normal.length()>0,T=p.vertexNormals.length>0,P=p.color.r!==1||p.color.g!==1||p.color.b!==1,A=p.vertexColors.length>0;let M=0;if(M=c(M,0,0),M=c(M,1,v),M=c(M,2,y),M=c(M,3,m),M=c(M,4,g),M=c(M,5,T),M=c(M,6,P),M=c(M,7,A),n.push(M),n.push(p.a,p.b,p.c),n.push(p.materialIndex),m){const N=this.faceVertexUvs[0][h];n.push(d(N[0]),d(N[1]),d(N[2]))}if(g&&n.push(f(p.normal)),T){const N=p.vertexNormals;n.push(f(N[0]),f(N[1]),f(N[2]))}if(P&&n.push(u(p.color)),A){const N=p.vertexColors;n.push(u(N[0]),u(N[1]),u(N[2]))}}function c(h,p,v){return v?h|1<<p:h&~(1<<p)}function f(h){const p=h.x.toString()+h.y.toString()+h.z.toString();return r[p]!==void 0||(r[p]=i.length/3,i.push(h.x,h.y,h.z)),r[p]}function u(h){const p=h.r.toString()+h.g.toString()+h.b.toString();return o[p]!==void 0||(o[p]=s.length,s.push(h.getHex())),o[p]}function d(h){const p=h.x.toString()+h.y.toString();return l[p]!==void 0||(l[p]=a.length/2,a.push(h.x,h.y)),l[p]}return e.data={},e.data.vertices=t,e.data.normals=i,s.length>0&&(e.data.colors=s),a.length>0&&(e.data.uvs=[a]),e.data.faces=n,e},clone:function(){return new Ot().copy(this)},copy:function(e){this.vertices=[],this.colors=[],this.faces=[],this.faceVertexUvs=[[]],this.morphTargets=[],this.morphNormals=[],this.skinWeights=[],this.skinIndices=[],this.lineDistances=[],this.boundingBox=null,this.boundingSphere=null,this.name=e.name;const t=e.vertices;for(let u=0,d=t.length;u<d;u++)this.vertices.push(t[u].clone());const n=e.colors;for(let u=0,d=n.length;u<d;u++)this.colors.push(n[u].clone());const i=e.faces;for(let u=0,d=i.length;u<d;u++)this.faces.push(i[u].clone());for(let u=0,d=e.faceVertexUvs.length;u<d;u++){const h=e.faceVertexUvs[u];this.faceVertexUvs[u]===void 0&&(this.faceVertexUvs[u]=[]);for(let p=0,v=h.length;p<v;p++){const y=h[p],m=[];for(let g=0,T=y.length;g<T;g++){const P=y[g];m.push(P.clone())}this.faceVertexUvs[u].push(m)}}const r=e.morphTargets;for(let u=0,d=r.length;u<d;u++){const h={};if(h.name=r[u].name,r[u].vertices!==void 0){h.vertices=[];for(let p=0,v=r[u].vertices.length;p<v;p++)h.vertices.push(r[u].vertices[p].clone())}if(r[u].normals!==void 0){h.normals=[];for(let p=0,v=r[u].normals.length;p<v;p++)h.normals.push(r[u].normals[p].clone())}this.morphTargets.push(h)}const s=e.morphNormals;for(let u=0,d=s.length;u<d;u++){const h={};if(s[u].vertexNormals!==void 0){h.vertexNormals=[];for(let p=0,v=s[u].vertexNormals.length;p<v;p++){const y=s[u].vertexNormals[p],m={};m.a=y.a.clone(),m.b=y.b.clone(),m.c=y.c.clone(),h.vertexNormals.push(m)}}if(s[u].faceNormals!==void 0){h.faceNormals=[];for(let p=0,v=s[u].faceNormals.length;p<v;p++)h.faceNormals.push(s[u].faceNormals[p].clone())}this.morphNormals.push(h)}const o=e.skinWeights;for(let u=0,d=o.length;u<d;u++)this.skinWeights.push(o[u].clone());const a=e.skinIndices;for(let u=0,d=a.length;u<d;u++)this.skinIndices.push(a[u].clone());const l=e.lineDistances;for(let u=0,d=l.length;u<d;u++)this.lineDistances.push(l[u]);const c=e.boundingBox;c!==null&&(this.boundingBox=c.clone());const f=e.boundingSphere;return f!==null&&(this.boundingSphere=f.clone()),this.elementsNeedUpdate=e.elementsNeedUpdate,this.verticesNeedUpdate=e.verticesNeedUpdate,this.uvsNeedUpdate=e.uvsNeedUpdate,this.normalsNeedUpdate=e.normalsNeedUpdate,this.colorsNeedUpdate=e.colorsNeedUpdate,this.lineDistancesNeedUpdate=e.lineDistancesNeedUpdate,this.groupsNeedUpdate=e.groupsNeedUpdate,this},dispose:function(){this.dispatchEvent({type:"dispose"})}});class pw extends Ot{constructor(t,n,i,r,s,o){super(),this.type="BoxGeometry",this.parameters={width:t,height:n,depth:i,widthSegments:r,heightSegments:s,depthSegments:o},this.fromBufferGeometry(new vu(t,n,i,r,s,o)),this.mergeVertices()}}class mw extends Be{constructor(t=1,n=1,i=1,r=8,s=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderBufferGeometry",this.parameters={radiusTop:t,radiusBottom:n,height:i,radialSegments:r,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:l};const c=this;r=Math.floor(r),s=Math.floor(s);const f=[],u=[],d=[],h=[];let p=0;const v=[],y=i/2;let m=0;g(),o===!1&&(t>0&&T(!0),n>0&&T(!1)),this.setIndex(f),this.setAttribute("position",new Ie(u,3)),this.setAttribute("normal",new Ie(d,3)),this.setAttribute("uv",new Ie(h,2));function g(){const P=new z,A=new z;let M=0;const N=(n-t)/i;for(let B=0;B<=s;B++){const W=[],te=B/s,H=te*(n-t)+t;for(let j=0;j<=r;j++){const Y=j/r,X=Y*l+a,q=Math.sin(X),$=Math.cos(X);A.x=H*q,A.y=-te*i+y,A.z=H*$,u.push(A.x,A.y,A.z),P.set(q,N,$).normalize(),d.push(P.x,P.y,P.z),h.push(Y,1-te),W.push(p++)}v.push(W)}for(let B=0;B<r;B++)for(let W=0;W<s;W++){const te=v[W][B],H=v[W+1][B],j=v[W+1][B+1],Y=v[W][B+1];f.push(te,H,Y),f.push(H,j,Y),M+=6}c.addGroup(m,M,0),m+=M}function T(P){const A=p,M=new le,N=new z;let B=0;const W=P===!0?t:n,te=P===!0?1:-1;for(let j=1;j<=r;j++)u.push(0,y*te,0),d.push(0,te,0),h.push(.5,.5),p++;const H=p;for(let j=0;j<=r;j++){const X=j/r*l+a,q=Math.cos(X),$=Math.sin(X);N.x=W*$,N.y=y*te,N.z=W*q,u.push(N.x,N.y,N.z),d.push(0,te,0),M.x=q*.5+.5,M.y=$*.5*te+.5,h.push(M.x,M.y),p++}for(let j=0;j<r;j++){const Y=A+j,X=H+j;P===!0?f.push(X,X+1,Y):f.push(X+1,X,Y),B+=3}c.addGroup(m,B,P===!0?1:2),m+=B}}}class gw extends Ot{constructor(t,n,i,r,s,o,a,l){super(),this.type="CylinderGeometry",this.parameters={radiusTop:t,radiusBottom:n,height:i,radialSegments:r,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:l},this.fromBufferGeometry(new mw(t,n,i,r,s,o,a,l)),this.mergeVertices()}}new z;new z;new z;new _t;const vw={triangulate:function(e,t,n){n=n||2;const i=t&&t.length,r=i?t[0]*n:e.length;let s=cp(e,0,r,n,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,f,u,d,h;if(i&&(s=ww(e,t,s,n)),e.length>80*n){a=c=e[0],l=f=e[1];for(let p=n;p<r;p+=n)u=e[p],d=e[p+1],u<a&&(a=u),d<l&&(l=d),u>c&&(c=u),d>f&&(f=d);h=Math.max(c-a,f-l),h=h!==0?1/h:0}return Xs(s,o,n,a,l,h),o}};function cp(e,t,n,i,r){let s,o;if(r===Ow(e,t,n,i)>0)for(s=t;s<n;s+=i)o=ld(s,e[s],e[s+1],o);else for(s=n-i;s>=t;s-=i)o=ld(s,e[s],e[s+1],o);return o&&Wa(o,o.next)&&(Js(o),o=o.next),o}function Li(e,t){if(!e)return e;t||(t=e);let n=e,i;do if(i=!1,!n.steiner&&(Wa(n,n.next)||Ze(n.prev,n,n.next)===0)){if(Js(n),n=t=n.prev,n===n.next)break;i=!0}else n=n.next;while(i||n!==t);return t}function Xs(e,t,n,i,r,s,o){if(!e)return;!o&&s&&Aw(e,i,r,s);let a=e,l,c;for(;e.prev!==e.next;){if(l=e.prev,c=e.next,s?xw(e,i,r,s):yw(e)){t.push(l.i/n),t.push(e.i/n),t.push(c.i/n),Js(e),e=c.next,a=c.next;continue}if(e=c,e===a){o?o===1?(e=_w(Li(e),t,n),Xs(e,t,n,i,r,s,2)):o===2&&bw(e,t,n,i,r,s):Xs(Li(e),t,n,i,r,s,1);break}}}function yw(e){const t=e.prev,n=e,i=e.next;if(Ze(t,n,i)>=0)return!1;let r=e.next.next;for(;r!==e.prev;){if(Tr(t.x,t.y,n.x,n.y,i.x,i.y,r.x,r.y)&&Ze(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function xw(e,t,n,i){const r=e.prev,s=e,o=e.next;if(Ze(r,s,o)>=0)return!1;const a=r.x<s.x?r.x<o.x?r.x:o.x:s.x<o.x?s.x:o.x,l=r.y<s.y?r.y<o.y?r.y:o.y:s.y<o.y?s.y:o.y,c=r.x>s.x?r.x>o.x?r.x:o.x:s.x>o.x?s.x:o.x,f=r.y>s.y?r.y>o.y?r.y:o.y:s.y>o.y?s.y:o.y,u=xc(a,l,t,n,i),d=xc(c,f,t,n,i);let h=e.prevZ,p=e.nextZ;for(;h&&h.z>=u&&p&&p.z<=d;){if(h!==e.prev&&h!==e.next&&Tr(r.x,r.y,s.x,s.y,o.x,o.y,h.x,h.y)&&Ze(h.prev,h,h.next)>=0||(h=h.prevZ,p!==e.prev&&p!==e.next&&Tr(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&Ze(p.prev,p,p.next)>=0))return!1;p=p.nextZ}for(;h&&h.z>=u;){if(h!==e.prev&&h!==e.next&&Tr(r.x,r.y,s.x,s.y,o.x,o.y,h.x,h.y)&&Ze(h.prev,h,h.next)>=0)return!1;h=h.prevZ}for(;p&&p.z<=d;){if(p!==e.prev&&p!==e.next&&Tr(r.x,r.y,s.x,s.y,o.x,o.y,p.x,p.y)&&Ze(p.prev,p,p.next)>=0)return!1;p=p.nextZ}return!0}function _w(e,t,n){let i=e;do{const r=i.prev,s=i.next.next;!Wa(r,s)&&up(r,i,i.next,s)&&Ys(r,s)&&Ys(s,r)&&(t.push(r.i/n),t.push(i.i/n),t.push(s.i/n),Js(i),Js(i.next),i=e=s),i=i.next}while(i!==e);return Li(i)}function bw(e,t,n,i,r,s){let o=e;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&Pw(o,a)){let l=fp(o,a);o=Li(o,o.next),l=Li(l,l.next),Xs(o,t,n,i,r,s),Xs(l,t,n,i,r,s);return}a=a.next}o=o.next}while(o!==e)}function ww(e,t,n,i){const r=[];let s,o,a,l,c;for(s=0,o=t.length;s<o;s++)a=t[s]*i,l=s<o-1?t[s+1]*i:e.length,c=cp(e,a,l,i,!1),c===c.next&&(c.steiner=!0),r.push(Cw(c));for(r.sort(Mw),s=0;s<r.length;s++)Sw(r[s],n),n=Li(n,n.next);return n}function Mw(e,t){return e.x-t.x}function Sw(e,t){if(t=Tw(e,t),t){const n=fp(t,e);Li(t,t.next),Li(n,n.next)}}function Tw(e,t){let n=t;const i=e.x,r=e.y;let s=-1/0,o;do{if(r<=n.y&&r>=n.next.y&&n.next.y!==n.y){const d=n.x+(r-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(d<=i&&d>s){if(s=d,d===i){if(r===n.y)return n;if(r===n.next.y)return n.next}o=n.x<n.next.x?n:n.next}}n=n.next}while(n!==t);if(!o)return null;if(i===s)return o;const a=o,l=o.x,c=o.y;let f=1/0,u;n=o;do i>=n.x&&n.x>=l&&i!==n.x&&Tr(r<c?i:s,r,l,c,r<c?s:i,r,n.x,n.y)&&(u=Math.abs(r-n.y)/(i-n.x),Ys(n,e)&&(u<f||u===f&&(n.x>o.x||n.x===o.x&&Ew(o,n)))&&(o=n,f=u)),n=n.next;while(n!==a);return o}function Ew(e,t){return Ze(e.prev,e,t.prev)<0&&Ze(t.next,e,e.next)<0}function Aw(e,t,n,i){let r=e;do r.z===null&&(r.z=xc(r.x,r.y,t,n,i)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==e);r.prevZ.nextZ=null,r.prevZ=null,Lw(r)}function Lw(e){let t,n,i,r,s,o,a,l,c=1;do{for(n=e,e=null,s=null,o=0;n;){for(o++,i=n,a=0,t=0;t<c&&(a++,i=i.nextZ,!!i);t++);for(l=c;a>0||l>0&&i;)a!==0&&(l===0||!i||n.z<=i.z)?(r=n,n=n.nextZ,a--):(r=i,i=i.nextZ,l--),s?s.nextZ=r:e=r,r.prevZ=s,s=r;n=i}s.nextZ=null,c*=2}while(o>1);return e}function xc(e,t,n,i,r){return e=32767*(e-n)*r,t=32767*(t-i)*r,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e|t<<1}function Cw(e){let t=e,n=e;do(t.x<n.x||t.x===n.x&&t.y<n.y)&&(n=t),t=t.next;while(t!==e);return n}function Tr(e,t,n,i,r,s,o,a){return(r-o)*(t-a)-(e-o)*(s-a)>=0&&(e-o)*(i-a)-(n-o)*(t-a)>=0&&(n-o)*(s-a)-(r-o)*(i-a)>=0}function Pw(e,t){return e.next.i!==t.i&&e.prev.i!==t.i&&!Rw(e,t)&&(Ys(e,t)&&Ys(t,e)&&Iw(e,t)&&(Ze(e.prev,e,t.prev)||Ze(e,t.prev,t))||Wa(e,t)&&Ze(e.prev,e,e.next)>0&&Ze(t.prev,t,t.next)>0)}function Ze(e,t,n){return(t.y-e.y)*(n.x-t.x)-(t.x-e.x)*(n.y-t.y)}function Wa(e,t){return e.x===t.x&&e.y===t.y}function up(e,t,n,i){const r=qo(Ze(e,t,n)),s=qo(Ze(e,t,i)),o=qo(Ze(n,i,e)),a=qo(Ze(n,i,t));return!!(r!==s&&o!==a||r===0&&jo(e,n,t)||s===0&&jo(e,i,t)||o===0&&jo(n,e,i)||a===0&&jo(n,t,i))}function jo(e,t,n){return t.x<=Math.max(e.x,n.x)&&t.x>=Math.min(e.x,n.x)&&t.y<=Math.max(e.y,n.y)&&t.y>=Math.min(e.y,n.y)}function qo(e){return e>0?1:e<0?-1:0}function Rw(e,t){let n=e;do{if(n.i!==e.i&&n.next.i!==e.i&&n.i!==t.i&&n.next.i!==t.i&&up(n,n.next,e,t))return!0;n=n.next}while(n!==e);return!1}function Ys(e,t){return Ze(e.prev,e,e.next)<0?Ze(e,t,e.next)>=0&&Ze(e,e.prev,t)>=0:Ze(e,t,e.prev)<0||Ze(e,e.next,t)<0}function Iw(e,t){let n=e,i=!1;const r=(e.x+t.x)/2,s=(e.y+t.y)/2;do n.y>s!=n.next.y>s&&n.next.y!==n.y&&r<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(i=!i),n=n.next;while(n!==e);return i}function fp(e,t){const n=new _c(e.i,e.x,e.y),i=new _c(t.i,t.x,t.y),r=e.next,s=t.prev;return e.next=t,t.prev=e,n.next=r,r.prev=n,i.next=n,n.prev=i,s.next=i,i.prev=s,i}function ld(e,t,n,i){const r=new _c(e,t,n);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function Js(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function _c(e,t,n){this.i=e,this.x=t,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Ow(e,t,n,i){let r=0;for(let s=t,o=n-i;s<n;s+=i)r+=(e[o]-e[s])*(e[s+1]+e[o+1]),o=s;return r}const bi={area:function(e){const t=e.length;let n=0;for(let i=t-1,r=0;r<t;i=r++)n+=e[i].x*e[r].y-e[r].x*e[i].y;return n*.5},isClockWise:function(e){return bi.area(e)<0},triangulateShape:function(e,t){const n=[],i=[],r=[];cd(e),ud(n,e);let s=e.length;t.forEach(cd);for(let a=0;a<t.length;a++)i.push(s),s+=t[a].length,ud(n,t[a]);const o=vw.triangulate(n,i);for(let a=0;a<o.length;a+=3)r.push(o.slice(a,a+3));return r}};function cd(e){const t=e.length;t>2&&e[t-1].equals(e[0])&&e.pop()}function ud(e,t){for(let n=0;n<t.length;n++)e.push(t[n].x),e.push(t[n].y)}class dp extends Be{constructor(t,n){super(),this.type="ExtrudeBufferGeometry",this.parameters={shapes:t,options:n},t=Array.isArray(t)?t:[t];const i=this,r=[],s=[];for(let a=0,l=t.length;a<l;a++){const c=t[a];o(c)}this.setAttribute("position",new Ie(r,3)),this.setAttribute("uv",new Ie(s,2)),this.computeVertexNormals();function o(a){const l=[],c=n.curveSegments!==void 0?n.curveSegments:12,f=n.steps!==void 0?n.steps:1;let u=n.depth!==void 0?n.depth:100,d=n.bevelEnabled!==void 0?n.bevelEnabled:!0,h=n.bevelThickness!==void 0?n.bevelThickness:6,p=n.bevelSize!==void 0?n.bevelSize:h-2,v=n.bevelOffset!==void 0?n.bevelOffset:0,y=n.bevelSegments!==void 0?n.bevelSegments:3;const m=n.extrudePath,g=n.UVGenerator!==void 0?n.UVGenerator:Nw;n.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),u=n.amount);let T,P=!1,A,M,N,B;m&&(T=m.getSpacedPoints(f),P=!0,d=!1,A=m.computeFrenetFrames(f,!1),M=new z,N=new z,B=new z),d||(y=0,h=0,p=0,v=0);const W=a.extractPoints(c);let te=W.shape;const H=W.holes;if(!bi.isClockWise(te)){te=te.reverse();for(let x=0,_=H.length;x<_;x++){const L=H[x];bi.isClockWise(L)&&(H[x]=L.reverse())}}const Y=bi.triangulateShape(te,H),X=te;for(let x=0,_=H.length;x<_;x++){const L=H[x];te=te.concat(L)}function q(x,_,L){return _||console.error("THREE.ExtrudeGeometry: vec does not exist"),_.clone().multiplyScalar(L).add(x)}const $=te.length,ne=Y.length;function oe(x,_,L){let F,O,b;const w=x.x-_.x,V=x.y-_.y,k=L.x-x.x,C=L.y-x.y,J=w*w+V*V,Z=w*C-V*k;if(Math.abs(Z)>Number.EPSILON){const K=Math.sqrt(J),Q=Math.sqrt(k*k+C*C),ae=_.x-V/K,ue=_.y+w/K,pe=L.x-C/Q,ce=L.y+k/Q,ye=((pe-ae)*C-(ce-ue)*k)/(w*C-V*k);F=ae+w*ye-x.x,O=ue+V*ye-x.y;const Te=F*F+O*O;if(Te<=2)return new le(F,O);b=Math.sqrt(Te/2)}else{let K=!1;w>Number.EPSILON?k>Number.EPSILON&&(K=!0):w<-Number.EPSILON?k<-Number.EPSILON&&(K=!0):Math.sign(V)===Math.sign(C)&&(K=!0),K?(F=-V,O=w,b=Math.sqrt(J)):(F=w,O=V,b=Math.sqrt(J/2))}return new le(F/b,O/b)}const fe=[];for(let x=0,_=X.length,L=_-1,F=x+1;x<_;x++,L++,F++)L===_&&(L=0),F===_&&(F=0),fe[x]=oe(X[x],X[L],X[F]);const ge=[];let he,de=fe.concat();for(let x=0,_=H.length;x<_;x++){const L=H[x];he=[];for(let F=0,O=L.length,b=O-1,w=F+1;F<O;F++,b++,w++)b===O&&(b=0),w===O&&(w=0),he[F]=oe(L[F],L[b],L[w]);ge.push(he),de=de.concat(he)}for(let x=0;x<y;x++){const _=x/y,L=h*Math.cos(_*Math.PI/2),F=p*Math.sin(_*Math.PI/2)+v;for(let O=0,b=X.length;O<b;O++){const w=q(X[O],fe[O],F);S(w.x,w.y,-L)}for(let O=0,b=H.length;O<b;O++){const w=H[O];he=ge[O];for(let V=0,k=w.length;V<k;V++){const C=q(w[V],he[V],F);S(C.x,C.y,-L)}}}const Me=p+v;for(let x=0;x<$;x++){const _=d?q(te[x],de[x],Me):te[x];P?(N.copy(A.normals[0]).multiplyScalar(_.x),M.copy(A.binormals[0]).multiplyScalar(_.y),B.copy(T[0]).add(N).add(M),S(B.x,B.y,B.z)):S(_.x,_.y,0)}for(let x=1;x<=f;x++)for(let _=0;_<$;_++){const L=d?q(te[_],de[_],Me):te[_];P?(N.copy(A.normals[x]).multiplyScalar(L.x),M.copy(A.binormals[x]).multiplyScalar(L.y),B.copy(T[x]).add(N).add(M),S(B.x,B.y,B.z)):S(L.x,L.y,u/f*x)}for(let x=y-1;x>=0;x--){const _=x/y,L=h*Math.cos(_*Math.PI/2),F=p*Math.sin(_*Math.PI/2)+v;for(let O=0,b=X.length;O<b;O++){const w=q(X[O],fe[O],F);S(w.x,w.y,u+L)}for(let O=0,b=H.length;O<b;O++){const w=H[O];he=ge[O];for(let V=0,k=w.length;V<k;V++){const C=q(w[V],he[V],F);P?S(C.x,C.y+T[f-1].y,T[f-1].x+L):S(C.x,C.y,u+L)}}}ke(),se();function ke(){const x=r.length/3;if(d){let _=0,L=$*_;for(let F=0;F<ne;F++){const O=Y[F];D(O[2]+L,O[1]+L,O[0]+L)}_=f+y*2,L=$*_;for(let F=0;F<ne;F++){const O=Y[F];D(O[0]+L,O[1]+L,O[2]+L)}}else{for(let _=0;_<ne;_++){const L=Y[_];D(L[2],L[1],L[0])}for(let _=0;_<ne;_++){const L=Y[_];D(L[0]+$*f,L[1]+$*f,L[2]+$*f)}}i.addGroup(x,r.length/3-x,0)}function se(){const x=r.length/3;let _=0;E(X,_),_+=X.length;for(let L=0,F=H.length;L<F;L++){const O=H[L];E(O,_),_+=O.length}i.addGroup(x,r.length/3-x,1)}function E(x,_){let L=x.length;for(;--L>=0;){const F=L;let O=L-1;O<0&&(O=x.length-1);for(let b=0,w=f+y*2;b<w;b++){const V=$*b,k=$*(b+1),C=_+F+V,J=_+O+V,Z=_+O+k,K=_+F+k;R(C,J,Z,K)}}}function S(x,_,L){l.push(x),l.push(_),l.push(L)}function D(x,_,L){U(x),U(_),U(L);const F=r.length/3,O=g.generateTopUV(i,r,F-3,F-2,F-1);G(O[0]),G(O[1]),G(O[2])}function R(x,_,L,F){U(x),U(_),U(F),U(_),U(L),U(F);const O=r.length/3,b=g.generateSideWallUV(i,r,O-6,O-3,O-2,O-1);G(b[0]),G(b[1]),G(b[3]),G(b[1]),G(b[2]),G(b[3])}function U(x){r.push(l[x*3+0]),r.push(l[x*3+1]),r.push(l[x*3+2])}function G(x){s.push(x.x),s.push(x.y)}}}toJSON(){const t=Be.prototype.toJSON.call(this),n=this.parameters.shapes,i=this.parameters.options;return Dw(n,i,t)}}const Nw={generateTopUV:function(e,t,n,i,r){const s=t[n*3],o=t[n*3+1],a=t[i*3],l=t[i*3+1],c=t[r*3],f=t[r*3+1];return[new le(s,o),new le(a,l),new le(c,f)]},generateSideWallUV:function(e,t,n,i,r,s){const o=t[n*3],a=t[n*3+1],l=t[n*3+2],c=t[i*3],f=t[i*3+1],u=t[i*3+2],d=t[r*3],h=t[r*3+1],p=t[r*3+2],v=t[s*3],y=t[s*3+1],m=t[s*3+2];return Math.abs(a-f)<.01?[new le(o,1-l),new le(c,1-u),new le(d,1-p),new le(v,1-m)]:[new le(a,1-l),new le(f,1-u),new le(h,1-p),new le(y,1-m)]}};function Dw(e,t,n){if(n.shapes=[],Array.isArray(e))for(let i=0,r=e.length;i<r;i++){const s=e[i];n.shapes.push(s.uuid)}else n.shapes.push(e.uuid);return t.extrudePath!==void 0&&(n.options.extrudePath=t.extrudePath.toJSON()),n}class Fw extends Ot{constructor(t,n){super(),this.type="ExtrudeGeometry",this.parameters={shapes:t,options:n},this.fromBufferGeometry(new dp(t,n)),this.mergeVertices()}toJSON(){const t=super.toJSON(),n=this.parameters.shapes,i=this.parameters.options;return Bw(n,i,t)}}function Bw(e,t,n){if(n.shapes=[],Array.isArray(e))for(let i=0,r=e.length;i<r;i++){const s=e[i];n.shapes.push(s.uuid)}else n.shapes.push(e.uuid);return t.extrudePath!==void 0&&(n.options.extrudePath=t.extrudePath.toJSON()),n}function _a(e,t,n){Be.call(this),this.type="ParametricBufferGeometry",this.parameters={func:e,slices:t,stacks:n};const i=[],r=[],s=[],o=[],a=1e-5,l=new z,c=new z,f=new z,u=new z,d=new z;e.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const h=t+1;for(let p=0;p<=n;p++){const v=p/n;for(let y=0;y<=t;y++){const m=y/t;e(m,v,c),r.push(c.x,c.y,c.z),m-a>=0?(e(m-a,v,f),u.subVectors(c,f)):(e(m+a,v,f),u.subVectors(f,c)),v-a>=0?(e(m,v-a,f),d.subVectors(c,f)):(e(m,v+a,f),d.subVectors(f,c)),l.crossVectors(u,d).normalize(),s.push(l.x,l.y,l.z),o.push(m,v)}}for(let p=0;p<n;p++)for(let v=0;v<t;v++){const y=p*h+v,m=p*h+v+1,g=(p+1)*h+v+1,T=(p+1)*h+v;i.push(y,m,T),i.push(m,g,T)}this.setIndex(i),this.setAttribute("position",new Ie(r,3)),this.setAttribute("normal",new Ie(s,3)),this.setAttribute("uv",new Ie(o,2))}_a.prototype=Object.create(Be.prototype);_a.prototype.constructor=_a;function bc(e,t,n){Ot.call(this),this.type="ParametricGeometry",this.parameters={func:e,slices:t,stacks:n},this.fromBufferGeometry(new _a(e,t,n)),this.mergeVertices()}bc.prototype=Object.create(Ot.prototype);bc.prototype.constructor=bc;class zw extends Ot{constructor(t,n,i,r){super(),this.type="PlaneGeometry",this.parameters={width:t,height:n,widthSegments:i,heightSegments:r},this.fromBufferGeometry(new $h(t,n,i,r)),this.mergeVertices()}}class Uw extends Be{constructor(t,n=12){super(),this.type="ShapeBufferGeometry",this.parameters={shapes:t,curveSegments:n};const i=[],r=[],s=[],o=[];let a=0,l=0;if(Array.isArray(t)===!1)c(t);else for(let f=0;f<t.length;f++)c(t[f]),this.addGroup(a,l,f),a+=l,l=0;this.setIndex(i),this.setAttribute("position",new Ie(r,3)),this.setAttribute("normal",new Ie(s,3)),this.setAttribute("uv",new Ie(o,2));function c(f){const u=r.length/3,d=f.extractPoints(n);let h=d.shape;const p=d.holes;bi.isClockWise(h)===!1&&(h=h.reverse());for(let y=0,m=p.length;y<m;y++){const g=p[y];bi.isClockWise(g)===!0&&(p[y]=g.reverse())}const v=bi.triangulateShape(h,p);for(let y=0,m=p.length;y<m;y++){const g=p[y];h=h.concat(g)}for(let y=0,m=h.length;y<m;y++){const g=h[y];r.push(g.x,g.y,0),s.push(0,0,1),o.push(g.x,g.y)}for(let y=0,m=v.length;y<m;y++){const g=v[y],T=g[0]+u,P=g[1]+u,A=g[2]+u;i.push(T,P,A),l+=3}}}toJSON(){const t=Be.prototype.toJSON.call(this),n=this.parameters.shapes;return Hw(n,t)}}function Hw(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,i=e.length;n<i;n++){const r=e[n];t.shapes.push(r.uuid)}else t.shapes.push(e.uuid);return t}class kw extends Ot{constructor(t,n){super(),this.type="ShapeGeometry",typeof n=="object"&&(console.warn("THREE.ShapeGeometry: Options parameter has been removed."),n=n.curveSegments),this.parameters={shapes:t,curveSegments:n},this.fromBufferGeometry(new Uw(t,n)),this.mergeVertices()}toJSON(){const t=Ot.prototype.toJSON.call(this),n=this.parameters.shapes;return Gw(n,t)}}function Gw(e,t){if(t.shapes=[],Array.isArray(e))for(let n=0,i=e.length;n<i;n++){const r=e[n];t.shapes.push(r.uuid)}else t.shapes.push(e.uuid);return t}function Gr(e){we.call(this),this.type="ShadowMaterial",this.color=new xe(0),this.transparent=!0,this.setValues(e)}Gr.prototype=Object.create(we.prototype);Gr.prototype.constructor=Gr;Gr.prototype.isShadowMaterial=!0;Gr.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.color.copy(e.color),this};function Zs(e){Dt.call(this,e),this.type="RawShaderMaterial"}Zs.prototype=Object.create(Dt.prototype);Zs.prototype.constructor=Zs;Zs.prototype.isRawShaderMaterial=!0;function Rt(e){we.call(this),this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new xe(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new xe(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.vertexTangents=!1,this.setValues(e)}Rt.prototype=Object.create(we.prototype);Rt.prototype.constructor=Rt;Rt.prototype.isMeshStandardMaterial=!0;Rt.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this.vertexTangents=e.vertexTangents,this};function Vn(e){Rt.call(this),this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoat=0,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new le(1,1),this.clearcoatNormalMap=null,this.reflectivity=.5,Object.defineProperty(this,"ior",{get:function(){return(1+.4*this.reflectivity)/(1-.4*this.reflectivity)},set:function(t){this.reflectivity=Ee.clamp(2.5*(t-1)/(t+1),0,1)}}),this.sheen=null,this.transmission=0,this.transmissionMap=null,this.setValues(e)}Vn.prototype=Object.create(Rt.prototype);Vn.prototype.constructor=Vn;Vn.prototype.isMeshPhysicalMaterial=!0;Vn.prototype.copy=function(e){return Rt.prototype.copy.call(this,e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.reflectivity=e.reflectivity,e.sheen?this.sheen=(this.sheen||new xe).copy(e.sheen):this.sheen=null,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this};function Xi(e){we.call(this),this.type="MeshPhongMaterial",this.color=new xe(16777215),this.specular=new xe(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new xe(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ka,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}Xi.prototype=Object.create(we.prototype);Xi.prototype.constructor=Xi;Xi.prototype.isMeshPhongMaterial=!0;Xi.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function Vr(e){we.call(this),this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new xe(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new xe(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}Vr.prototype=Object.create(we.prototype);Vr.prototype.constructor=Vr;Vr.prototype.isMeshToonMaterial=!0;Vr.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function Wr(e){we.call(this),this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}Wr.prototype=Object.create(we.prototype);Wr.prototype.constructor=Wr;Wr.prototype.isMeshNormalMaterial=!0;Wr.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function Yi(e){we.call(this),this.type="MeshLambertMaterial",this.color=new xe(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new xe(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ka,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}Yi.prototype=Object.create(we.prototype);Yi.prototype.constructor=Yi;Yi.prototype.isMeshLambertMaterial=!0;Yi.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function jr(e){we.call(this),this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new xe(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Zi,this.normalScale=new le(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.skinning=!1,this.morphTargets=!1,this.morphNormals=!1,this.setValues(e)}jr.prototype=Object.create(we.prototype);jr.prototype.constructor=jr;jr.prototype.isMeshMatcapMaterial=!0;jr.prototype.copy=function(e){return we.prototype.copy.call(this,e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.skinning=e.skinning,this.morphTargets=e.morphTargets,this.morphNormals=e.morphNormals,this};function qr(e){Tt.call(this),this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}qr.prototype=Object.create(Tt.prototype);qr.prototype.constructor=qr;qr.prototype.isLineDashedMaterial=!0;qr.prototype.copy=function(e){return Tt.prototype.copy.call(this,e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this};var Vw=Object.freeze({__proto__:null,ShadowMaterial:Gr,SpriteMaterial:qi,RawShaderMaterial:Zs,ShaderMaterial:Dt,PointsMaterial:Gn,MeshPhysicalMaterial:Vn,MeshStandardMaterial:Rt,MeshPhongMaterial:Xi,MeshToonMaterial:Vr,MeshNormalMaterial:Wr,MeshLambertMaterial:Yi,MeshDepthMaterial:Wi,MeshDistanceMaterial:ji,MeshBasicMaterial:Pt,MeshMatcapMaterial:jr,LineDashedMaterial:qr,LineBasicMaterial:Tt,Material:we});const Ye={arraySlice:function(e,t,n){return Ye.isTypedArray(e)?new e.constructor(e.subarray(t,n!==void 0?n:e.length)):e.slice(t,n)},convertArray:function(e,t,n){return!e||!n&&e.constructor===t?e:typeof t.BYTES_PER_ELEMENT=="number"?new t(e):Array.prototype.slice.call(e)},isTypedArray:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)},getKeyframeOrder:function(e){function t(r,s){return e[r]-e[s]}const n=e.length,i=new Array(n);for(let r=0;r!==n;++r)i[r]=r;return i.sort(t),i},sortedArray:function(e,t,n){const i=e.length,r=new e.constructor(i);for(let s=0,o=0;o!==i;++s){const a=n[s]*t;for(let l=0;l!==t;++l)r[o++]=e[a+l]}return r},flattenJSON:function(e,t,n,i){let r=1,s=e[0];for(;s!==void 0&&s[i]===void 0;)s=e[r++];if(s===void 0)return;let o=s[i];if(o!==void 0)if(Array.isArray(o))do o=s[i],o!==void 0&&(t.push(s.time),n.push.apply(n,o)),s=e[r++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[i],o!==void 0&&(t.push(s.time),o.toArray(n,n.length)),s=e[r++];while(s!==void 0);else do o=s[i],o!==void 0&&(t.push(s.time),n.push(o)),s=e[r++];while(s!==void 0)},subclip:function(e,t,n,i,r=30){const s=e.clone();s.name=t;const o=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],f=c.getValueSize(),u=[],d=[];for(let h=0;h<c.times.length;++h){const p=c.times[h]*r;if(!(p<n||p>=i)){u.push(c.times[h]);for(let v=0;v<f;++v)d.push(c.values[h*f+v])}}u.length!==0&&(c.times=Ye.convertArray(u,c.times.constructor),c.values=Ye.convertArray(d,c.values.constructor),o.push(c))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s},makeClipAdditive:function(e,t=0,n=e,i=30){i<=0&&(i=30);const r=n.tracks.length,s=t/i;for(let o=0;o<r;++o){const a=n.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=e.tracks.find(function(m){return m.name===a.name&&m.ValueTypeName===l});if(c===void 0)continue;let f=0;const u=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=u/3);let d=0;const h=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=h/3);const p=a.times.length-1;let v;if(s<=a.times[0]){const m=f,g=u-f;v=Ye.arraySlice(a.values,m,g)}else if(s>=a.times[p]){const m=p*u+f,g=m+u-f;v=Ye.arraySlice(a.values,m,g)}else{const m=a.createInterpolant(),g=f,T=u-f;m.evaluate(s),v=Ye.arraySlice(m.resultBuffer,g,T)}l==="quaternion"&&new Gt().fromArray(v).normalize().conjugate().toArray(v);const y=c.times.length;for(let m=0;m<y;++m){const g=m*h+d;if(l==="quaternion")Gt.multiplyQuaternionsFlat(c.values,g,v,0,c.values,g);else{const T=h-d*2;for(let P=0;P<T;++P)c.values[g+P]-=v[P]}}}return e.blendMode=jh,e}};function Nt(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n}Object.assign(Nt.prototype,{evaluate:function(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],r=t[n-1];e:{t:{let s;n:{i:if(!(e<i)){for(let o=n+2;;){if(i===void 0){if(e<r)break i;return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,e,r)}if(n===o)break;if(r=i,i=t[++n],e<i)break t}s=t.length;break n}if(!(e>=r)){const o=t[1];e<o&&(n=2,r=o);for(let a=n-2;;){if(r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(n===a)break;if(i=r,r=t[--n-1],e>=r)break t}s=n,n=0;break n}break e}for(;n<s;){const o=n+s>>>1;e<t[o]?s=o:n=o+1}if(i=t[n],r=t[n-1],r===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,i);if(i===void 0)return n=t.length,this._cachedIndex=n,this.afterEnd_(n-1,r,e)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,e,i)},settings:null,DefaultSettings_:{},getSettings_:function(){return this.settings||this.DefaultSettings_},copySampleValue_:function(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i;for(let s=0;s!==i;++s)t[s]=n[r+s];return t},interpolate_:function(){throw new Error("call to abstract method")},intervalChanged_:function(){}});Object.assign(Nt.prototype,{beforeStart_:Nt.prototype.copySampleValue_,afterEnd_:Nt.prototype.copySampleValue_});function wc(e,t,n,i){Nt.call(this,e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0}wc.prototype=Object.assign(Object.create(Nt.prototype),{constructor:wc,DefaultSettings_:{endingStart:_r,endingEnd:_r},intervalChanged_:function(e,t,n){const i=this.parameterPositions;let r=e-2,s=e+1,o=i[r],a=i[s];if(o===void 0)switch(this.getSettings_().endingStart){case br:r=e,o=2*t-n;break;case ha:r=i.length-2,o=t+i[r]-i[r+1];break;default:r=e,o=n}if(a===void 0)switch(this.getSettings_().endingEnd){case br:s=e,a=2*n-t;break;case ha:s=1,a=n+i[1]-i[0];break;default:s=e-1,a=t}const l=(n-t)*.5,c=this.valueSize;this._weightPrev=l/(t-o),this._weightNext=l/(a-n),this._offsetPrev=r*c,this._offsetNext=s*c},interpolate_:function(e,t,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=e*o,l=a-o,c=this._offsetPrev,f=this._offsetNext,u=this._weightPrev,d=this._weightNext,h=(n-t)/(i-t),p=h*h,v=p*h,y=-u*v+2*u*p-u*h,m=(1+u)*v+(-1.5-2*u)*p+(-.5+u)*h+1,g=(-1-d)*v+(1.5+d)*p+.5*h,T=d*v-d*p;for(let P=0;P!==o;++P)r[P]=y*s[c+P]+m*s[l+P]+g*s[a+P]+T*s[f+P];return r}});function ba(e,t,n,i){Nt.call(this,e,t,n,i)}ba.prototype=Object.assign(Object.create(Nt.prototype),{constructor:ba,interpolate_:function(e,t,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=e*o,l=a-o,c=(n-t)/(i-t),f=1-c;for(let u=0;u!==o;++u)r[u]=s[l+u]*f+s[a+u]*c;return r}});function Mc(e,t,n,i){Nt.call(this,e,t,n,i)}Mc.prototype=Object.assign(Object.create(Nt.prototype),{constructor:Mc,interpolate_:function(e){return this.copySampleValue_(e-1)}});function Mt(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Ye.convertArray(t,this.TimeBufferType),this.values=Ye.convertArray(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}Object.assign(Mt,{toJSON:function(e){const t=e.constructor;let n;if(t.toJSON!==void 0)n=t.toJSON(e);else{n={name:e.name,times:Ye.convertArray(e.times,Array),values:Ye.convertArray(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}});Object.assign(Mt.prototype,{constructor:Mt,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:Pr,InterpolantFactoryMethodDiscrete:function(e){return new Mc(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodLinear:function(e){return new ba(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:function(e){return new wc(this.times,this.values,this.getValueSize(),e)},setInterpolation:function(e){let t;switch(e){case zs:t=this.InterpolantFactoryMethodDiscrete;break;case Pr:t=this.InterpolantFactoryMethodLinear;break;case ol:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this},getInterpolation:function(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return zs;case this.InterpolantFactoryMethodLinear:return Pr;case this.InterpolantFactoryMethodSmooth:return ol}},getValueSize:function(){return this.values.length/this.times.length},shift:function(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this},scale:function(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this},trim:function(e,t){const n=this.times,i=n.length;let r=0,s=i-1;for(;r!==i&&n[r]<e;)++r;for(;s!==-1&&n[s]>t;)--s;if(++s,r!==0||s!==i){r>=s&&(s=Math.max(s,1),r=s-1);const o=this.getValueSize();this.times=Ye.arraySlice(n,r,s),this.values=Ye.arraySlice(this.values,r*o,s*o)}return this},validate:function(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,r=n.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let s=null;for(let o=0;o!==r;o++){const a=n[o];if(typeof a=="number"&&isNaN(a)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,a),e=!1;break}if(s!==null&&s>a){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,a,s),e=!1;break}s=a}if(i!==void 0&&Ye.isTypedArray(i))for(let o=0,a=i.length;o!==a;++o){const l=i[o];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,l),e=!1;break}}return e},optimize:function(){const e=Ye.arraySlice(this.times),t=Ye.arraySlice(this.values),n=this.getValueSize(),i=this.getInterpolation()===ol,r=e.length-1;let s=1;for(let o=1;o<r;++o){let a=!1;const l=e[o],c=e[o+1];if(l!==c&&(o!==1||l!==l[0]))if(i)a=!0;else{const f=o*n,u=f-n,d=f+n;for(let h=0;h!==n;++h){const p=t[f+h];if(p!==t[u+h]||p!==t[d+h]){a=!0;break}}}if(a){if(o!==s){e[s]=e[o];const f=o*n,u=s*n;for(let d=0;d!==n;++d)t[u+d]=t[f+d]}++s}}if(r>0){e[s]=e[r];for(let o=r*n,a=s*n,l=0;l!==n;++l)t[a+l]=t[o+l];++s}return s!==e.length?(this.times=Ye.arraySlice(e,0,s),this.values=Ye.arraySlice(t,0,s*n)):(this.times=e,this.values=t),this},clone:function(){const e=Ye.arraySlice(this.times,0),t=Ye.arraySlice(this.values,0),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}});function Sc(e,t,n){Mt.call(this,e,t,n)}Sc.prototype=Object.assign(Object.create(Mt.prototype),{constructor:Sc,ValueTypeName:"bool",ValueBufferType:Array,DefaultInterpolation:zs,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function Tc(e,t,n,i){Mt.call(this,e,t,n,i)}Tc.prototype=Object.assign(Object.create(Mt.prototype),{constructor:Tc,ValueTypeName:"color"});function Xr(e,t,n,i){Mt.call(this,e,t,n,i)}Xr.prototype=Object.assign(Object.create(Mt.prototype),{constructor:Xr,ValueTypeName:"number"});function Ec(e,t,n,i){Nt.call(this,e,t,n,i)}Ec.prototype=Object.assign(Object.create(Nt.prototype),{constructor:Ec,interpolate_:function(e,t,n,i){const r=this.resultBuffer,s=this.sampleValues,o=this.valueSize,a=(n-t)/(i-t);let l=e*o;for(let c=l+o;l!==c;l+=4)Gt.slerpFlat(r,0,s,l-o,s,l,a);return r}});function $s(e,t,n,i){Mt.call(this,e,t,n,i)}$s.prototype=Object.assign(Object.create(Mt.prototype),{constructor:$s,ValueTypeName:"quaternion",DefaultInterpolation:Pr,InterpolantFactoryMethodLinear:function(e){return new Ec(this.times,this.values,this.getValueSize(),e)},InterpolantFactoryMethodSmooth:void 0});function Ac(e,t,n,i){Mt.call(this,e,t,n,i)}Ac.prototype=Object.assign(Object.create(Mt.prototype),{constructor:Ac,ValueTypeName:"string",ValueBufferType:Array,DefaultInterpolation:zs,InterpolantFactoryMethodLinear:void 0,InterpolantFactoryMethodSmooth:void 0});function Yr(e,t,n,i){Mt.call(this,e,t,n,i)}Yr.prototype=Object.assign(Object.create(Mt.prototype),{constructor:Yr,ValueTypeName:"vector"});function Kt(e,t=-1,n,i=gu){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=Ee.generateUUID(),this.duration<0&&this.resetDuration()}function Ww(e){switch(e.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Xr;case"vector":case"vector2":case"vector3":case"vector4":return Yr;case"color":return Tc;case"quaternion":return $s;case"bool":case"boolean":return Sc;case"string":return Ac}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+e)}function jw(e){if(e.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const t=Ww(e.type);if(e.times===void 0){const n=[],i=[];Ye.flattenJSON(e.keys,n,i,"value"),e.times=n,e.values=i}return t.parse!==void 0?t.parse(e):new t(e.name,e.times,e.values,e.interpolation)}Object.assign(Kt,{parse:function(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let s=0,o=n.length;s!==o;++s)t.push(jw(n[s]).scale(i));const r=new Kt(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r},toJSON:function(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,s=n.length;r!==s;++r)t.push(Mt.toJSON(n[r]));return i},CreateFromMorphTargetSequence:function(e,t,n,i){const r=t.length,s=[];for(let o=0;o<r;o++){let a=[],l=[];a.push((o+r-1)%r,o,(o+1)%r),l.push(0,1,0);const c=Ye.getKeyframeOrder(a);a=Ye.sortedArray(a,1,c),l=Ye.sortedArray(l,1,c),!i&&a[0]===0&&(a.push(r),l.push(l[0])),s.push(new Xr(".morphTargetInfluences["+t[o].name+"]",a,l).scale(1/n))}return new Kt(e,-1,s)},findByName:function(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null},CreateClipsFromMorphTargetSequences:function(e,t,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,a=e.length;o<a;o++){const l=e[o],c=l.name.match(r);if(c&&c.length>1){const f=c[1];let u=i[f];u||(i[f]=u=[]),u.push(l)}}const s=[];for(const o in i)s.push(Kt.CreateFromMorphTargetSequence(o,i[o],t,n));return s},parseAnimation:function(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(f,u,d,h,p){if(d.length!==0){const v=[],y=[];Ye.flattenJSON(d,v,y,h),v.length!==0&&p.push(new f(u,v,y))}},i=[],r=e.name||"default",s=e.fps||30,o=e.blendMode;let a=e.length||-1;const l=e.hierarchy||[];for(let f=0;f<l.length;f++){const u=l[f].keys;if(!(!u||u.length===0))if(u[0].morphTargets){const d={};let h;for(h=0;h<u.length;h++)if(u[h].morphTargets)for(let p=0;p<u[h].morphTargets.length;p++)d[u[h].morphTargets[p]]=-1;for(const p in d){const v=[],y=[];for(let m=0;m!==u[h].morphTargets.length;++m){const g=u[h];v.push(g.time),y.push(g.morphTarget===p?1:0)}i.push(new Xr(".morphTargetInfluence["+p+"]",v,y))}a=d.length*(s||1)}else{const d=".bones["+t[f].name+"]";n(Yr,d+".position",u,"pos",i),n($s,d+".quaternion",u,"rot",i),n(Yr,d+".scale",u,"scl",i)}}return i.length===0?null:new Kt(r,a,i,o)}});Object.assign(Kt.prototype,{resetDuration:function(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const r=this.tracks[n];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this},trim:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this},validate:function(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e},optimize:function(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this},clone:function(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new Kt(this.name,this.duration,e,this.blendMode)},toJSON:function(){return Kt.toJSON(this)}});const Jr={enabled:!1,files:{},add:function(e,t){this.enabled!==!1&&(this.files[e]=t)},get:function(e){if(this.enabled!==!1)return this.files[e]},remove:function(e){delete this.files[e]},clear:function(){this.files={}}};function qw(e,t,n){const i=this;let r=!1,s=0,o=0,a;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(c){o++,r===!1&&i.onStart!==void 0&&i.onStart(c,s,o),r=!0},this.itemEnd=function(c){s++,i.onProgress!==void 0&&i.onProgress(c,s,o),s===o&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(c){i.onError!==void 0&&i.onError(c)},this.resolveURL=function(c){return a?a(c):c},this.setURLModifier=function(c){return a=c,this},this.addHandler=function(c,f){return l.push(c,f),this},this.removeHandler=function(c){const f=l.indexOf(c);return f!==-1&&l.splice(f,2),this},this.getHandler=function(c){for(let f=0,u=l.length;f<u;f+=2){const d=l[f],h=l[f+1];if(d.global&&(d.lastIndex=0),d.test(c))return h}return null}}const Xw=new qw;function He(e){this.manager=e!==void 0?e:Xw,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}Object.assign(He.prototype,{load:function(){},loadAsync:function(e,t){const n=this;return new Promise(function(i,r){n.load(e,i,t,r)})},parse:function(){},setCrossOrigin:function(e){return this.crossOrigin=e,this},setWithCredentials:function(e){return this.withCredentials=e,this},setPath:function(e){return this.path=e,this},setResourcePath:function(e){return this.resourcePath=e,this},setRequestHeader:function(e){return this.requestHeader=e,this}});const on={};function jt(e){He.call(this,e)}jt.prototype=Object.assign(Object.create(He.prototype),{constructor:jt,load:function(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,s=Jr.get(e);if(s!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(s),r.manager.itemEnd(e)},0),s;if(on[e]!==void 0){on[e].push({onLoad:t,onProgress:n,onError:i});return}const o=/^data:(.*?)(;base64)?,(.*)$/,a=e.match(o);let l;if(a){const c=a[1],f=!!a[2];let u=a[3];u=decodeURIComponent(u),f&&(u=atob(u));try{let d;const h=(this.responseType||"").toLowerCase();switch(h){case"arraybuffer":case"blob":const p=new Uint8Array(u.length);for(let y=0;y<u.length;y++)p[y]=u.charCodeAt(y);h==="blob"?d=new Blob([p.buffer],{type:c}):d=p.buffer;break;case"document":d=new DOMParser().parseFromString(u,c);break;case"json":d=JSON.parse(u);break;default:d=u;break}setTimeout(function(){t&&t(d),r.manager.itemEnd(e)},0)}catch(d){setTimeout(function(){i&&i(d),r.manager.itemError(e),r.manager.itemEnd(e)},0)}}else{on[e]=[],on[e].push({onLoad:t,onProgress:n,onError:i}),l=new XMLHttpRequest,l.open("GET",e,!0),l.addEventListener("load",function(c){const f=this.response,u=on[e];if(delete on[e],this.status===200||this.status===0){this.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),Jr.add(e,f);for(let d=0,h=u.length;d<h;d++){const p=u[d];p.onLoad&&p.onLoad(f)}r.manager.itemEnd(e)}else{for(let d=0,h=u.length;d<h;d++){const p=u[d];p.onError&&p.onError(c)}r.manager.itemError(e),r.manager.itemEnd(e)}},!1),l.addEventListener("progress",function(c){const f=on[e];for(let u=0,d=f.length;u<d;u++){const h=f[u];h.onProgress&&h.onProgress(c)}},!1),l.addEventListener("error",function(c){const f=on[e];delete on[e];for(let u=0,d=f.length;u<d;u++){const h=f[u];h.onError&&h.onError(c)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),l.addEventListener("abort",function(c){const f=on[e];delete on[e];for(let u=0,d=f.length;u<d;u++){const h=f[u];h.onError&&h.onError(c)}r.manager.itemError(e),r.manager.itemEnd(e)},!1),this.responseType!==void 0&&(l.responseType=this.responseType),this.withCredentials!==void 0&&(l.withCredentials=this.withCredentials),l.overrideMimeType&&l.overrideMimeType(this.mimeType!==void 0?this.mimeType:"text/plain");for(const c in this.requestHeader)l.setRequestHeader(c,this.requestHeader[c]);l.send(null)}return r.manager.itemStart(e),l},setResponseType:function(e){return this.responseType=e,this},setMimeType:function(e){return this.mimeType=e,this}});function fd(e){He.call(this,e)}fd.prototype=Object.assign(Object.create(He.prototype),{constructor:fd,load:function(e,t,n,i){const r=this,s=new jt(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(a){i?i(a):console.error(a),r.manager.itemError(e)}},n,i)},parse:function(e){const t=[];for(let n=0;n<e.length;n++){const i=Kt.parse(e[n]);t.push(i)}return t}});function dd(e){He.call(this,e)}dd.prototype=Object.assign(Object.create(He.prototype),{constructor:dd,load:function(e,t,n,i){const r=this,s=[],o=new js,a=new jt(this.manager);a.setPath(this.path),a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setWithCredentials(r.withCredentials);let l=0;function c(f){a.load(e[f],function(u){const d=r.parse(u,!0);s[f]={width:d.width,height:d.height,format:d.format,mipmaps:d.mipmaps},l+=1,l===6&&(d.mipmapCount===1&&(o.minFilter=ct),o.image=s,o.format=d.format,o.needsUpdate=!0,t&&t(o))},n,i)}if(Array.isArray(e))for(let f=0,u=e.length;f<u;++f)c(f);else a.load(e,function(f){const u=r.parse(f,!0);if(u.isCubemap){const d=u.mipmaps.length/u.mipmapCount;for(let h=0;h<d;h++){s[h]={mipmaps:[]};for(let p=0;p<u.mipmapCount;p++)s[h].mipmaps.push(u.mipmaps[h*u.mipmapCount+p]),s[h].format=u.format,s[h].width=u.width,s[h].height=u.height}o.image=s}else o.image.width=u.width,o.image.height=u.height,o.mipmaps=u.mipmaps;u.mipmapCount===1&&(o.minFilter=ct),o.format=u.format,o.needsUpdate=!0,t&&t(o)},n,i);return o}});function wa(e){He.call(this,e)}wa.prototype=Object.assign(Object.create(He.prototype),{constructor:wa,load:function(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,s=Jr.get(e);if(s!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(s),r.manager.itemEnd(e)},0),s;const o=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),Jr.add(e,this),t&&t(this),r.manager.itemEnd(e)}function l(c){o.removeEventListener("load",a,!1),o.removeEventListener("error",l,!1),i&&i(c),r.manager.itemError(e),r.manager.itemEnd(e)}return o.addEventListener("load",a,!1),o.addEventListener("error",l,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(e),o.src=e,o}});function Lc(e){He.call(this,e)}Lc.prototype=Object.assign(Object.create(He.prototype),{constructor:Lc,load:function(e,t,n,i){const r=new Ei,s=new wa(this.manager);s.setCrossOrigin(this.crossOrigin),s.setPath(this.path);let o=0;function a(l){s.load(e[l],function(c){r.images[l]=c,o++,o===6&&(r.needsUpdate=!0,t&&t(r))},void 0,i)}for(let l=0;l<e.length;++l)a(l);return r}});function hd(e){He.call(this,e)}hd.prototype=Object.assign(Object.create(He.prototype),{constructor:hd,load:function(e,t,n,i){const r=this,s=new Hr,o=new jt(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(e,function(a){const l=r.parse(a);!l||(l.image!==void 0?s.image=l.image:l.data!==void 0&&(s.image.width=l.width,s.image.height=l.height,s.image.data=l.data),s.wrapS=l.wrapS!==void 0?l.wrapS:Ct,s.wrapT=l.wrapT!==void 0?l.wrapT:Ct,s.magFilter=l.magFilter!==void 0?l.magFilter:ct,s.minFilter=l.minFilter!==void 0?l.minFilter:ct,s.anisotropy=l.anisotropy!==void 0?l.anisotropy:1,l.format!==void 0&&(s.format=l.format),l.type!==void 0&&(s.type=l.type),l.mipmaps!==void 0&&(s.mipmaps=l.mipmaps,s.minFilter=Br),l.mipmapCount===1&&(s.minFilter=ct),s.needsUpdate=!0,t&&t(s,l))},n,i),s}});function wi(e){He.call(this,e)}wi.prototype=Object.assign(Object.create(He.prototype),{constructor:wi,load:function(e,t,n,i){const r=new qe,s=new wa(this.manager);return s.setCrossOrigin(this.crossOrigin),s.setPath(this.path),s.load(e,function(o){r.image=o;const a=e.search(/\.jpe?g($|\?)/i)>0||e.search(/^data\:image\/jpeg/)===0;r.format=a?xi:pn,r.needsUpdate=!0,t!==void 0&&t(r)},n,i),r}});function _e(){this.type="Curve",this.arcLengthDivisions=200}Object.assign(_e.prototype,{getPoint:function(){return console.warn("THREE.Curve: .getPoint() not implemented."),null},getPointAt:function(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)},getPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t},getSpacedPoints:function(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t},getLength:function(){const e=this.getLengths();return e[e.length-1]},getLengths:function(e){if(e===void 0&&(e=this.arcLengthDivisions),this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),r=0;t.push(0);for(let s=1;s<=e;s++)n=this.getPoint(s/e),r+=n.distanceTo(i),t.push(r),i=n;return this.cacheArcLengths=t,t},updateArcLengths:function(){this.needsUpdate=!0,this.getLengths()},getUtoTmapping:function(e,t){const n=this.getLengths();let i=0;const r=n.length;let s;t?s=t:s=e*n[r-1];let o=0,a=r-1,l;for(;o<=a;)if(i=Math.floor(o+(a-o)/2),l=n[i]-s,l<0)o=i+1;else if(l>0)a=i-1;else{a=i;break}if(i=a,n[i]===s)return i/(r-1);const c=n[i],u=n[i+1]-c,d=(s-c)/u;return(i+d)/(r-1)},getTangent:function(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const s=this.getPoint(i),o=this.getPoint(r),a=t||(s.isVector2?new le:new z);return a.copy(o).sub(s).normalize(),a},getTangentAt:function(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)},computeFrenetFrames:function(e,t){const n=new z,i=[],r=[],s=[],o=new z,a=new Le;for(let d=0;d<=e;d++){const h=d/e;i[d]=this.getTangentAt(h,new z),i[d].normalize()}r[0]=new z,s[0]=new z;let l=Number.MAX_VALUE;const c=Math.abs(i[0].x),f=Math.abs(i[0].y),u=Math.abs(i[0].z);c<=l&&(l=c,n.set(1,0,0)),f<=l&&(l=f,n.set(0,1,0)),u<=l&&n.set(0,0,1),o.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],o),s[0].crossVectors(i[0],r[0]);for(let d=1;d<=e;d++){if(r[d]=r[d-1].clone(),s[d]=s[d-1].clone(),o.crossVectors(i[d-1],i[d]),o.length()>Number.EPSILON){o.normalize();const h=Math.acos(Ee.clamp(i[d-1].dot(i[d]),-1,1));r[d].applyMatrix4(a.makeRotationAxis(o,h))}s[d].crossVectors(i[d],r[d])}if(t===!0){let d=Math.acos(Ee.clamp(r[0].dot(r[e]),-1,1));d/=e,i[0].dot(o.crossVectors(r[0],r[e]))>0&&(d=-d);for(let h=1;h<=e;h++)r[h].applyMatrix4(a.makeRotationAxis(i[h],d*h)),s[h].crossVectors(i[h],r[h])}return{tangents:i,normals:r,binormals:s}},clone:function(){return new this.constructor().copy(this)},copy:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this},toJSON:function(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e},fromJSON:function(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}});function tn(e,t,n,i,r,s,o,a){_e.call(this),this.type="EllipseCurve",this.aX=e||0,this.aY=t||0,this.xRadius=n||1,this.yRadius=i||1,this.aStartAngle=r||0,this.aEndAngle=s||2*Math.PI,this.aClockwise=o||!1,this.aRotation=a||0}tn.prototype=Object.create(_e.prototype);tn.prototype.constructor=tn;tn.prototype.isEllipseCurve=!0;tn.prototype.getPoint=function(e,t){const n=t||new le,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const s=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(s?r=0:r=i),this.aClockwise===!0&&!s&&(r===i?r=-i:r=r-i);const o=this.aStartAngle+e*r;let a=this.aX+this.xRadius*Math.cos(o),l=this.aY+this.yRadius*Math.sin(o);if(this.aRotation!==0){const c=Math.cos(this.aRotation),f=Math.sin(this.aRotation),u=a-this.aX,d=l-this.aY;a=u*c-d*f+this.aX,l=u*f+d*c+this.aY}return n.set(a,l)};tn.prototype.copy=function(e){return _e.prototype.copy.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this};tn.prototype.toJSON=function(){const e=_e.prototype.toJSON.call(this);return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e};tn.prototype.fromJSON=function(e){return _e.prototype.fromJSON.call(this,e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this};function Ks(e,t,n,i,r,s){tn.call(this,e,t,n,n,i,r,s),this.type="ArcCurve"}Ks.prototype=Object.create(tn.prototype);Ks.prototype.constructor=Ks;Ks.prototype.isArcCurve=!0;function yu(){let e=0,t=0,n=0,i=0;function r(s,o,a,l){e=s,t=a,n=-3*s+3*o-2*a-l,i=2*s-2*o+a+l}return{initCatmullRom:function(s,o,a,l,c){r(o,a,c*(a-s),c*(l-o))},initNonuniformCatmullRom:function(s,o,a,l,c,f,u){let d=(o-s)/c-(a-s)/(c+f)+(a-o)/f,h=(a-o)/f-(l-o)/(f+u)+(l-a)/u;d*=f,h*=f,r(o,a,d,h)},calc:function(s){const o=s*s,a=o*s;return e+t*s+n*o+i*a}}}const Xo=new z,Il=new yu,Ol=new yu,Nl=new yu;function qt(e=[],t=!1,n="centripetal",i=.5){_e.call(this),this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}qt.prototype=Object.create(_e.prototype);qt.prototype.constructor=qt;qt.prototype.isCatmullRomCurve3=!0;qt.prototype.getPoint=function(e,t=new z){const n=t,i=this.points,r=i.length,s=(r-(this.closed?0:1))*e;let o=Math.floor(s),a=s-o;this.closed?o+=o>0?0:(Math.floor(Math.abs(o)/r)+1)*r:a===0&&o===r-1&&(o=r-2,a=1);let l,c;this.closed||o>0?l=i[(o-1)%r]:(Xo.subVectors(i[0],i[1]).add(i[0]),l=Xo);const f=i[o%r],u=i[(o+1)%r];if(this.closed||o+2<r?c=i[(o+2)%r]:(Xo.subVectors(i[r-1],i[r-2]).add(i[r-1]),c=Xo),this.curveType==="centripetal"||this.curveType==="chordal"){const d=this.curveType==="chordal"?.5:.25;let h=Math.pow(l.distanceToSquared(f),d),p=Math.pow(f.distanceToSquared(u),d),v=Math.pow(u.distanceToSquared(c),d);p<1e-4&&(p=1),h<1e-4&&(h=p),v<1e-4&&(v=p),Il.initNonuniformCatmullRom(l.x,f.x,u.x,c.x,h,p,v),Ol.initNonuniformCatmullRom(l.y,f.y,u.y,c.y,h,p,v),Nl.initNonuniformCatmullRom(l.z,f.z,u.z,c.z,h,p,v)}else this.curveType==="catmullrom"&&(Il.initCatmullRom(l.x,f.x,u.x,c.x,this.tension),Ol.initCatmullRom(l.y,f.y,u.y,c.y,this.tension),Nl.initCatmullRom(l.z,f.z,u.z,c.z,this.tension));return n.set(Il.calc(a),Ol.calc(a),Nl.calc(a)),n};qt.prototype.copy=function(e){_e.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this};qt.prototype.toJSON=function(){const e=_e.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e};qt.prototype.fromJSON=function(e){_e.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new z().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this};function pd(e,t,n,i,r){const s=(i-t)*.5,o=(r-n)*.5,a=e*e,l=e*a;return(2*n-2*i+s+o)*l+(-3*n+3*i-2*s-o)*a+s*e+n}function Yw(e,t){const n=1-e;return n*n*t}function Jw(e,t){return 2*(1-e)*e*t}function Zw(e,t){return e*e*t}function Ls(e,t,n,i){return Yw(e,t)+Jw(e,n)+Zw(e,i)}function $w(e,t){const n=1-e;return n*n*n*t}function Kw(e,t){const n=1-e;return 3*n*n*e*t}function Qw(e,t){return 3*(1-e)*e*e*t}function eM(e,t){return e*e*e*t}function Cs(e,t,n,i,r){return $w(e,t)+Kw(e,n)+Qw(e,i)+eM(e,r)}function En(e=new le,t=new le,n=new le,i=new le){_e.call(this),this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}En.prototype=Object.create(_e.prototype);En.prototype.constructor=En;En.prototype.isCubicBezierCurve=!0;En.prototype.getPoint=function(e,t=new le){const n=t,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(Cs(e,i.x,r.x,s.x,o.x),Cs(e,i.y,r.y,s.y,o.y)),n};En.prototype.copy=function(e){return _e.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this};En.prototype.toJSON=function(){const e=_e.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e};En.prototype.fromJSON=function(e){return _e.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this};function Wn(e=new z,t=new z,n=new z,i=new z){_e.call(this),this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}Wn.prototype=Object.create(_e.prototype);Wn.prototype.constructor=Wn;Wn.prototype.isCubicBezierCurve3=!0;Wn.prototype.getPoint=function(e,t=new z){const n=t,i=this.v0,r=this.v1,s=this.v2,o=this.v3;return n.set(Cs(e,i.x,r.x,s.x,o.x),Cs(e,i.y,r.y,s.y,o.y),Cs(e,i.z,r.z,s.z,o.z)),n};Wn.prototype.copy=function(e){return _e.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this};Wn.prototype.toJSON=function(){const e=_e.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e};Wn.prototype.fromJSON=function(e){return _e.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this};function Xt(e=new le,t=new le){_e.call(this),this.type="LineCurve",this.v1=e,this.v2=t}Xt.prototype=Object.create(_e.prototype);Xt.prototype.constructor=Xt;Xt.prototype.isLineCurve=!0;Xt.prototype.getPoint=function(e,t=new le){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n};Xt.prototype.getPointAt=function(e,t){return this.getPoint(e,t)};Xt.prototype.getTangent=function(e,t){const n=t||new le;return n.copy(this.v2).sub(this.v1).normalize(),n};Xt.prototype.copy=function(e){return _e.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this};Xt.prototype.toJSON=function(){const e=_e.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e};Xt.prototype.fromJSON=function(e){return _e.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this};function An(e=new z,t=new z){_e.call(this),this.type="LineCurve3",this.v1=e,this.v2=t}An.prototype=Object.create(_e.prototype);An.prototype.constructor=An;An.prototype.isLineCurve3=!0;An.prototype.getPoint=function(e,t=new z){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n};An.prototype.getPointAt=function(e,t){return this.getPoint(e,t)};An.prototype.copy=function(e){return _e.prototype.copy.call(this,e),this.v1.copy(e.v1),this.v2.copy(e.v2),this};An.prototype.toJSON=function(){const e=_e.prototype.toJSON.call(this);return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e};An.prototype.fromJSON=function(e){return _e.prototype.fromJSON.call(this,e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this};function Ln(e=new le,t=new le,n=new le){_e.call(this),this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}Ln.prototype=Object.create(_e.prototype);Ln.prototype.constructor=Ln;Ln.prototype.isQuadraticBezierCurve=!0;Ln.prototype.getPoint=function(e,t=new le){const n=t,i=this.v0,r=this.v1,s=this.v2;return n.set(Ls(e,i.x,r.x,s.x),Ls(e,i.y,r.y,s.y)),n};Ln.prototype.copy=function(e){return _e.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this};Ln.prototype.toJSON=function(){const e=_e.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e};Ln.prototype.fromJSON=function(e){return _e.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this};function jn(e=new z,t=new z,n=new z){_e.call(this),this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}jn.prototype=Object.create(_e.prototype);jn.prototype.constructor=jn;jn.prototype.isQuadraticBezierCurve3=!0;jn.prototype.getPoint=function(e,t=new z){const n=t,i=this.v0,r=this.v1,s=this.v2;return n.set(Ls(e,i.x,r.x,s.x),Ls(e,i.y,r.y,s.y),Ls(e,i.z,r.z,s.z)),n};jn.prototype.copy=function(e){return _e.prototype.copy.call(this,e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this};jn.prototype.toJSON=function(){const e=_e.prototype.toJSON.call(this);return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e};jn.prototype.fromJSON=function(e){return _e.prototype.fromJSON.call(this,e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this};function Cn(e=[]){_e.call(this),this.type="SplineCurve",this.points=e}Cn.prototype=Object.create(_e.prototype);Cn.prototype.constructor=Cn;Cn.prototype.isSplineCurve=!0;Cn.prototype.getPoint=function(e,t=new le){const n=t,i=this.points,r=(i.length-1)*e,s=Math.floor(r),o=r-s,a=i[s===0?s:s-1],l=i[s],c=i[s>i.length-2?i.length-1:s+1],f=i[s>i.length-3?i.length-1:s+2];return n.set(pd(o,a.x,l.x,c.x,f.x),pd(o,a.y,l.y,c.y,f.y)),n};Cn.prototype.copy=function(e){_e.prototype.copy.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this};Cn.prototype.toJSON=function(){const e=_e.prototype.toJSON.call(this);e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e};Cn.prototype.fromJSON=function(e){_e.prototype.fromJSON.call(this,e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new le().fromArray(i))}return this};var tM=Object.freeze({__proto__:null,ArcCurve:Ks,CatmullRomCurve3:qt,CubicBezierCurve:En,CubicBezierCurve3:Wn,EllipseCurve:tn,LineCurve:Xt,LineCurve3:An,QuadraticBezierCurve:Ln,QuadraticBezierCurve3:jn,SplineCurve:Cn});function hi(){_e.call(this),this.type="CurvePath",this.curves=[],this.autoClose=!1}hi.prototype=Object.assign(Object.create(_e.prototype),{constructor:hi,add:function(e){this.curves.push(e)},closePath:function(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Xt(t,e))},getPoint:function(e){const t=e*this.getLength(),n=this.getCurveLengths();let i=0;for(;i<n.length;){if(n[i]>=t){const r=n[i]-t,s=this.curves[i],o=s.getLength(),a=o===0?0:1-r/o;return s.getPointAt(a)}i++}return null},getLength:function(){const e=this.getCurveLengths();return e[e.length-1]},updateArcLengths:function(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()},getCurveLengths:function(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e},getSpacedPoints:function(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t},getPoints:function(e=12){const t=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const s=r[i],o=s&&s.isEllipseCurve?e*2:s&&(s.isLineCurve||s.isLineCurve3)?1:s&&s.isSplineCurve?e*s.points.length:e,a=s.getPoints(o);for(let l=0;l<a.length;l++){const c=a[l];n&&n.equals(c)||(t.push(c),n=c)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t},copy:function(e){_e.prototype.copy.call(this,e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this},toJSON:function(){const e=_e.prototype.toJSON.call(this);e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e},fromJSON:function(e){_e.prototype.fromJSON.call(this,e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new tM[i.type]().fromJSON(i))}return this}});function Mn(e){hi.call(this),this.type="Path",this.currentPoint=new le,e&&this.setFromPoints(e)}Mn.prototype=Object.assign(Object.create(hi.prototype),{constructor:Mn,setFromPoints:function(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this},moveTo:function(e,t){return this.currentPoint.set(e,t),this},lineTo:function(e,t){const n=new Xt(this.currentPoint.clone(),new le(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this},quadraticCurveTo:function(e,t,n,i){const r=new Ln(this.currentPoint.clone(),new le(e,t),new le(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this},bezierCurveTo:function(e,t,n,i,r,s){const o=new En(this.currentPoint.clone(),new le(e,t),new le(n,i),new le(r,s));return this.curves.push(o),this.currentPoint.set(r,s),this},splineThru:function(e){const t=[this.currentPoint.clone()].concat(e),n=new Cn(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this},arc:function(e,t,n,i,r,s){const o=this.currentPoint.x,a=this.currentPoint.y;return this.absarc(e+o,t+a,n,i,r,s),this},absarc:function(e,t,n,i,r,s){return this.absellipse(e,t,n,n,i,r,s),this},ellipse:function(e,t,n,i,r,s,o,a){const l=this.currentPoint.x,c=this.currentPoint.y;return this.absellipse(e+l,t+c,n,i,r,s,o,a),this},absellipse:function(e,t,n,i,r,s,o,a){const l=new tn(e,t,n,i,r,s,o,a);if(this.curves.length>0){const f=l.getPoint(0);f.equals(this.currentPoint)||this.lineTo(f.x,f.y)}this.curves.push(l);const c=l.getPoint(1);return this.currentPoint.copy(c),this},copy:function(e){return hi.prototype.copy.call(this,e),this.currentPoint.copy(e.currentPoint),this},toJSON:function(){const e=hi.prototype.toJSON.call(this);return e.currentPoint=this.currentPoint.toArray(),e},fromJSON:function(e){return hi.prototype.fromJSON.call(this,e),this.currentPoint.fromArray(e.currentPoint),this}});function Rr(e){Mn.call(this,e),this.uuid=Ee.generateUUID(),this.type="Shape",this.holes=[]}Rr.prototype=Object.assign(Object.create(Mn.prototype),{constructor:Rr,getPointsHoles:function(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t},extractPoints:function(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}},copy:function(e){Mn.prototype.copy.call(this,e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this},toJSON:function(){const e=Mn.prototype.toJSON.call(this);e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e},fromJSON:function(e){Mn.prototype.fromJSON.call(this,e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new Mn().fromJSON(i))}return this}});function Xe(e,t=1){be.call(this),this.type="Light",this.color=new xe(e),this.intensity=t}Xe.prototype=Object.assign(Object.create(be.prototype),{constructor:Xe,isLight:!0,copy:function(e){return be.prototype.copy.call(this,e),this.color.copy(e.color),this.intensity=e.intensity,this},toJSON:function(e){const t=be.prototype.toJSON.call(this,e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}});function md(e,t,n){Xe.call(this,e,n),this.type="HemisphereLight",this.position.copy(be.DefaultUp),this.updateMatrix(),this.groundColor=new xe(t)}md.prototype=Object.assign(Object.create(Xe.prototype),{constructor:md,isHemisphereLight:!0,copy:function(e){return Xe.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}});function qn(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.mapSize=new le(512,512),this.map=null,this.mapPass=null,this.matrix=new Le,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Va,this._frameExtents=new le(1,1),this._viewportCount=1,this._viewports=[new Ge(0,0,1,1)]}Object.assign(qn.prototype,{_projScreenMatrix:new Le,_lightPositionWorld:new z,_lookTarget:new z,getViewportCount:function(){return this._viewportCount},getFrustum:function(){return this._frustum},updateMatrices:function(e){const t=this.camera,n=this.matrix,i=this._projScreenMatrix,r=this._lookTarget,s=this._lightPositionWorld;s.setFromMatrixPosition(e.matrixWorld),t.position.copy(s),r.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(r),t.updateMatrixWorld(),i.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(i),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(t.projectionMatrix),n.multiply(t.matrixWorldInverse)},getViewport:function(e){return this._viewports[e]},getFrameExtents:function(){return this._frameExtents},copy:function(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}});function Cc(){qn.call(this,new lt(50,1,.5,500)),this.focus=1}Cc.prototype=Object.assign(Object.create(qn.prototype),{constructor:Cc,isSpotLightShadow:!0,updateMatrices:function(e){const t=this.camera,n=Ee.RAD2DEG*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(n!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=n,t.aspect=i,t.far=r,t.updateProjectionMatrix()),qn.prototype.updateMatrices.call(this,e)}});function Pc(e,t,n,i,r,s){Xe.call(this,e,t),this.type="SpotLight",this.position.copy(be.DefaultUp),this.updateMatrix(),this.target=new be,Object.defineProperty(this,"power",{get:function(){return this.intensity*Math.PI},set:function(o){this.intensity=o/Math.PI}}),this.distance=n!==void 0?n:0,this.angle=i!==void 0?i:Math.PI/3,this.penumbra=r!==void 0?r:0,this.decay=s!==void 0?s:1,this.shadow=new Cc}Pc.prototype=Object.assign(Object.create(Xe.prototype),{constructor:Pc,isSpotLight:!0,copy:function(e){return Xe.prototype.copy.call(this,e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}});function Rc(){qn.call(this,new lt(90,1,.5,500)),this._frameExtents=new le(4,2),this._viewportCount=6,this._viewports=[new Ge(2,1,1,1),new Ge(0,1,1,1),new Ge(3,1,1,1),new Ge(1,1,1,1),new Ge(3,0,1,1),new Ge(1,0,1,1)],this._cubeDirections=[new z(1,0,0),new z(-1,0,0),new z(0,0,1),new z(0,0,-1),new z(0,1,0),new z(0,-1,0)],this._cubeUps=[new z(0,1,0),new z(0,1,0),new z(0,1,0),new z(0,1,0),new z(0,0,1),new z(0,0,-1)]}Rc.prototype=Object.assign(Object.create(qn.prototype),{constructor:Rc,isPointLightShadow:!0,updateMatrices:function(e,t=0){const n=this.camera,i=this.matrix,r=this._lightPositionWorld,s=this._lookTarget,o=this._projScreenMatrix;r.setFromMatrixPosition(e.matrixWorld),n.position.copy(r),s.copy(n.position),s.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(s),n.updateMatrixWorld(),i.makeTranslation(-r.x,-r.y,-r.z),o.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(o)}});function Ic(e,t,n,i){Xe.call(this,e,t),this.type="PointLight",Object.defineProperty(this,"power",{get:function(){return this.intensity*4*Math.PI},set:function(r){this.intensity=r/(4*Math.PI)}}),this.distance=n!==void 0?n:0,this.decay=i!==void 0?i:1,this.shadow=new Rc}Ic.prototype=Object.assign(Object.create(Xe.prototype),{constructor:Ic,isPointLight:!0,copy:function(e){return Xe.prototype.copy.call(this,e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}});function Qs(e=-1,t=1,n=1,i=-1,r=.1,s=2e3){Ti.call(this),this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=r,this.far=s,this.updateProjectionMatrix()}Qs.prototype=Object.assign(Object.create(Ti.prototype),{constructor:Qs,isOrthographicCamera:!0,copy:function(e,t){return Ti.prototype.copy.call(this,e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this},setViewOffset:function(e,t,n,i,r,s){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=s,this.updateProjectionMatrix()},clearViewOffset:function(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()},updateProjectionMatrix:function(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-e,s=n+e,o=i+t,a=i-t;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,c=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=l*this.view.offsetX,s=r+l*this.view.width,o-=c*this.view.offsetY,a=o-c*this.view.height}this.projectionMatrix.makeOrthographic(r,s,o,a,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()},toJSON:function(e){const t=be.prototype.toJSON.call(this,e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}});function Oc(){qn.call(this,new Qs(-5,5,5,-5,.5,500))}Oc.prototype=Object.assign(Object.create(qn.prototype),{constructor:Oc,isDirectionalLightShadow:!0,updateMatrices:function(e){qn.prototype.updateMatrices.call(this,e)}});function Ma(e,t){Xe.call(this,e,t),this.type="DirectionalLight",this.position.copy(be.DefaultUp),this.updateMatrix(),this.target=new be,this.shadow=new Oc}Ma.prototype=Object.assign(Object.create(Xe.prototype),{constructor:Ma,isDirectionalLight:!0,copy:function(e){return Xe.prototype.copy.call(this,e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}});function Nc(e,t){Xe.call(this,e,t),this.type="AmbientLight"}Nc.prototype=Object.assign(Object.create(Xe.prototype),{constructor:Nc,isAmbientLight:!0});function gd(e,t,n,i){Xe.call(this,e,t),this.type="RectAreaLight",this.width=n!==void 0?n:10,this.height=i!==void 0?i:10}gd.prototype=Object.assign(Object.create(Xe.prototype),{constructor:gd,isRectAreaLight:!0,copy:function(e){return Xe.prototype.copy.call(this,e),this.width=e.width,this.height=e.height,this},toJSON:function(e){const t=Xe.prototype.toJSON.call(this,e);return t.object.width=this.width,t.object.height=this.height,t}});class nM{constructor(){Object.defineProperty(this,"isSphericalHarmonics3",{value:!0}),this.coefficients=[];for(let t=0;t<9;t++)this.coefficients.push(new z)}set(t){for(let n=0;n<9;n++)this.coefficients[n].copy(t[n]);return this}zero(){for(let t=0;t<9;t++)this.coefficients[t].set(0,0,0);return this}getAt(t,n){const i=t.x,r=t.y,s=t.z,o=this.coefficients;return n.copy(o[0]).multiplyScalar(.282095),n.addScaledVector(o[1],.488603*r),n.addScaledVector(o[2],.488603*s),n.addScaledVector(o[3],.488603*i),n.addScaledVector(o[4],1.092548*(i*r)),n.addScaledVector(o[5],1.092548*(r*s)),n.addScaledVector(o[6],.315392*(3*s*s-1)),n.addScaledVector(o[7],1.092548*(i*s)),n.addScaledVector(o[8],.546274*(i*i-r*r)),n}getIrradianceAt(t,n){const i=t.x,r=t.y,s=t.z,o=this.coefficients;return n.copy(o[0]).multiplyScalar(.886227),n.addScaledVector(o[1],2*.511664*r),n.addScaledVector(o[2],2*.511664*s),n.addScaledVector(o[3],2*.511664*i),n.addScaledVector(o[4],2*.429043*i*r),n.addScaledVector(o[5],2*.429043*r*s),n.addScaledVector(o[6],.743125*s*s-.247708),n.addScaledVector(o[7],2*.429043*i*s),n.addScaledVector(o[8],.429043*(i*i-r*r)),n}add(t){for(let n=0;n<9;n++)this.coefficients[n].add(t.coefficients[n]);return this}addScaledSH(t,n){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(t.coefficients[i],n);return this}scale(t){for(let n=0;n<9;n++)this.coefficients[n].multiplyScalar(t);return this}lerp(t,n){for(let i=0;i<9;i++)this.coefficients[i].lerp(t.coefficients[i],n);return this}equals(t){for(let n=0;n<9;n++)if(!this.coefficients[n].equals(t.coefficients[n]))return!1;return!0}copy(t){return this.set(t.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(t,n=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].fromArray(t,n+r*3);return this}toArray(t=[],n=0){const i=this.coefficients;for(let r=0;r<9;r++)i[r].toArray(t,n+r*3);return t}static getBasisAt(t,n){const i=t.x,r=t.y,s=t.z;n[0]=.282095,n[1]=.488603*r,n[2]=.488603*s,n[3]=.488603*i,n[4]=1.092548*i*r,n[5]=1.092548*r*s,n[6]=.315392*(3*s*s-1),n[7]=1.092548*i*s,n[8]=.546274*(i*i-r*r)}}function Tn(e,t){Xe.call(this,void 0,t),this.type="LightProbe",this.sh=e!==void 0?e:new nM}Tn.prototype=Object.assign(Object.create(Xe.prototype),{constructor:Tn,isLightProbe:!0,copy:function(e){return Xe.prototype.copy.call(this,e),this.sh.copy(e.sh),this},fromJSON:function(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this},toJSON:function(e){const t=Xe.prototype.toJSON.call(this,e);return t.object.sh=this.sh.toArray(),t}});function vd(e){He.call(this,e),this.textures={}}vd.prototype=Object.assign(Object.create(He.prototype),{constructor:vd,load:function(e,t,n,i){const r=this,s=new jt(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(a){i?i(a):console.error(a),r.manager.itemError(e)}},n,i)},parse:function(e){const t=this.textures;function n(r){return t[r]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",r),t[r]}const i=new Vw[e.type];if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=new xe().setHex(e.sheen)),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==1&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.skinning!==void 0&&(i.skinning=e.skinning),e.morphTargets!==void 0&&(i.morphTargets=e.morphTargets),e.morphNormals!==void 0&&(i.morphNormals=e.morphNormals),e.dithering!==void 0&&(i.dithering=e.dithering),e.vertexTangents!==void 0&&(i.vertexTangents=e.vertexTangents),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const r in e.uniforms){const s=e.uniforms[r];switch(i.uniforms[r]={},s.type){case"t":i.uniforms[r].value=n(s.value);break;case"c":i.uniforms[r].value=new xe().setHex(s.value);break;case"v2":i.uniforms[r].value=new le().fromArray(s.value);break;case"v3":i.uniforms[r].value=new z().fromArray(s.value);break;case"v4":i.uniforms[r].value=new Ge().fromArray(s.value);break;case"m3":i.uniforms[r].value=new It().fromArray(s.value);break;case"m4":i.uniforms[r].value=new Le().fromArray(s.value);break;default:i.uniforms[r].value=s.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.extensions!==void 0)for(const r in e.extensions)i.extensions[r]=e.extensions[r];if(e.shading!==void 0&&(i.flatShading=e.shading===1),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=n(e.map)),e.matcap!==void 0&&(i.matcap=n(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=n(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=n(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=n(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let r=e.normalScale;Array.isArray(r)===!1&&(r=[r,r]),i.normalScale=new le().fromArray(r)}return e.displacementMap!==void 0&&(i.displacementMap=n(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=n(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=n(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=n(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=n(e.specularMap)),e.envMap!==void 0&&(i.envMap=n(e.envMap)),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=n(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=n(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=n(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=n(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=n(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=n(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new le().fromArray(e.clearcoatNormalScale)),e.transmission!==void 0&&(i.transmission=e.transmission),e.transmissionMap!==void 0&&(i.transmissionMap=n(e.transmissionMap)),i},setTextures:function(e){return this.textures=e,this}});const yr={decodeText:function(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}},extractUrlBase:function(e){const t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}};function Sa(){Be.call(this),this.type="InstancedBufferGeometry",this.instanceCount=1/0}Sa.prototype=Object.assign(Object.create(Be.prototype),{constructor:Sa,isInstancedBufferGeometry:!0,copy:function(e){return Be.prototype.copy.call(this,e),this.instanceCount=e.instanceCount,this},clone:function(){return new this.constructor().copy(this)},toJSON:function(){const e=Be.prototype.toJSON.call(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}});function Dc(e,t,n,i){typeof n=="number"&&(i=n,n=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),Se.call(this,e,t,n),this.meshPerAttribute=i||1}Dc.prototype=Object.assign(Object.create(Se.prototype),{constructor:Dc,isInstancedBufferAttribute:!0,copy:function(e){return Se.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},toJSON:function(){const e=Se.prototype.toJSON.call(this);return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}});function yd(e){He.call(this,e)}yd.prototype=Object.assign(Object.create(He.prototype),{constructor:yd,load:function(e,t,n,i){const r=this,s=new jt(r.manager);s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,function(o){try{t(r.parse(JSON.parse(o)))}catch(a){i?i(a):console.error(a),r.manager.itemError(e)}},n,i)},parse:function(e){const t={},n={};function i(d,h){if(t[h]!==void 0)return t[h];const v=d.interleavedBuffers[h],y=r(d,v.buffer),m=Eo(v.type,y),g=new kt(m,v.stride);return g.uuid=v.uuid,t[h]=g,g}function r(d,h){if(n[h]!==void 0)return n[h];const v=d.arrayBuffers[h],y=new Uint32Array(v).buffer;return n[h]=y,y}const s=e.isInstancedBufferGeometry?new Sa:new Be,o=e.data.index;if(o!==void 0){const d=Eo(o.type,o.array);s.setIndex(new Se(d,1))}const a=e.data.attributes;for(const d in a){const h=a[d];let p;if(h.isInterleavedBufferAttribute){const v=i(e.data,h.data);p=new Ai(v,h.itemSize,h.offset,h.normalized)}else{const v=Eo(h.type,h.array),y=h.isInstancedBufferAttribute?Dc:Se;p=new y(v,h.itemSize,h.normalized)}h.name!==void 0&&(p.name=h.name),s.setAttribute(d,p)}const l=e.data.morphAttributes;if(l)for(const d in l){const h=l[d],p=[];for(let v=0,y=h.length;v<y;v++){const m=h[v];let g;if(m.isInterleavedBufferAttribute){const T=i(e.data,m.data);g=new Ai(T,m.itemSize,m.offset,m.normalized)}else{const T=Eo(m.type,m.array);g=new Se(T,m.itemSize,m.normalized)}m.name!==void 0&&(g.name=m.name),p.push(g)}s.morphAttributes[d]=p}e.data.morphTargetsRelative&&(s.morphTargetsRelative=!0);const f=e.data.groups||e.data.drawcalls||e.data.offsets;if(f!==void 0)for(let d=0,h=f.length;d!==h;++d){const p=f[d];s.addGroup(p.start,p.count,p.materialIndex)}const u=e.data.boundingSphere;if(u!==void 0){const d=new z;u.center!==void 0&&d.fromArray(u.center),s.boundingSphere=new Zn(d,u.radius)}return e.name&&(s.name=e.name),e.userData&&(s.userData=e.userData),s}});function Fc(e){typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),He.call(this,e),this.options={premultiplyAlpha:"none"}}Fc.prototype=Object.assign(Object.create(He.prototype),{constructor:Fc,isImageBitmapLoader:!0,setOptions:function(t){return this.options=t,this},load:function(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,s=Jr.get(e);if(s!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(s),r.manager.itemEnd(e)},0),s;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",fetch(e,o).then(function(a){return a.blob()}).then(function(a){return createImageBitmap(a,r.options)}).then(function(a){Jr.add(e,a),t&&t(a),r.manager.itemEnd(e)}).catch(function(a){i&&i(a),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}});function hp(){this.type="ShapePath",this.color=new xe,this.subPaths=[],this.currentPath=null}Object.assign(hp.prototype,{moveTo:function(e,t){return this.currentPath=new Mn,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this},lineTo:function(e,t){return this.currentPath.lineTo(e,t),this},quadraticCurveTo:function(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this},bezierCurveTo:function(e,t,n,i,r,s){return this.currentPath.bezierCurveTo(e,t,n,i,r,s),this},splineThru:function(e){return this.currentPath.splineThru(e),this},toShapes:function(e,t){function n(m){const g=[];for(let T=0,P=m.length;T<P;T++){const A=m[T],M=new Rr;M.curves=A.curves,g.push(M)}return g}function i(m,g){const T=g.length;let P=!1;for(let A=T-1,M=0;M<T;A=M++){let N=g[A],B=g[M],W=B.x-N.x,te=B.y-N.y;if(Math.abs(te)>Number.EPSILON){if(te<0&&(N=g[M],W=-W,B=g[A],te=-te),m.y<N.y||m.y>B.y)continue;if(m.y===N.y){if(m.x===N.x)return!0}else{const H=te*(m.x-N.x)-W*(m.y-N.y);if(H===0)return!0;if(H<0)continue;P=!P}}else{if(m.y!==N.y)continue;if(B.x<=m.x&&m.x<=N.x||N.x<=m.x&&m.x<=B.x)return!0}}return P}const r=bi.isClockWise,s=this.subPaths;if(s.length===0)return[];if(t===!0)return n(s);let o,a,l;const c=[];if(s.length===1)return a=s[0],l=new Rr,l.curves=a.curves,c.push(l),c;let f=!r(s[0].getPoints());f=e?!f:f;const u=[],d=[];let h=[],p=0,v;d[p]=void 0,h[p]=[];for(let m=0,g=s.length;m<g;m++)a=s[m],v=a.getPoints(),o=r(v),o=e?!o:o,o?(!f&&d[p]&&p++,d[p]={s:new Rr,p:v},d[p].s.curves=a.curves,f&&p++,h[p]=[]):h[p].push({h:a,p:v[0]});if(!d[0])return n(s);if(d.length>1){let m=!1;const g=[];for(let T=0,P=d.length;T<P;T++)u[T]=[];for(let T=0,P=d.length;T<P;T++){const A=h[T];for(let M=0;M<A.length;M++){const N=A[M];let B=!0;for(let W=0;W<d.length;W++)i(N.p,d[W].p)&&(T!==W&&g.push({froms:T,tos:W,hole:M}),B?(B=!1,u[W].push(N)):m=!0);B&&u[T].push(N)}}g.length>0&&(m||(h=u))}let y;for(let m=0,g=d.length;m<g;m++){l=d[m].s,c.push(l),y=h[m];for(let T=0,P=y.length;T<P;T++)l.holes.push(y[T].h)}return c}});function pp(e){this.type="Font",this.data=e}Object.assign(pp.prototype,{isFont:!0,generateShapes:function(e,t=100){const n=[],i=iM(e,t,this.data);for(let r=0,s=i.length;r<s;r++)Array.prototype.push.apply(n,i[r].toShapes());return n}});function iM(e,t,n){const i=Array.from?Array.from(e):String(e).split(""),r=t/n.resolution,s=(n.boundingBox.yMax-n.boundingBox.yMin+n.underlineThickness)*r,o=[];let a=0,l=0;for(let c=0;c<i.length;c++){const f=i[c];if(f===`
`)a=0,l-=s;else{const u=rM(f,r,a,l,n);a+=u.offsetX,o.push(u.path)}}return o}function rM(e,t,n,i,r){const s=r.glyphs[e]||r.glyphs["?"];if(!s){console.error('THREE.Font: character "'+e+'" does not exists in font family '+r.familyName+".");return}const o=new hp;let a,l,c,f,u,d,h,p;if(s.o){const v=s._cachedOutline||(s._cachedOutline=s.o.split(" "));for(let y=0,m=v.length;y<m;)switch(v[y++]){case"m":a=v[y++]*t+n,l=v[y++]*t+i,o.moveTo(a,l);break;case"l":a=v[y++]*t+n,l=v[y++]*t+i,o.lineTo(a,l);break;case"q":c=v[y++]*t+n,f=v[y++]*t+i,u=v[y++]*t+n,d=v[y++]*t+i,o.quadraticCurveTo(u,d,c,f);break;case"b":c=v[y++]*t+n,f=v[y++]*t+i,u=v[y++]*t+n,d=v[y++]*t+i,h=v[y++]*t+n,p=v[y++]*t+i,o.bezierCurveTo(u,d,h,p,c,f);break}}return{offsetX:s.ha*t,path:o}}function xd(e){He.call(this,e)}xd.prototype=Object.assign(Object.create(He.prototype),{constructor:xd,load:function(e,t,n,i){const r=this,s=new jt(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,function(o){let a;try{a=JSON.parse(o)}catch{console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),a=JSON.parse(o.substring(65,o.length-2))}const l=r.parse(a);t&&t(l)},n,i)},parse:function(e){return new pp(e)}});let Yo;const sM={getContext:function(){return Yo===void 0&&(Yo=new(window.AudioContext||window.webkitAudioContext)),Yo},setContext:function(e){Yo=e}};function _d(e){He.call(this,e)}_d.prototype=Object.assign(Object.create(He.prototype),{constructor:_d,load:function(e,t,n,i){const r=this,s=new jt(r.manager);s.setResponseType("arraybuffer"),s.setPath(r.path),s.setRequestHeader(r.requestHeader),s.setWithCredentials(r.withCredentials),s.load(e,function(o){try{const a=o.slice(0);sM.getContext().decodeAudioData(a,function(c){t(c)})}catch(a){i?i(a):console.error(a),r.manager.itemError(e)}},n,i)}});function bd(e,t,n){Tn.call(this,void 0,n);const i=new xe().set(e),r=new xe().set(t),s=new z(i.r,i.g,i.b),o=new z(r.r,r.g,r.b),a=Math.sqrt(Math.PI),l=a*Math.sqrt(.75);this.sh.coefficients[0].copy(s).add(o).multiplyScalar(a),this.sh.coefficients[1].copy(s).sub(o).multiplyScalar(l)}bd.prototype=Object.assign(Object.create(Tn.prototype),{constructor:bd,isHemisphereLightProbe:!0,copy:function(e){return Tn.prototype.copy.call(this,e),this},toJSON:function(e){return Tn.prototype.toJSON.call(this,e)}});function wd(e,t){Tn.call(this,void 0,t);const n=new xe().set(e);this.sh.coefficients[0].set(n.r,n.g,n.b).multiplyScalar(2*Math.sqrt(Math.PI))}wd.prototype=Object.assign(Object.create(Tn.prototype),{constructor:wd,isAmbientLightProbe:!0,copy:function(e){return Tn.prototype.copy.call(this,e),this},toJSON:function(e){return Tn.prototype.toJSON.call(this,e)}});const Md=new Le,Sd=new Le;function oM(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new lt,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new lt,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}Object.assign(oM.prototype,{update:function(e){const t=this._cache;if(t.focus!==e.focus||t.fov!==e.fov||t.aspect!==e.aspect*this.aspect||t.near!==e.near||t.far!==e.far||t.zoom!==e.zoom||t.eyeSep!==this.eyeSep){t.focus=e.focus,t.fov=e.fov,t.aspect=e.aspect*this.aspect,t.near=e.near,t.far=e.far,t.zoom=e.zoom,t.eyeSep=this.eyeSep;const i=e.projectionMatrix.clone(),r=t.eyeSep/2,s=r*t.near/t.focus,o=t.near*Math.tan(Ee.DEG2RAD*t.fov*.5)/t.zoom;let a,l;Sd.elements[12]=-r,Md.elements[12]=r,a=-o*t.aspect+s,l=o*t.aspect+s,i.elements[0]=2*t.near/(l-a),i.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(i),a=-o*t.aspect-s,l=o*t.aspect-s,i.elements[0]=2*t.near/(l-a),i.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(i)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(Sd),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(Md)}});function mp(e,t,n){this.binding=e,this.valueSize=n;let i,r,s;switch(t){case"quaternion":i=this._slerp,r=this._slerpAdditive,s=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(n*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,s=this._setAdditiveIdentityOther,this.buffer=new Array(n*5);break;default:i=this._lerp,r=this._lerpAdditive,s=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(n*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=s,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}Object.assign(mp.prototype,{accumulate:function(e,t){const n=this.buffer,i=this.valueSize,r=e*i+i;let s=this.cumulativeWeight;if(s===0){for(let o=0;o!==i;++o)n[r+o]=n[o];s=t}else{s+=t;const o=t/s;this._mixBufferRegion(n,r,0,o,i)}this.cumulativeWeight=s},accumulateAdditive:function(e){const t=this.buffer,n=this.valueSize,i=n*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,n),this.cumulativeWeightAdditive+=e},apply:function(e){const t=this.valueSize,n=this.buffer,i=e*t+t,r=this.cumulativeWeight,s=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const a=t*this._origIndex;this._mixBufferRegion(n,i,a,1-r,t)}s>0&&this._mixBufferRegionAdditive(n,i,this._addIndex*t,1,t);for(let a=t,l=t+t;a!==l;++a)if(n[a]!==n[a+t]){o.setValue(n,i);break}},saveOriginalState:function(){const e=this.binding,t=this.buffer,n=this.valueSize,i=n*this._origIndex;e.getValue(t,i);for(let r=n,s=i;r!==s;++r)t[r]=t[i+r%n];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0},restoreOriginalState:function(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)},_setAdditiveIdentityNumeric:function(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let n=e;n<t;n++)this.buffer[n]=0},_setAdditiveIdentityQuaternion:function(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1},_setAdditiveIdentityOther:function(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let n=0;n<this.valueSize;n++)this.buffer[t+n]=this.buffer[e+n]},_select:function(e,t,n,i,r){if(i>=.5)for(let s=0;s!==r;++s)e[t+s]=e[n+s]},_slerp:function(e,t,n,i){Gt.slerpFlat(e,t,e,t,e,n,i)},_slerpAdditive:function(e,t,n,i,r){const s=this._workIndex*r;Gt.multiplyQuaternionsFlat(e,s,e,t,e,n),Gt.slerpFlat(e,t,e,t,e,s,i)},_lerp:function(e,t,n,i,r){const s=1-i;for(let o=0;o!==r;++o){const a=t+o;e[a]=e[a]*s+e[n+o]*i}},_lerpAdditive:function(e,t,n,i,r){for(let s=0;s!==r;++s){const o=t+s;e[o]=e[o]+e[n+s]*i}}});const xu="\\[\\]\\.:\\/",aM=new RegExp("["+xu+"]","g"),_u="[^"+xu+"]",lM="[^"+xu.replace("\\.","")+"]",cM=/((?:WC+[\/:])*)/.source.replace("WC",_u),uM=/(WCOD+)?/.source.replace("WCOD",lM),fM=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",_u),dM=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",_u),hM=new RegExp("^"+cM+uM+fM+dM+"$"),pM=["material","materials","bones"];function gp(e,t,n){const i=n||bt.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}Object.assign(gp.prototype,{getValue:function(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)},setValue:function(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(e,t)},bind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()},unbind:function(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}});function bt(e,t,n){this.path=t,this.parsedPath=n||bt.parseTrackName(t),this.node=bt.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e}Object.assign(bt,{Composite:gp,create:function(e,t,n){return e&&e.isAnimationObjectGroup?new bt.Composite(e,t,n):new bt(e,t,n)},sanitizeNodeName:function(e){return e.replace(/\s/g,"_").replace(aM,"")},parseTrackName:function(e){const t=hM.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=n.nodeName.substring(i+1);pM.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n},findNode:function(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(r){for(let s=0;s<r.length;s++){const o=r[s];if(o.name===t||o.uuid===t)return o;const a=n(o.children);if(a)return a}return null},i=n(e.children);if(i)return i}return null}});Object.assign(bt.prototype,{_getValue_unavailable:function(){},_setValue_unavailable:function(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function(t,n){t[n]=this.node[this.propertyName]},function(t,n){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)t[n++]=i[r]},function(t,n){t[n]=this.resolvedProperty[this.propertyIndex]},function(t,n){this.resolvedProperty.toArray(t,n)}],SetterByBindingTypeAndVersioning:[[function(t,n){this.targetObject[this.propertyName]=t[n]},function(t,n){this.targetObject[this.propertyName]=t[n],this.targetObject.needsUpdate=!0},function(t,n){this.targetObject[this.propertyName]=t[n],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,n){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=t[n++]},function(t,n){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=t[n++];this.targetObject.needsUpdate=!0},function(t,n){const i=this.resolvedProperty;for(let r=0,s=i.length;r!==s;++r)i[r]=t[n++];this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,n){this.resolvedProperty[this.propertyIndex]=t[n]},function(t,n){this.resolvedProperty[this.propertyIndex]=t[n],this.targetObject.needsUpdate=!0},function(t,n){this.resolvedProperty[this.propertyIndex]=t[n],this.targetObject.matrixWorldNeedsUpdate=!0}],[function(t,n){this.resolvedProperty.fromArray(t,n)},function(t,n){this.resolvedProperty.fromArray(t,n),this.targetObject.needsUpdate=!0},function(t,n){this.resolvedProperty.fromArray(t,n),this.targetObject.matrixWorldNeedsUpdate=!0}]],getValue:function(t,n){this.bind(),this.getValue(t,n)},setValue:function(t,n){this.bind(),this.setValue(t,n)},bind:function(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=bt.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(n){let l=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let c=0;c<e.length;c++)if(e[c].name===l){l=c;break}break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(l!==void 0){if(e[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[l]}}const s=e[i];if(s===void 0){const l=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let a=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}a=this.BindingType.ArrayElement,this.resolvedProperty=s,this.propertyIndex=r}else s.fromArray!==void 0&&s.toArray!==void 0?(a=this.BindingType.HasFromToArray,this.resolvedProperty=s):Array.isArray(s)?(a=this.BindingType.EntireArray,this.resolvedProperty=s):this.propertyName=i;this.getValue=this.GetterByBindingType[a],this.setValue=this.SetterByBindingTypeAndVersioning[a][o]},unbind:function(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}});Object.assign(bt.prototype,{_getValue_unbound:bt.prototype.getValue,_setValue_unbound:bt.prototype.setValue});function mM(){this.uuid=Ee.generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let n=0,i=arguments.length;n!==i;++n)e[arguments[n].uuid]=n;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const t=this;this.stats={objects:{get total(){return t._objects.length},get inUse(){return this.total-t.nCachedObjects_}},get bindingsPerObject(){return t._bindings.length}}}Object.assign(mM.prototype,{isAnimationObjectGroup:!0,add:function(){const e=this._objects,t=this._indicesByUUID,n=this._paths,i=this._parsedPaths,r=this._bindings,s=r.length;let o,a=e.length,l=this.nCachedObjects_;for(let c=0,f=arguments.length;c!==f;++c){const u=arguments[c],d=u.uuid;let h=t[d];if(h===void 0){h=a++,t[d]=h,e.push(u);for(let p=0,v=s;p!==v;++p)r[p].push(new bt(u,n[p],i[p]))}else if(h<l){o=e[h];const p=--l,v=e[p];t[v.uuid]=h,e[h]=v,t[d]=p,e[p]=u;for(let y=0,m=s;y!==m;++y){const g=r[y],T=g[p];let P=g[h];g[h]=T,P===void 0&&(P=new bt(u,n[y],i[y])),g[p]=P}}else e[h]!==o&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=l},remove:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_;for(let s=0,o=arguments.length;s!==o;++s){const a=arguments[s],l=a.uuid,c=t[l];if(c!==void 0&&c>=r){const f=r++,u=e[f];t[u.uuid]=c,e[c]=u,t[l]=f,e[f]=a;for(let d=0,h=i;d!==h;++d){const p=n[d],v=p[f],y=p[c];p[c]=v,p[f]=y}}}this.nCachedObjects_=r},uncache:function(){const e=this._objects,t=this._indicesByUUID,n=this._bindings,i=n.length;let r=this.nCachedObjects_,s=e.length;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,f=t[c];if(f!==void 0)if(delete t[c],f<r){const u=--r,d=e[u],h=--s,p=e[h];t[d.uuid]=f,e[f]=d,t[p.uuid]=u,e[u]=p,e.pop();for(let v=0,y=i;v!==y;++v){const m=n[v],g=m[u],T=m[h];m[f]=g,m[u]=T,m.pop()}}else{const u=--s,d=e[u];u>0&&(t[d.uuid]=f),e[f]=d,e.pop();for(let h=0,p=i;h!==p;++h){const v=n[h];v[f]=v[u],v.pop()}}}this.nCachedObjects_=r},subscribe_:function(e,t){const n=this._bindingsIndicesByPath;let i=n[e];const r=this._bindings;if(i!==void 0)return r[i];const s=this._paths,o=this._parsedPaths,a=this._objects,l=a.length,c=this.nCachedObjects_,f=new Array(l);i=r.length,n[e]=i,s.push(e),o.push(t),r.push(f);for(let u=c,d=a.length;u!==d;++u){const h=a[u];f[u]=new bt(h,e,t)}return f},unsubscribe_:function(e){const t=this._bindingsIndicesByPath,n=t[e];if(n!==void 0){const i=this._paths,r=this._parsedPaths,s=this._bindings,o=s.length-1,a=s[o],l=e[o];t[l]=n,s[n]=a,s.pop(),r[n]=r[o],r.pop(),i[n]=i[o],i.pop()}}});class gM{constructor(t,n,i=null,r=n.blendMode){this._mixer=t,this._clip=n,this._localRoot=i,this.blendMode=r;const s=n.tracks,o=s.length,a=new Array(o),l={endingStart:_r,endingEnd:_r};for(let c=0;c!==o;++c){const f=s[c].createInterpolant(null);a[c]=f,f.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=Fy,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(t){return this._startTime=t,this}setLoop(t,n){return this.loop=t,this.repetitions=n,this}setEffectiveWeight(t){return this.weight=t,this._effectiveWeight=this.enabled?t:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(t){return this._scheduleFading(t,0,1)}fadeOut(t){return this._scheduleFading(t,1,0)}crossFadeFrom(t,n,i){if(t.fadeOut(n),this.fadeIn(n),i){const r=this._clip.duration,s=t._clip.duration,o=s/r,a=r/s;t.warp(1,o,n),this.warp(a,1,n)}return this}crossFadeTo(t,n,i){return t.crossFadeFrom(this,n,i)}stopFading(){const t=this._weightInterpolant;return t!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}setEffectiveTimeScale(t){return this.timeScale=t,this._effectiveTimeScale=this.paused?0:t,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(t){return this.timeScale=this._clip.duration/t,this.stopWarping()}syncWith(t){return this.time=t.time,this.timeScale=t.timeScale,this.stopWarping()}halt(t){return this.warp(this._effectiveTimeScale,0,t)}warp(t,n,i){const r=this._mixer,s=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=s,l[1]=s+i,c[0]=t/o,c[1]=n/o,this}stopWarping(){const t=this._timeScaleInterpolant;return t!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(t)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(t,n,i,r){if(!this.enabled){this._updateWeight(t);return}const s=this._startTime;if(s!==null){const l=(t-s)*i;if(l<0||i===0)return;this._startTime=null,n=i*l}n*=this._updateTimeScale(t);const o=this._updateTime(n),a=this._updateWeight(t);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case jh:for(let f=0,u=l.length;f!==u;++f)l[f].evaluate(o),c[f].accumulateAdditive(a);break;case gu:default:for(let f=0,u=l.length;f!==u;++f)l[f].evaluate(o),c[f].accumulate(r,a)}}}_updateWeight(t){let n=0;if(this.enabled){n=this.weight;const i=this._weightInterpolant;if(i!==null){const r=i.evaluate(t)[0];n*=r,t>i.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=n,n}_updateTimeScale(t){let n=0;if(!this.paused){n=this.timeScale;const i=this._timeScaleInterpolant;if(i!==null){const r=i.evaluate(t)[0];n*=r,t>i.parameterPositions[1]&&(this.stopWarping(),n===0?this.paused=!0:this.timeScale=n)}}return this._effectiveTimeScale=n,n}_updateTime(t){const n=this._clip.duration,i=this.loop;let r=this.time+t,s=this._loopCount;const o=i===By;if(t===0)return s===-1?r:o&&(s&1)===1?n-r:r;if(i===Dy){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=n)r=n;else if(r<0)r=0;else{this.time=r;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t<0?-1:1})}}else{if(s===-1&&(t>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=n||r<0){const a=Math.floor(r/n);r-=n*a,s+=Math.abs(a);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=t>0?n:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:t>0?1:-1});else{if(l===1){const c=t<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(s&1)===1)return n-r}return r}_setEndings(t,n,i){const r=this._interpolantSettings;i?(r.endingStart=br,r.endingEnd=br):(t?r.endingStart=this.zeroSlopeAtStart?br:_r:r.endingStart=ha,n?r.endingEnd=this.zeroSlopeAtEnd?br:_r:r.endingEnd=ha)}_scheduleFading(t,n,i){const r=this._mixer,s=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=s,l[0]=n,a[1]=s+t,l[1]=i,this}}function Bc(e){this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}Bc.prototype=Object.assign(Object.create(Yn.prototype),{constructor:Bc,_bindAction:function(e,t){const n=e._localRoot||this._root,i=e._clip.tracks,r=i.length,s=e._propertyBindings,o=e._interpolants,a=n.uuid,l=this._bindingsByRootAndName;let c=l[a];c===void 0&&(c={},l[a]=c);for(let f=0;f!==r;++f){const u=i[f],d=u.name;let h=c[d];if(h!==void 0)s[f]=h;else{if(h=s[f],h!==void 0){h._cacheIndex===null&&(++h.referenceCount,this._addInactiveBinding(h,a,d));continue}const p=t&&t._propertyBindings[f].binding.parsedPath;h=new mp(bt.create(n,d,p),u.ValueTypeName,u.getValueSize()),++h.referenceCount,this._addInactiveBinding(h,a,d),s[f]=h}o[f].resultBuffer=h.buffer}},_activateAction:function(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const n=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,n)}const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}},_deactivateAction:function(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}},_initMemoryManager:function(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}},_isActiveAction:function(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions},_addInactiveAction:function(e,t,n){const i=this._actions,r=this._actionsByClip;let s=r[t];if(s===void 0)s={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=s;else{const o=s.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=i.length,i.push(e),s.actionByRoot[n]=e},_removeInactiveAction:function(e){const t=this._actions,n=t[t.length-1],i=e._cacheIndex;n._cacheIndex=i,t[i]=n,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,s=this._actionsByClip,o=s[r],a=o.knownActions,l=a[a.length-1],c=e._byClipCacheIndex;l._byClipCacheIndex=c,a[c]=l,a.pop(),e._byClipCacheIndex=null;const f=o.actionByRoot,u=(e._localRoot||this._root).uuid;delete f[u],a.length===0&&delete s[r],this._removeInactiveBindingsForAction(e)},_removeInactiveBindingsForAction:function(e){const t=e._propertyBindings;for(let n=0,i=t.length;n!==i;++n){const r=t[n];--r.referenceCount===0&&this._removeInactiveBinding(r)}},_lendAction:function(e){const t=this._actions,n=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r},_takeBackAction:function(e){const t=this._actions,n=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r},_addInactiveBinding:function(e,t,n){const i=this._bindingsByRootAndName,r=this._bindings;let s=i[t];s===void 0&&(s={},i[t]=s),s[n]=e,e._cacheIndex=r.length,r.push(e)},_removeInactiveBinding:function(e){const t=this._bindings,n=e.binding,i=n.rootNode.uuid,r=n.path,s=this._bindingsByRootAndName,o=s[i],a=t[t.length-1],l=e._cacheIndex;a._cacheIndex=l,t[l]=a,t.pop(),delete o[r],Object.keys(o).length===0&&delete s[i]},_lendBinding:function(e){const t=this._bindings,n=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r},_takeBackBinding:function(e){const t=this._bindings,n=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=n,t[n]=r},_lendControlInterpolant:function(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let n=e[t];return n===void 0&&(n=new ba(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),n.__cacheIndex=t,e[t]=n),n},_takeBackControlInterpolant:function(e){const t=this._controlInterpolants,n=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=n,t[n]=r},_controlInterpolantsResultBuffer:new Float32Array(1),clipAction:function(e,t,n){const i=t||this._root,r=i.uuid;let s=typeof e=="string"?Kt.findByName(i,e):e;const o=s!==null?s.uuid:e,a=this._actionsByClip[o];let l=null;if(n===void 0&&(s!==null?n=s.blendMode:n=gu),a!==void 0){const f=a.actionByRoot[r];if(f!==void 0&&f.blendMode===n)return f;l=a.knownActions[0],s===null&&(s=l._clip)}if(s===null)return null;const c=new gM(this,s,t,n);return this._bindAction(c,l),this._addInactiveAction(c,o,r),c},existingAction:function(e,t){const n=t||this._root,i=n.uuid,r=typeof e=="string"?Kt.findByName(n,e):e,s=r?r.uuid:e,o=this._actionsByClip[s];return o!==void 0&&o.actionByRoot[i]||null},stopAllAction:function(){const e=this._actions,t=this._nActiveActions;for(let n=t-1;n>=0;--n)e[n].stop();return this},update:function(e){e*=this.timeScale;const t=this._actions,n=this._nActiveActions,i=this.time+=e,r=Math.sign(e),s=this._accuIndex^=1;for(let l=0;l!==n;++l)t[l]._update(i,e,r,s);const o=this._bindings,a=this._nActiveBindings;for(let l=0;l!==a;++l)o[l].apply(s);return this},setTime:function(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)},getRoot:function(){return this._root},uncacheClip:function(e){const t=this._actions,n=e.uuid,i=this._actionsByClip,r=i[n];if(r!==void 0){const s=r.knownActions;for(let o=0,a=s.length;o!==a;++o){const l=s[o];this._deactivateAction(l);const c=l._cacheIndex,f=t[t.length-1];l._cacheIndex=null,l._byClipCacheIndex=null,f._cacheIndex=c,t[c]=f,t.pop(),this._removeInactiveBindingsForAction(l)}delete i[n]}},uncacheRoot:function(e){const t=e.uuid,n=this._actionsByClip;for(const s in n){const o=n[s].actionByRoot,a=o[t];a!==void 0&&(this._deactivateAction(a),this._removeInactiveAction(a))}const i=this._bindingsByRootAndName,r=i[t];if(r!==void 0)for(const s in r){const o=r[s];o.restoreOriginalState(),this._removeInactiveBinding(o)}},uncacheAction:function(e,t){const n=this.existingAction(e,t);n!==null&&(this._deactivateAction(n),this._removeInactiveAction(n))}});function Td(e,t,n){kt.call(this,e,t),this.meshPerAttribute=n||1}Td.prototype=Object.assign(Object.create(kt.prototype),{constructor:Td,isInstancedInterleavedBuffer:!0,copy:function(e){return kt.prototype.copy.call(this,e),this.meshPerAttribute=e.meshPerAttribute,this},clone:function(e){const t=kt.prototype.clone.call(this,e);return t.meshPerAttribute=this.meshPerAttribute,t},toJSON:function(e){const t=kt.prototype.toJSON.call(this,e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}});function vp(e,t,n,i,r){this.buffer=e,this.type=t,this.itemSize=n,this.elementSize=i,this.count=r,this.version=0}Object.defineProperty(vp.prototype,"needsUpdate",{set:function(e){e===!0&&this.version++}});Object.assign(vp.prototype,{isGLBufferAttribute:!0,setBuffer:function(e){return this.buffer=e,this},setType:function(e,t){return this.type=e,this.elementSize=t,this},setItemSize:function(e){return this.itemSize=e,this},setCount:function(e){return this.count=e,this}});function yp(e,t,n,i){this.ray=new so(e,t),this.near=n||0,this.far=i||1/0,this.camera=null,this.layers=new qh,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}},Object.defineProperties(this.params,{PointCloud:{get:function(){return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),this.Points}}})}function Ed(e,t){return e.distance-t.distance}function zc(e,t,n,i){if(e.layers.test(t.layers)&&e.raycast(t,n),i===!0){const r=e.children;for(let s=0,o=r.length;s<o;s++)zc(r[s],t,n,!0)}}Object.assign(yp.prototype,{set:function(e,t){this.ray.set(e,t)},setFromCamera:function(e,t){t&&t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t&&t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)},intersectObject:function(e,t,n){const i=n||[];return zc(e,this,i,t),i.sort(Ed),i},intersectObjects:function(e,t,n){const i=n||[];if(Array.isArray(e)===!1)return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),i;for(let r=0,s=e.length;r<s;r++)zc(e[r],this,i,t);return i.sort(Ed),i}});const Ad=new le;class vM{constructor(t,n){Object.defineProperty(this,"isBox2",{value:!0}),this.min=t!==void 0?t:new le(1/0,1/0),this.max=n!==void 0?n:new le(-1/0,-1/0)}set(t,n){return this.min.copy(t),this.max.copy(n),this}setFromPoints(t){this.makeEmpty();for(let n=0,i=t.length;n<i;n++)this.expandByPoint(t[n]);return this}setFromCenterAndSize(t,n){const i=Ad.copy(n).multiplyScalar(.5);return this.min.copy(t).sub(i),this.max.copy(t).add(i),this}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(t){return t===void 0&&(console.warn("THREE.Box2: .getCenter() target is now required"),t=new le),this.isEmpty()?t.set(0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return t===void 0&&(console.warn("THREE.Box2: .getSize() target is now required"),t=new le),this.isEmpty()?t.set(0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y}getParameter(t,n){return n===void 0&&(console.warn("THREE.Box2: .getParameter() target is now required"),n=new le),n.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y)}clampPoint(t,n){return n===void 0&&(console.warn("THREE.Box2: .clampPoint() target is now required"),n=new le),n.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return Ad.copy(t).clamp(this.min,this.max).sub(t).length()}intersect(t){return this.min.max(t.min),this.max.min(t.max),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}function Ta(e){be.call(this),this.material=e,this.render=function(){},this.hasPositions=!1,this.hasNormals=!1,this.hasColors=!1,this.hasUvs=!1,this.positionArray=null,this.normalArray=null,this.colorArray=null,this.uvArray=null,this.count=0}Ta.prototype=Object.create(be.prototype);Ta.prototype.constructor=Ta;Ta.prototype.isImmediateRenderObject=!0;const li=new z,Jo=new Le,Dl=new Le;class yM extends kr{constructor(t){const n=xp(t),i=new Be,r=[],s=[],o=new xe(0,0,1),a=new xe(0,1,0);for(let c=0;c<n.length;c++){const f=n[c];f.parent&&f.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}i.setAttribute("position",new Ie(r,3)),i.setAttribute("color",new Ie(s,3));const l=new Tt({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(i,l),this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=t,this.bones=n,this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(t){const n=this.bones,i=this.geometry,r=i.getAttribute("position");Dl.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<n.length;s++){const a=n[s];a.parent&&a.parent.isBone&&(Jo.multiplyMatrices(Dl,a.matrixWorld),li.setFromMatrixPosition(Jo),r.setXYZ(o,li.x,li.y,li.z),Jo.multiplyMatrices(Dl,a.parent.matrixWorld),li.setFromMatrixPosition(Jo),r.setXYZ(o+1,li.x,li.y,li.z),o+=2)}i.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(t)}}function xp(e){const t=[];e&&e.isBone&&t.push(e);for(let n=0;n<e.children.length;n++)t.push.apply(t,xp(e.children[n]));return t}class xM extends kr{constructor(t=10,n=10,i=4473924,r=8947848){i=new xe(i),r=new xe(r);const s=n/2,o=t/n,a=t/2,l=[],c=[];for(let d=0,h=0,p=-a;d<=n;d++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const v=d===s?i:r;v.toArray(c,h),h+=3,v.toArray(c,h),h+=3,v.toArray(c,h),h+=3,v.toArray(c,h),h+=3}const f=new Be;f.setAttribute("position",new Ie(l,3)),f.setAttribute("color",new Ie(c,3));const u=new Tt({vertexColors:!0,toneMapped:!1});super(f,u),this.type="GridHelper"}}const Ld=new z,Zo=new z,Cd=new z;class _M extends be{constructor(t,n,i){super(),this.light=t,this.light.updateMatrixWorld(),this.matrix=t.matrixWorld,this.matrixAutoUpdate=!1,this.color=i,n===void 0&&(n=1);let r=new Be;r.setAttribute("position",new Ie([-n,n,0,n,n,0,n,-n,0,-n,-n,0,-n,n,0],3));const s=new Tt({fog:!1,toneMapped:!1});this.lightPlane=new kn(r,s),this.add(this.lightPlane),r=new Be,r.setAttribute("position",new Ie([0,0,0,0,0,1],3)),this.targetLine=new kn(r,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){Ld.setFromMatrixPosition(this.light.matrixWorld),Zo.setFromMatrixPosition(this.light.target.matrixWorld),Cd.subVectors(Zo,Ld),this.lightPlane.lookAt(Zo),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(Zo),this.targetLine.scale.z=Cd.length()}}class bM extends kr{constructor(t=1){const n=[0,0,0,t,0,0,0,0,0,0,t,0,0,0,0,0,0,t],i=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],r=new Be;r.setAttribute("position",new Ie(n,3)),r.setAttribute("color",new Ie(i,3));const s=new Tt({vertexColors:!0,toneMapped:!1});super(r,s),this.type="AxesHelper"}}const wM=new Float32Array(1);new Int32Array(wM.buffer);_e.create=function(e,t){return console.log("THREE.Curve.create() has been deprecated"),e.prototype=Object.create(_e.prototype),e.prototype.constructor=e,e.prototype.getPoint=t,e};Object.assign(hi.prototype,{createPointsGeometry:function(e){console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getPoints(e);return this.createGeometry(t)},createSpacedPointsGeometry:function(e){console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=this.getSpacedPoints(e);return this.createGeometry(t)},createGeometry:function(e){console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");const t=new Ot;for(let n=0,i=e.length;n<i;n++){const r=e[n];t.vertices.push(new z(r.x,r.y,r.z||0))}return t}});Object.assign(Mn.prototype,{fromPoints:function(e){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(e)}});Object.create(qt.prototype);Object.create(qt.prototype);function _p(e){console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."),qt.call(this,e),this.type="catmullrom"}_p.prototype=Object.create(qt.prototype);Object.assign(_p.prototype,{initFromArray:function(){console.error("THREE.Spline: .initFromArray() has been removed.")},getControlPointsArray:function(){console.error("THREE.Spline: .getControlPointsArray() has been removed.")},reparametrizeByArcLength:function(){console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")}});xM.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};yM.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Object.assign(He.prototype,{extractUrlBase:function(e){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),yr.extractUrlBase(e)}});He.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};Object.assign(vM.prototype,{center:function(e){return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},size:function(e){return console.warn("THREE.Box2: .size() has been renamed to .getSize()."),this.getSize(e)}});Object.assign(Jn.prototype,{center:function(e){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(e)},empty:function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()},isIntersectionBox:function(e){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionSphere:function(e){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)},size:function(e){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(e)}});Object.assign(Zn.prototype,{empty:function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()}});Va.prototype.setFromMatrix=function(e){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(e)};Object.assign(Ee,{random16:function(){return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."),Math.random()},nearestPowerOfTwo:function(e){return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."),Ee.floorPowerOfTwo(e)},nextPowerOfTwo:function(e){return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."),Ee.ceilPowerOfTwo(e)}});Object.assign(It.prototype,{flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},multiplyVector3:function(e){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},multiplyVector3Array:function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),e.applyMatrix3(this)},applyToVector3Array:function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")},getInverse:function(e){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()}});Object.assign(Le.prototype,{extractPosition:function(e){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(e)},flattenToArrayOffset:function(e,t){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(e,t)},getPosition:function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new z().setFromMatrixColumn(this,3)},setRotationFromQuaternion:function(e){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(e)},multiplyToArray:function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")},multiplyVector3:function(e){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector4:function(e){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},multiplyVector3Array:function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")},rotateAxis:function(e){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),e.transformDirection(this)},crossVector:function(e){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},translate:function(){console.error("THREE.Matrix4: .translate() has been removed.")},rotateX:function(){console.error("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(){console.error("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")},applyToBufferAttribute:function(e){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),e.applyMatrix4(this)},applyToVector3Array:function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")},makeFrustum:function(e,t,n,i,r,s){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(e,t,i,n,r,s)},getInverse:function(e){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(e).invert()}});Bn.prototype.isIntersectionLine=function(e){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(e)};Object.assign(Gt.prototype,{multiplyVector3:function(e){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),e.applyQuaternion(this)},inverse:function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()}});Object.assign(so.prototype,{isIntersectionBox:function(e){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(e)},isIntersectionPlane:function(e){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(e)},isIntersectionSphere:function(e){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(e)}});Object.assign(_t.prototype,{area:function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()},barycoordFromPoint:function(e,t){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(e,t)},midpoint:function(e){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(e)},normal:function(e){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(e)},plane:function(e){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(e)}});Object.assign(_t,{barycoordFromPoint:function(e,t,n,i,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),_t.getBarycoord(e,t,n,i,r)},normal:function(e,t,n,i){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),_t.getNormal(e,t,n,i)}});Object.assign(Rr.prototype,{extractAllPoints:function(e){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(e)},extrude:function(e){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Fw(this,e)},makeGeometry:function(e){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new kw(this,e)}});Object.assign(le.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(z.prototype,{setEulerFromRotationMatrix:function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},setEulerFromQuaternion:function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(e){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(e)},getScaleFromMatrix:function(e){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(e)},getColumnFromMatrix:function(e,t){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(t,e)},applyProjection:function(e){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(e)},fromAttribute:function(e,t,n){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},distanceToManhattan:function(e){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(e)},lengthManhattan:function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(Ge.prototype,{fromAttribute:function(e,t,n){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(e,t,n)},lengthManhattan:function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()}});Object.assign(Ot.prototype,{computeTangents:function(){console.error("THREE.Geometry: .computeTangents() has been removed.")},computeLineDistances:function(){console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")},applyMatrix:function(e){return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}});Object.assign(be.prototype,{getChildByName:function(e){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(e)},renderDepth:function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")},translate:function(e,t){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(t,e)},getWorldRotation:function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")},applyMatrix:function(e){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}});Object.defineProperties(be.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(e){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=e}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});Object.assign(rt.prototype,{setDrawMode:function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}});Object.defineProperties(rt.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),zy},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Object.defineProperties(gc.prototype,{objects:{get:function(){return console.warn("THREE.LOD: .objects has been renamed to .levels."),this.levels}}});Object.defineProperty(va.prototype,"useVertexTexture",{get:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")},set:function(){console.warn("THREE.Skeleton: useVertexTexture has been removed.")}});ma.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Object.defineProperty(_e.prototype,"__arcLengthDivisions",{get:function(){return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions},set:function(e){console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."),this.arcLengthDivisions=e}});lt.prototype.setLens=function(e,t){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),t!==void 0&&(this.filmGauge=t),this.setFocalLength(e)};Object.defineProperties(Xe.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(e){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=e}},shadowCameraLeft:{set:function(e){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=e}},shadowCameraRight:{set:function(e){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=e}},shadowCameraTop:{set:function(e){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=e}},shadowCameraBottom:{set:function(e){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=e}},shadowCameraNear:{set:function(e){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=e}},shadowCameraFar:{set:function(e){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=e}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(e){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=e}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(e){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=e}},shadowMapHeight:{set:function(e){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=e}}});Object.defineProperties(Se.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Hs},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Hs)}}});Object.assign(Se.prototype,{setDynamic:function(e){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(e===!0?Hs:Ga),this},copyIndicesArray:function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},setArray:function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(Be.prototype,{addIndex:function(e){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(e)},addAttribute:function(e,t){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(t&&t.isBufferAttribute)&&!(t&&t.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(e,new Se(arguments[1],arguments[2]))):e==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(t),this):this.setAttribute(e,t)},addDrawCall:function(e,t,n){n!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(e,t)},clearDrawCalls:function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()},computeTangents:function(){console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")},computeOffsets:function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")},removeAttribute:function(e){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(e)},applyMatrix:function(e){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(e)}});Object.defineProperties(Be.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});Object.defineProperties(Sa.prototype,{maxInstancedCount:{get:function(){return console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount},set:function(e){console.warn("THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount."),this.instanceCount=e}}});Object.defineProperties(yp.prototype,{linePrecision:{get:function(){return console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold},set:function(e){console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead."),this.params.Line.threshold=e}}});Object.defineProperties(kt.prototype,{dynamic:{get:function(){return console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.usage===Hs},set:function(e){console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead."),this.setUsage(e)}}});Object.assign(kt.prototype,{setDynamic:function(e){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(e===!0?Hs:Ga),this},setArray:function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")}});Object.assign(dp.prototype,{getArrays:function(){console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")},addShapeList:function(){console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")},addShape:function(){console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")}});Object.assign(ap.prototype,{dispose:function(){console.error("THREE.Scene: .dispose() has been removed.")}});Object.defineProperties(we.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new xe}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(e){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=e===Hh}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(e){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=e}}});Object.defineProperties(Xi.prototype,{metal:{get:function(){return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),!1},set:function(){console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")}}});Object.defineProperties(Vn.prototype,{transparency:{get:function(){return console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission},set:function(e){console.warn("THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission."),this.transmission=e}}});Object.defineProperties(Dt.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(e){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=e}}});Object.assign(ao.prototype,{clearTarget:function(e,t,n,i){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(e),this.clear(t,n,i)},animate:function(e){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(e)},getCurrentRenderTarget:function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()},getMaxAnisotropy:function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()},getPrecision:function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision},resetGLState:function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()},supportsFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")},supportsHalfFloatTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")},supportsStandardDerivatives:function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")},supportsCompressedTextureS3TC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")},supportsCompressedTexturePVRTC:function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")},supportsBlendMinMax:function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")},supportsVertexTextures:function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures},supportsInstancedArrays:function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")},enableScissorTest:function(e){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(e)},initMaterial:function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")},addPrePlugin:function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")},addPostPlugin:function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")},updateShadowMap:function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")},setFaceCulling:function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")},allocTextureUnit:function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")},setTexture:function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")},setTexture2D:function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")},setTextureCube:function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")},getActiveMipMapLevel:function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()}});Object.defineProperties(ao.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=e}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(e){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=e}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(e){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=e===!0?Us:ro}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(sp.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(mn.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=e}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(e){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=e}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=e}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(e){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=e}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(e){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=e}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(e){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=e}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(e){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=e}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(e){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=e}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(e){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=e}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(e){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=e}}});Ur.prototype.updateCubeMap=function(e,t){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(e,t)};Ur.prototype.clear=function(e,t,n,i){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(e,t,n,i)};Qr.crossOrigin=void 0;Qr.loadTexture=function(e,t,n,i){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new wi;r.setCrossOrigin(this.crossOrigin);const s=r.load(e,n,void 0,i);return t&&(s.mapping=t),s};Qr.loadTextureCube=function(e,t,n,i){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new Lc;r.setCrossOrigin(this.crossOrigin);const s=r.load(e,n,void 0,i);return t&&(s.mapping=t),s};Qr.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Qr.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:pv}}));var MM=function(){function e(E){He.call(this,E),this.dracoLoader=null,this.ddsLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(S){return new o(S)}),this.register(function(S){return new l(S)}),this.register(function(S){return new c(S)}),this.register(function(S){return new a(S)}),this.register(function(S){return new r(S)}),this.register(function(S){return new f(S)})}e.prototype=Object.assign(Object.create(He.prototype),{constructor:e,load:function(E,S,D,R){var U=this,G;this.resourcePath!==""?G=this.resourcePath:this.path!==""?G=this.path:G=yr.extractUrlBase(E),this.manager.itemStart(E);var x=function(L){R?R(L):console.error(L),U.manager.itemError(E),U.manager.itemEnd(E)},_=new jt(this.manager);_.setPath(this.path),_.setResponseType("arraybuffer"),_.setRequestHeader(this.requestHeader),_.setWithCredentials(this.withCredentials),_.load(E,function(L){try{U.parse(L,G,function(F){S(F),U.manager.itemEnd(E)},x)}catch(F){x(F)}},D,x)},setDRACOLoader:function(E){return this.dracoLoader=E,this},setDDSLoader:function(E){return this.ddsLoader=E,this},setKTX2Loader:function(E){return this.ktx2Loader=E,this},setMeshoptDecoder:function(E){return this.meshoptDecoder=E,this},register:function(E){return this.pluginCallbacks.indexOf(E)===-1&&this.pluginCallbacks.push(E),this},unregister:function(E){return this.pluginCallbacks.indexOf(E)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(E),1),this},parse:function(E,S,D,R){var U,G={},x={};if(typeof E=="string")U=E;else{var _=yr.decodeText(new Uint8Array(E,0,4));if(_===u){try{G[n.KHR_BINARY_GLTF]=new p(E)}catch(k){R&&R(k);return}U=G[n.KHR_BINARY_GLTF].content}else U=yr.decodeText(new Uint8Array(E))}var L=JSON.parse(U);if(L.asset===void 0||L.asset.version[0]<2){R&&R(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}var F=new de(L,{path:S||this.resourcePath||"",crossOrigin:this.crossOrigin,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});F.fileLoader.setRequestHeader(this.requestHeader);for(var O=0;O<this.pluginCallbacks.length;O++){var b=this.pluginCallbacks[O](F);x[b.name]=b,G[b.name]=!0}if(L.extensionsUsed)for(var O=0;O<L.extensionsUsed.length;++O){var w=L.extensionsUsed[O],V=L.extensionsRequired||[];switch(w){case n.KHR_MATERIALS_UNLIT:G[w]=new s;break;case n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:G[w]=new g;break;case n.KHR_DRACO_MESH_COMPRESSION:G[w]=new v(L,this.dracoLoader);break;case n.MSFT_TEXTURE_DDS:G[w]=new i(this.ddsLoader);break;case n.KHR_TEXTURE_TRANSFORM:G[w]=new y;break;case n.KHR_MESH_QUANTIZATION:G[w]=new T;break;default:V.indexOf(w)>=0&&x[w]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+w+'".')}}F.setExtensions(G),F.setPlugins(x),F.parse(D,R)}});function t(){var E={};return{get:function(S){return E[S]},add:function(S,D){E[S]=D},remove:function(S){delete E[S]},removeAll:function(){E={}}}}var n={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",MSFT_TEXTURE_DDS:"MSFT_texture_dds"};function i(E){if(!E)throw new Error("THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader");this.name=n.MSFT_TEXTURE_DDS,this.ddsLoader=E}function r(E){this.parser=E,this.name=n.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}r.prototype._markDefs=function(){for(var E=this.parser,S=this.parser.json.nodes||[],D=0,R=S.length;D<R;D++){var U=S[D];U.extensions&&U.extensions[this.name]&&U.extensions[this.name].light!==void 0&&E._addNodeRef(this.cache,U.extensions[this.name].light)}},r.prototype._loadLight=function(E){var S=this.parser,D="light:"+E,R=S.cache.get(D);if(R)return R;var U=S.json,G=U.extensions&&U.extensions[this.name]||{},x=G.lights||[],_=x[E],L,F=new xe(16777215);_.color!==void 0&&F.fromArray(_.color);var O=_.range!==void 0?_.range:0;switch(_.type){case"directional":L=new Ma(F),L.target.position.set(0,0,-1),L.add(L.target);break;case"point":L=new Ic(F),L.distance=O;break;case"spot":L=new Pc(F),L.distance=O,_.spot=_.spot||{},_.spot.innerConeAngle=_.spot.innerConeAngle!==void 0?_.spot.innerConeAngle:0,_.spot.outerConeAngle=_.spot.outerConeAngle!==void 0?_.spot.outerConeAngle:Math.PI/4,L.angle=_.spot.outerConeAngle,L.penumbra=1-_.spot.innerConeAngle/_.spot.outerConeAngle,L.target.position.set(0,0,-1),L.add(L.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+_.type)}return L.position.set(0,0,0),L.decay=2,_.intensity!==void 0&&(L.intensity=_.intensity),L.name=S.createUniqueName(_.name||"light_"+E),R=Promise.resolve(L),S.cache.add(D,R),R},r.prototype.createNodeAttachment=function(E){var S=this,D=this.parser,R=D.json,U=R.nodes[E],G=U.extensions&&U.extensions[this.name]||{},x=G.light;return x===void 0?null:this._loadLight(x).then(function(_){return D._getNodeRef(S.cache,x,_)})};function s(){this.name=n.KHR_MATERIALS_UNLIT}s.prototype.getMaterialType=function(){return Pt},s.prototype.extendParams=function(E,S,D){var R=[];E.color=new xe(1,1,1),E.opacity=1;var U=S.pbrMetallicRoughness;if(U){if(Array.isArray(U.baseColorFactor)){var G=U.baseColorFactor;E.color.fromArray(G),E.opacity=G[3]}U.baseColorTexture!==void 0&&R.push(D.assignTexture(E,"map",U.baseColorTexture))}return Promise.all(R)};function o(E){this.parser=E,this.name=n.KHR_MATERIALS_CLEARCOAT}o.prototype.getMaterialType=function(E){var S=this.parser,D=S.json.materials[E];return!D.extensions||!D.extensions[this.name]?null:Vn},o.prototype.extendMaterialParams=function(E,S){var D=this.parser,R=D.json.materials[E];if(!R.extensions||!R.extensions[this.name])return Promise.resolve();var U=[],G=R.extensions[this.name];if(G.clearcoatFactor!==void 0&&(S.clearcoat=G.clearcoatFactor),G.clearcoatTexture!==void 0&&U.push(D.assignTexture(S,"clearcoatMap",G.clearcoatTexture)),G.clearcoatRoughnessFactor!==void 0&&(S.clearcoatRoughness=G.clearcoatRoughnessFactor),G.clearcoatRoughnessTexture!==void 0&&U.push(D.assignTexture(S,"clearcoatRoughnessMap",G.clearcoatRoughnessTexture)),G.clearcoatNormalTexture!==void 0&&(U.push(D.assignTexture(S,"clearcoatNormalMap",G.clearcoatNormalTexture)),G.clearcoatNormalTexture.scale!==void 0)){var x=G.clearcoatNormalTexture.scale;S.clearcoatNormalScale=new le(x,x)}return Promise.all(U)};function a(E){this.parser=E,this.name=n.KHR_MATERIALS_TRANSMISSION}a.prototype.getMaterialType=function(E){var S=this.parser,D=S.json.materials[E];return!D.extensions||!D.extensions[this.name]?null:Vn},a.prototype.extendMaterialParams=function(E,S){var D=this.parser,R=D.json.materials[E];if(!R.extensions||!R.extensions[this.name])return Promise.resolve();var U=[],G=R.extensions[this.name];return G.transmissionFactor!==void 0&&(S.transmission=G.transmissionFactor),G.transmissionTexture!==void 0&&U.push(D.assignTexture(S,"transmissionMap",G.transmissionTexture)),Promise.all(U)};function l(E){this.parser=E,this.name=n.KHR_TEXTURE_BASISU}l.prototype.loadTexture=function(E){var S=this.parser,D=S.json,R=D.textures[E];if(!R.extensions||!R.extensions[this.name])return null;var U=R.extensions[this.name],G=D.images[U.source],x=S.options.ktx2Loader;if(!x){if(D.extensionsRequired&&D.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return S.loadTextureImage(E,G,x)};function c(E){this.parser=E,this.name=n.EXT_TEXTURE_WEBP,this.isSupported=null}c.prototype.loadTexture=function(E){var S=this.name,D=this.parser,R=D.json,U=R.textures[E];if(!U.extensions||!U.extensions[S])return null;var G=U.extensions[S],x=R.images[G.source],_=x.uri?D.options.manager.getHandler(x.uri):D.textureLoader;return this.detectSupport().then(function(L){if(L)return D.loadTextureImage(E,x,_);if(R.extensionsRequired&&R.extensionsRequired.indexOf(S)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return D.loadTexture(E)})},c.prototype.detectSupport=function(){return this.isSupported||(this.isSupported=new Promise(function(E){var S=new Image;S.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",S.onload=S.onerror=function(){E(S.height===1)}})),this.isSupported};function f(E){this.name=n.EXT_MESHOPT_COMPRESSION,this.parser=E}f.prototype.loadBufferView=function(E){var S=this.parser.json,D=S.bufferViews[E];if(D.extensions&&D.extensions[this.name]){var R=D.extensions[this.name],U=this.parser.getDependency("buffer",R.buffer),G=this.parser.options.meshoptDecoder;if(!G||!G.supported){if(S.extensionsRequired&&S.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([U,G.ready]).then(function(x){var _=R.byteOffset||0,L=R.byteLength||0,F=R.count,O=R.byteStride,b=new ArrayBuffer(F*O),w=new Uint8Array(x[0],_,L);return G.decodeGltfBuffer(new Uint8Array(b),F,O,w,R.mode,R.filter),b})}else return null};var u="glTF",d=12,h={JSON:1313821514,BIN:5130562};function p(E){this.name=n.KHR_BINARY_GLTF,this.content=null,this.body=null;var S=new DataView(E,0,d);if(this.header={magic:yr.decodeText(new Uint8Array(E.slice(0,4))),version:S.getUint32(4,!0),length:S.getUint32(8,!0)},this.header.magic!==u)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");for(var D=new DataView(E,d),R=0;R<D.byteLength;){var U=D.getUint32(R,!0);R+=4;var G=D.getUint32(R,!0);if(R+=4,G===h.JSON){var x=new Uint8Array(E,d+R,U);this.content=yr.decodeText(x)}else if(G===h.BIN){var _=d+R;this.body=E.slice(_,_+U)}R+=U}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}function v(E,S){if(!S)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=n.KHR_DRACO_MESH_COMPRESSION,this.json=E,this.dracoLoader=S,this.dracoLoader.preload()}v.prototype.decodePrimitive=function(E,S){var D=this.json,R=this.dracoLoader,U=E.extensions[this.name].bufferView,G=E.extensions[this.name].attributes,x={},_={},L={};for(var F in G){var O=te[F]||F.toLowerCase();x[O]=G[F]}for(F in E.attributes){var O=te[F]||F.toLowerCase();if(G[F]!==void 0){var b=D.accessors[E.attributes[F]],w=M[b.componentType];L[O]=w,_[O]=b.normalized===!0}}return S.getDependency("bufferView",U).then(function(V){return new Promise(function(k){R.decodeDracoFile(V,function(C){for(var J in C.attributes){var Z=C.attributes[J],K=_[J];K!==void 0&&(Z.normalized=K)}k(C)},x,L)})})};function y(){this.name=n.KHR_TEXTURE_TRANSFORM}y.prototype.extendTexture=function(E,S){return E=E.clone(),S.offset!==void 0&&E.offset.fromArray(S.offset),S.rotation!==void 0&&(E.rotation=S.rotation),S.scale!==void 0&&E.repeat.fromArray(S.scale),S.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),E.needsUpdate=!0,E};function m(E){Rt.call(this),this.isGLTFSpecularGlossinessMaterial=!0;var S=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),D=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),R=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	texelSpecular = sRGBToLinear( texelSpecular );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),U=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),G=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.specularRoughness += geometryRoughness;","material.specularRoughness = min( material.specularRoughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),x={specular:{value:new xe().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=x,this.onBeforeCompile=function(_){for(var L in x)_.uniforms[L]=x[L];_.fragmentShader=_.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",S).replace("#include <metalnessmap_pars_fragment>",D).replace("#include <roughnessmap_fragment>",R).replace("#include <metalnessmap_fragment>",U).replace("#include <lights_physical_fragment>",G)},Object.defineProperties(this,{specular:{get:function(){return x.specular.value},set:function(_){x.specular.value=_}},specularMap:{get:function(){return x.specularMap.value},set:function(_){x.specularMap.value=_,_?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return x.glossiness.value},set:function(_){x.glossiness.value=_}},glossinessMap:{get:function(){return x.glossinessMap.value},set:function(_){x.glossinessMap.value=_,_?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(E)}m.prototype=Object.create(Rt.prototype),m.prototype.constructor=m,m.prototype.copy=function(E){return Rt.prototype.copy.call(this,E),this.specularMap=E.specularMap,this.specular.copy(E.specular),this.glossinessMap=E.glossinessMap,this.glossiness=E.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this};function g(){return{name:n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,specularGlossinessParams:["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"],getMaterialType:function(){return m},extendParams:function(E,S,D){var R=S.extensions[this.name];E.color=new xe(1,1,1),E.opacity=1;var U=[];if(Array.isArray(R.diffuseFactor)){var G=R.diffuseFactor;E.color.fromArray(G),E.opacity=G[3]}if(R.diffuseTexture!==void 0&&U.push(D.assignTexture(E,"map",R.diffuseTexture)),E.emissive=new xe(0,0,0),E.glossiness=R.glossinessFactor!==void 0?R.glossinessFactor:1,E.specular=new xe(1,1,1),Array.isArray(R.specularFactor)&&E.specular.fromArray(R.specularFactor),R.specularGlossinessTexture!==void 0){var x=R.specularGlossinessTexture;U.push(D.assignTexture(E,"glossinessMap",x)),U.push(D.assignTexture(E,"specularMap",x))}return Promise.all(U)},createMaterial:function(E){var S=new m(E);return S.fog=!0,S.color=E.color,S.map=E.map===void 0?null:E.map,S.lightMap=null,S.lightMapIntensity=1,S.aoMap=E.aoMap===void 0?null:E.aoMap,S.aoMapIntensity=1,S.emissive=E.emissive,S.emissiveIntensity=1,S.emissiveMap=E.emissiveMap===void 0?null:E.emissiveMap,S.bumpMap=E.bumpMap===void 0?null:E.bumpMap,S.bumpScale=1,S.normalMap=E.normalMap===void 0?null:E.normalMap,S.normalMapType=Zi,E.normalScale&&(S.normalScale=E.normalScale),S.displacementMap=null,S.displacementScale=1,S.displacementBias=0,S.specularMap=E.specularMap===void 0?null:E.specularMap,S.specular=E.specular,S.glossinessMap=E.glossinessMap===void 0?null:E.glossinessMap,S.glossiness=E.glossiness,S.alphaMap=null,S.envMap=E.envMap===void 0?null:E.envMap,S.envMapIntensity=1,S.refractionRatio=.98,S}}}function T(){this.name=n.KHR_MESH_QUANTIZATION}function P(E,S,D,R){Nt.call(this,E,S,D,R)}P.prototype=Object.create(Nt.prototype),P.prototype.constructor=P,P.prototype.copySampleValue_=function(E){for(var S=this.resultBuffer,D=this.sampleValues,R=this.valueSize,U=E*R*3+R,G=0;G!==R;G++)S[G]=D[U+G];return S},P.prototype.beforeStart_=P.prototype.copySampleValue_,P.prototype.afterEnd_=P.prototype.copySampleValue_,P.prototype.interpolate_=function(E,S,D,R){for(var U=this.resultBuffer,G=this.sampleValues,x=this.valueSize,_=x*2,L=x*3,F=R-S,O=(D-S)/F,b=O*O,w=b*O,V=E*L,k=V-L,C=-2*w+3*b,J=w-b,Z=1-C,K=J-b+O,Q=0;Q!==x;Q++){var ae=G[k+Q+x],ue=G[k+Q+_]*F,pe=G[V+Q+x],ce=G[V+Q]*F;U[Q]=Z*ae+K*ue+C*pe+J*ce}return U};var A={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},M={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},N={9728:xt,9729:ct,9984:sc,9985:Wh,9986:oc,9987:Br},B={33071:Ct,33648:ua,10497:Un},W={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},te={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},H={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},j={CUBICSPLINE:void 0,LINEAR:Pr,STEP:zs},Y={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function X(E,S){return typeof E!="string"||E===""?"":(/^https?:\/\//i.test(S)&&/^\//.test(E)&&(S=S.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(E)||/^data:.*,.*$/i.test(E)||/^blob:.*$/i.test(E)?E:S+E)}function q(E){return E.DefaultMaterial===void 0&&(E.DefaultMaterial=new Rt({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:no})),E.DefaultMaterial}function $(E,S,D){for(var R in D.extensions)E[R]===void 0&&(S.userData.gltfExtensions=S.userData.gltfExtensions||{},S.userData.gltfExtensions[R]=D.extensions[R])}function ne(E,S){S.extras!==void 0&&(typeof S.extras=="object"?Object.assign(E.userData,S.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+S.extras))}function oe(E,S,D){for(var R=!1,U=!1,G=0,x=S.length;G<x;G++){var _=S[G];if(_.POSITION!==void 0&&(R=!0),_.NORMAL!==void 0&&(U=!0),R&&U)break}if(!R&&!U)return Promise.resolve(E);for(var L=[],F=[],G=0,x=S.length;G<x;G++){var _=S[G];if(R){var O=_.POSITION!==void 0?D.getDependency("accessor",_.POSITION):E.attributes.position;L.push(O)}if(U){var O=_.NORMAL!==void 0?D.getDependency("accessor",_.NORMAL):E.attributes.normal;F.push(O)}}return Promise.all([Promise.all(L),Promise.all(F)]).then(function(b){var w=b[0],V=b[1];return R&&(E.morphAttributes.position=w),U&&(E.morphAttributes.normal=V),E.morphTargetsRelative=!0,E})}function fe(E,S){if(E.updateMorphTargets(),S.weights!==void 0)for(var D=0,R=S.weights.length;D<R;D++)E.morphTargetInfluences[D]=S.weights[D];if(S.extras&&Array.isArray(S.extras.targetNames)){var U=S.extras.targetNames;if(E.morphTargetInfluences.length===U.length){E.morphTargetDictionary={};for(var D=0,R=U.length;D<R;D++)E.morphTargetDictionary[U[D]]=D}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function ge(E){var S=E.extensions&&E.extensions[n.KHR_DRACO_MESH_COMPRESSION],D;return S?D="draco:"+S.bufferView+":"+S.indices+":"+he(S.attributes):D=E.indices+":"+he(E.attributes)+":"+E.mode,D}function he(E){for(var S="",D=Object.keys(E).sort(),R=0,U=D.length;R<U;R++)S+=D[R]+":"+E[D[R]]+";";return S}function de(E,S){this.json=E||{},this.extensions={},this.plugins={},this.options=S||{},this.cache=new t,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.nodeNamesUsed={},typeof createImageBitmap<"u"&&/Firefox/.test(navigator.userAgent)===!1?this.textureLoader=new Fc(this.options.manager):this.textureLoader=new wi(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.fileLoader=new jt(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}de.prototype.setExtensions=function(E){this.extensions=E},de.prototype.setPlugins=function(E){this.plugins=E},de.prototype.parse=function(E,S){var D=this,R=this.json,U=this.extensions;this.cache.removeAll(),this._invokeAll(function(G){return G._markDefs&&G._markDefs()}),Promise.all([this.getDependencies("scene"),this.getDependencies("animation"),this.getDependencies("camera")]).then(function(G){var x={scene:G[0][R.scene||0],scenes:G[0],animations:G[1],cameras:G[2],asset:R.asset,parser:D,userData:{}};$(U,x,R),ne(x,R),E(x)}).catch(S)},de.prototype._markDefs=function(){for(var E=this.json.nodes||[],S=this.json.skins||[],D=this.json.meshes||[],R=0,U=S.length;R<U;R++)for(var G=S[R].joints,x=0,_=G.length;x<_;x++)E[G[x]].isBone=!0;for(var L=0,F=E.length;L<F;L++){var O=E[L];O.mesh!==void 0&&(this._addNodeRef(this.meshCache,O.mesh),O.skin!==void 0&&(D[O.mesh].isSkinnedMesh=!0)),O.camera!==void 0&&this._addNodeRef(this.cameraCache,O.camera)}},de.prototype._addNodeRef=function(E,S){S!==void 0&&(E.refs[S]===void 0&&(E.refs[S]=E.uses[S]=0),E.refs[S]++)},de.prototype._getNodeRef=function(E,S,D){if(E.refs[S]<=1)return D;var R=D.clone();return R.name+="_instance_"+E.uses[S]++,R},de.prototype._invokeOne=function(E){var S=Object.values(this.plugins);S.push(this);for(var D=0;D<S.length;D++){var R=E(S[D]);if(R)return R}},de.prototype._invokeAll=function(E){var S=Object.values(this.plugins);S.unshift(this);for(var D=[],R=0;R<S.length;R++){var U=E(S[R]);U&&D.push(U)}return D},de.prototype.getDependency=function(E,S){var D=E+":"+S,R=this.cache.get(D);if(!R){switch(E){case"scene":R=this.loadScene(S);break;case"node":R=this.loadNode(S);break;case"mesh":R=this._invokeOne(function(U){return U.loadMesh&&U.loadMesh(S)});break;case"accessor":R=this.loadAccessor(S);break;case"bufferView":R=this._invokeOne(function(U){return U.loadBufferView&&U.loadBufferView(S)});break;case"buffer":R=this.loadBuffer(S);break;case"material":R=this._invokeOne(function(U){return U.loadMaterial&&U.loadMaterial(S)});break;case"texture":R=this._invokeOne(function(U){return U.loadTexture&&U.loadTexture(S)});break;case"skin":R=this.loadSkin(S);break;case"animation":R=this.loadAnimation(S);break;case"camera":R=this.loadCamera(S);break;default:throw new Error("Unknown type: "+E)}this.cache.add(D,R)}return R},de.prototype.getDependencies=function(E){var S=this.cache.get(E);if(!S){var D=this,R=this.json[E+(E==="mesh"?"es":"s")]||[];S=Promise.all(R.map(function(U,G){return D.getDependency(E,G)})),this.cache.add(E,S)}return S},de.prototype.loadBuffer=function(E){var S=this.json.buffers[E],D=this.fileLoader;if(S.type&&S.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+S.type+" buffer type is not supported.");if(S.uri===void 0&&E===0)return Promise.resolve(this.extensions[n.KHR_BINARY_GLTF].body);var R=this.options;return new Promise(function(U,G){D.load(X(S.uri,R.path),U,void 0,function(){G(new Error('THREE.GLTFLoader: Failed to load buffer "'+S.uri+'".'))})})},de.prototype.loadBufferView=function(E){var S=this.json.bufferViews[E];return this.getDependency("buffer",S.buffer).then(function(D){var R=S.byteLength||0,U=S.byteOffset||0;return D.slice(U,U+R)})},de.prototype.loadAccessor=function(E){var S=this,D=this.json,R=this.json.accessors[E];if(R.bufferView===void 0&&R.sparse===void 0)return Promise.resolve(null);var U=[];return R.bufferView!==void 0?U.push(this.getDependency("bufferView",R.bufferView)):U.push(null),R.sparse!==void 0&&(U.push(this.getDependency("bufferView",R.sparse.indices.bufferView)),U.push(this.getDependency("bufferView",R.sparse.values.bufferView))),Promise.all(U).then(function(G){var x=G[0],_=W[R.type],L=M[R.componentType],F=L.BYTES_PER_ELEMENT,O=F*_,b=R.byteOffset||0,w=R.bufferView!==void 0?D.bufferViews[R.bufferView].byteStride:void 0,V=R.normalized===!0,k,C;if(w&&w!==O){var J=Math.floor(b/w),Z="InterleavedBuffer:"+R.bufferView+":"+R.componentType+":"+J+":"+R.count,K=S.cache.get(Z);K||(k=new L(x,J*w,R.count*w/F),K=new kt(k,w/F),S.cache.add(Z,K)),C=new Ai(K,_,b%w/F,V)}else x===null?k=new L(R.count*_):k=new L(x,b,R.count*_),C=new Se(k,_,V);if(R.sparse!==void 0){var Q=W.SCALAR,ae=M[R.sparse.indices.componentType],ue=R.sparse.indices.byteOffset||0,pe=R.sparse.values.byteOffset||0,ce=new ae(G[1],ue,R.sparse.count*Q),ye=new L(G[2],pe,R.sparse.count*_);x!==null&&(C=new Se(C.array.slice(),C.itemSize,C.normalized));for(var Te=0,Ke=ce.length;Te<Ke;Te++){var gt=ce[Te];if(C.setX(gt,ye[Te*_]),_>=2&&C.setY(gt,ye[Te*_+1]),_>=3&&C.setZ(gt,ye[Te*_+2]),_>=4&&C.setW(gt,ye[Te*_+3]),_>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return C})},de.prototype.loadTexture=function(E){var S=this,D=this.json,R=this.options,U=D.textures[E],G=U.extensions||{},x;G[n.MSFT_TEXTURE_DDS]?x=D.images[G[n.MSFT_TEXTURE_DDS].source]:x=D.images[U.source];var _;return x.uri&&(_=R.manager.getHandler(x.uri)),_||(_=G[n.MSFT_TEXTURE_DDS]?S.extensions[n.MSFT_TEXTURE_DDS].ddsLoader:this.textureLoader),this.loadTextureImage(E,x,_)},de.prototype.loadTextureImage=function(E,S,D){var R=this,U=this.json,G=this.options,x=U.textures[E],_=self.URL||self.webkitURL,L=S.uri,F=!1,O=!0;return S.mimeType==="image/jpeg"&&(O=!1),S.bufferView!==void 0&&(L=R.getDependency("bufferView",S.bufferView).then(function(b){if(S.mimeType==="image/png"){var w=new DataView(b,25,1).getUint8(0,!1);O=w===6||w===4||w===3}F=!0;var V=new Blob([b],{type:S.mimeType});return L=_.createObjectURL(V),L})),Promise.resolve(L).then(function(b){return new Promise(function(w,V){var k=w;D.isImageBitmapLoader===!0&&(k=function(C){w(new qs(C))}),D.load(X(b,G.path),k,void 0,V)})}).then(function(b){F===!0&&_.revokeObjectURL(L),b.flipY=!1,x.name&&(b.name=x.name),O||(b.format=xi);var w=U.samplers||{},V=w[x.sampler]||{};return b.magFilter=N[V.magFilter]||ct,b.minFilter=N[V.minFilter]||Br,b.wrapS=B[V.wrapS]||Un,b.wrapT=B[V.wrapT]||Un,R.associations.set(b,{type:"textures",index:E}),b})},de.prototype.assignTexture=function(E,S,D){var R=this;return this.getDependency("texture",D.index).then(function(U){if(D.texCoord!==void 0&&D.texCoord!=0&&!(S==="aoMap"&&D.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+D.texCoord+" for texture "+S+" not yet supported."),R.extensions[n.KHR_TEXTURE_TRANSFORM]){var G=D.extensions!==void 0?D.extensions[n.KHR_TEXTURE_TRANSFORM]:void 0;if(G){var x=R.associations.get(U);U=R.extensions[n.KHR_TEXTURE_TRANSFORM].extendTexture(U,G),R.associations.set(U,x)}}E[S]=U})},de.prototype.assignFinalMaterial=function(E){var S=E.geometry,D=E.material,R=S.attributes.tangent!==void 0,U=S.attributes.color!==void 0,G=S.attributes.normal===void 0,x=E.isSkinnedMesh===!0,_=Object.keys(S.morphAttributes).length>0,L=_&&S.morphAttributes.normal!==void 0;if(E.isPoints){var F="PointsMaterial:"+D.uuid,O=this.cache.get(F);O||(O=new Gn,we.prototype.copy.call(O,D),O.color.copy(D.color),O.map=D.map,O.sizeAttenuation=!1,this.cache.add(F,O)),D=O}else if(E.isLine){var F="LineBasicMaterial:"+D.uuid,b=this.cache.get(F);b||(b=new Tt,we.prototype.copy.call(b,D),b.color.copy(D.color),this.cache.add(F,b)),D=b}if(R||U||G||x||_){var F="ClonedMaterial:"+D.uuid+":";D.isGLTFSpecularGlossinessMaterial&&(F+="specular-glossiness:"),x&&(F+="skinning:"),R&&(F+="vertex-tangents:"),U&&(F+="vertex-colors:"),G&&(F+="flat-shading:"),_&&(F+="morph-targets:"),L&&(F+="morph-normals:");var w=this.cache.get(F);w||(w=D.clone(),x&&(w.skinning=!0),R&&(w.vertexTangents=!0),U&&(w.vertexColors=!0),G&&(w.flatShading=!0),_&&(w.morphTargets=!0),L&&(w.morphNormals=!0),this.cache.add(F,w),this.associations.set(w,this.associations.get(D))),D=w}D.aoMap&&S.attributes.uv2===void 0&&S.attributes.uv!==void 0&&S.setAttribute("uv2",S.attributes.uv),D.normalScale&&!R&&(D.normalScale.y=-D.normalScale.y),D.clearcoatNormalScale&&!R&&(D.clearcoatNormalScale.y=-D.clearcoatNormalScale.y),E.material=D},de.prototype.getMaterialType=function(){return Rt},de.prototype.loadMaterial=function(E){var S=this,D=this.json,R=this.extensions,U=D.materials[E],G,x={},_=U.extensions||{},L=[];if(_[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){var F=R[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];G=F.getMaterialType(),L.push(F.extendParams(x,U,S))}else if(_[n.KHR_MATERIALS_UNLIT]){var O=R[n.KHR_MATERIALS_UNLIT];G=O.getMaterialType(),L.push(O.extendParams(x,U,S))}else{var b=U.pbrMetallicRoughness||{};if(x.color=new xe(1,1,1),x.opacity=1,Array.isArray(b.baseColorFactor)){var w=b.baseColorFactor;x.color.fromArray(w),x.opacity=w[3]}b.baseColorTexture!==void 0&&L.push(S.assignTexture(x,"map",b.baseColorTexture)),x.metalness=b.metallicFactor!==void 0?b.metallicFactor:1,x.roughness=b.roughnessFactor!==void 0?b.roughnessFactor:1,b.metallicRoughnessTexture!==void 0&&(L.push(S.assignTexture(x,"metalnessMap",b.metallicRoughnessTexture)),L.push(S.assignTexture(x,"roughnessMap",b.metallicRoughnessTexture))),G=this._invokeOne(function(k){return k.getMaterialType&&k.getMaterialType(E)}),L.push(Promise.all(this._invokeAll(function(k){return k.extendMaterialParams&&k.extendMaterialParams(E,x)})))}U.doubleSided===!0&&(x.side=io);var V=U.alphaMode||Y.OPAQUE;return V===Y.BLEND?(x.transparent=!0,x.depthWrite=!1):(x.transparent=!1,V===Y.MASK&&(x.alphaTest=U.alphaCutoff!==void 0?U.alphaCutoff:.5)),U.normalTexture!==void 0&&G!==Pt&&(L.push(S.assignTexture(x,"normalMap",U.normalTexture)),x.normalScale=new le(1,1),U.normalTexture.scale!==void 0&&x.normalScale.set(U.normalTexture.scale,U.normalTexture.scale)),U.occlusionTexture!==void 0&&G!==Pt&&(L.push(S.assignTexture(x,"aoMap",U.occlusionTexture)),U.occlusionTexture.strength!==void 0&&(x.aoMapIntensity=U.occlusionTexture.strength)),U.emissiveFactor!==void 0&&G!==Pt&&(x.emissive=new xe().fromArray(U.emissiveFactor)),U.emissiveTexture!==void 0&&G!==Pt&&L.push(S.assignTexture(x,"emissiveMap",U.emissiveTexture)),Promise.all(L).then(function(){var k;return G===m?k=R[n.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(x):k=new G(x),U.name&&(k.name=U.name),k.map&&(k.map.encoding=Us),k.emissiveMap&&(k.emissiveMap.encoding=Us),ne(k,U),S.associations.set(k,{type:"materials",index:E}),U.extensions&&$(R,k,U),k})},de.prototype.createUniqueName=function(E){for(var S=bt.sanitizeNodeName(E||""),D=S,R=1;this.nodeNamesUsed[D];++R)D=S+"_"+R;return this.nodeNamesUsed[D]=!0,D};function Me(E,S,D){var R=S.attributes,U=new Jn;if(R.POSITION!==void 0){var G=D.json.accessors[R.POSITION],x=G.min,_=G.max;if(x!==void 0&&_!==void 0)U.set(new z(x[0],x[1],x[2]),new z(_[0],_[1],_[2]));else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;var L=S.targets;if(L!==void 0){for(var F=new z,O=new z,b=0,w=L.length;b<w;b++){var V=L[b];if(V.POSITION!==void 0){var G=D.json.accessors[V.POSITION],x=G.min,_=G.max;x!==void 0&&_!==void 0?(O.setX(Math.max(Math.abs(x[0]),Math.abs(_[0]))),O.setY(Math.max(Math.abs(x[1]),Math.abs(_[1]))),O.setZ(Math.max(Math.abs(x[2]),Math.abs(_[2]))),F.max(O)):console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}U.expandByVector(F)}E.boundingBox=U;var k=new Zn;U.getCenter(k.center),k.radius=U.min.distanceTo(U.max)/2,E.boundingSphere=k}function ke(E,S,D){var R=S.attributes,U=[];function G(F,O){return D.getDependency("accessor",F).then(function(b){E.setAttribute(O,b)})}for(var x in R){var _=te[x]||x.toLowerCase();_ in E.attributes||U.push(G(R[x],_))}if(S.indices!==void 0&&!E.index){var L=D.getDependency("accessor",S.indices).then(function(F){E.setIndex(F)});U.push(L)}return ne(E,S),Me(E,S,D),Promise.all(U).then(function(){return S.targets!==void 0?oe(E,S.targets,D):E})}function se(E,S){var D=E.getIndex();if(D===null){var R=[],U=E.getAttribute("position");if(U!==void 0){for(var G=0;G<U.count;G++)R.push(G);E.setIndex(R),D=E.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),E}var x=D.count-2,_=[];if(S===vf)for(var G=1;G<=x;G++)_.push(D.getX(0)),_.push(D.getX(G)),_.push(D.getX(G+1));else for(var G=0;G<x;G++)G%2===0?(_.push(D.getX(G)),_.push(D.getX(G+1)),_.push(D.getX(G+2))):(_.push(D.getX(G+2)),_.push(D.getX(G+1)),_.push(D.getX(G)));_.length/3!==x&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var L=E.clone();return L.setIndex(_),L}return de.prototype.loadGeometries=function(E){var S=this,D=this.extensions,R=this.primitiveCache;function U(w){return D[n.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(w,S).then(function(V){return ke(V,w,S)})}for(var G=[],x=0,_=E.length;x<_;x++){var L=E[x],F=ge(L),O=R[F];if(O)G.push(O.promise);else{var b;L.extensions&&L.extensions[n.KHR_DRACO_MESH_COMPRESSION]?b=U(L):b=ke(new Be,L,S),R[F]={primitive:L,promise:b},G.push(b)}}return Promise.all(G)},de.prototype.loadMesh=function(E){for(var S=this,D=this.json,R=this.extensions,U=D.meshes[E],G=U.primitives,x=[],_=0,L=G.length;_<L;_++){var F=G[_].material===void 0?q(this.cache):this.getDependency("material",G[_].material);x.push(F)}return x.push(S.loadGeometries(G)),Promise.all(x).then(function(O){for(var b=O.slice(0,O.length-1),w=O[O.length-1],V=[],k=0,C=w.length;k<C;k++){var J=w[k],Z=G[k],K,Q=b[k];if(Z.mode===A.TRIANGLES||Z.mode===A.TRIANGLE_STRIP||Z.mode===A.TRIANGLE_FAN||Z.mode===void 0)K=U.isSkinnedMesh===!0?new ma(J,Q):new rt(J,Q),K.isSkinnedMesh===!0&&!K.geometry.attributes.skinWeight.normalized&&K.normalizeSkinWeights(),Z.mode===A.TRIANGLE_STRIP?K.geometry=se(K.geometry,Uy):Z.mode===A.TRIANGLE_FAN&&(K.geometry=se(K.geometry,vf));else if(Z.mode===A.LINES)K=new kr(J,Q);else if(Z.mode===A.LINE_STRIP)K=new kn(J,Q);else if(Z.mode===A.LINE_LOOP)K=new vc(J,Q);else if(Z.mode===A.POINTS)K=new ya(J,Q);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+Z.mode);Object.keys(K.geometry.morphAttributes).length>0&&fe(K,U),K.name=S.createUniqueName(U.name||"mesh_"+E),ne(K,U),Z.extensions&&$(R,K,Z),S.assignFinalMaterial(K),V.push(K)}if(V.length===1)return V[0];for(var ae=new Sn,k=0,C=V.length;k<C;k++)ae.add(V[k]);return ae})},de.prototype.loadCamera=function(E){var S,D=this.json.cameras[E],R=D[D.type];if(!R){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return D.type==="perspective"?S=new lt(Ee.radToDeg(R.yfov),R.aspectRatio||1,R.znear||1,R.zfar||2e6):D.type==="orthographic"&&(S=new Qs(-R.xmag,R.xmag,R.ymag,-R.ymag,R.znear,R.zfar)),D.name&&(S.name=this.createUniqueName(D.name)),ne(S,D),Promise.resolve(S)},de.prototype.loadSkin=function(E){var S=this.json.skins[E],D={joints:S.joints};return S.inverseBindMatrices===void 0?Promise.resolve(D):this.getDependency("accessor",S.inverseBindMatrices).then(function(R){return D.inverseBindMatrices=R,D})},de.prototype.loadAnimation=function(E){for(var S=this.json,D=S.animations[E],R=[],U=[],G=[],x=[],_=[],L=0,F=D.channels.length;L<F;L++){var O=D.channels[L],b=D.samplers[O.sampler],w=O.target,V=w.node!==void 0?w.node:w.id,k=D.parameters!==void 0?D.parameters[b.input]:b.input,C=D.parameters!==void 0?D.parameters[b.output]:b.output;R.push(this.getDependency("node",V)),U.push(this.getDependency("accessor",k)),G.push(this.getDependency("accessor",C)),x.push(b),_.push(w)}return Promise.all([Promise.all(R),Promise.all(U),Promise.all(G),Promise.all(x),Promise.all(_)]).then(function(J){for(var Z=J[0],K=J[1],Q=J[2],ae=J[3],ue=J[4],pe=[],ce=0,ye=Z.length;ce<ye;ce++){var Te=Z[ce],Ke=K[ce],gt=Q[ce],$n=ae[ce],tt=ue[ce];if(Te!==void 0){Te.updateMatrix(),Te.matrixAutoUpdate=!0;var ft;switch(H[tt.path]){case H.weights:ft=Xr;break;case H.rotation:ft=$s;break;case H.position:case H.scale:default:ft=Yr;break}var Kn=Te.name?Te.name:Te.uuid,qa=$n.interpolation!==void 0?j[$n.interpolation]:Pr,gn=[];H[tt.path]===H.weights?Te.traverse(function(I){I.isMesh===!0&&I.morphTargetInfluences&&gn.push(I.name?I.name:I.uuid)}):gn.push(Kn);var Jt=gt.array;if(gt.normalized){var Qn;if(Jt.constructor===Int8Array)Qn=1/127;else if(Jt.constructor===Uint8Array)Qn=1/255;else if(Jt.constructor==Int16Array)Qn=1/32767;else if(Jt.constructor===Uint16Array)Qn=1/65535;else throw new Error("THREE.GLTFLoader: Unsupported output accessor component type.");for(var ts=new Float32Array(Jt.length),st=0,Ki=Jt.length;st<Ki;st++)ts[st]=Jt[st]*Qn;Jt=ts}for(var st=0,Ki=gn.length;st<Ki;st++){var ns=new ft(gn[st]+"."+H[tt.path],Ke.array,Jt,qa);$n.interpolation==="CUBICSPLINE"&&(ns.createInterpolant=function(re){return new P(this.times,this.values,this.getValueSize()/3,re)},ns.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),pe.push(ns)}}}var Xa=D.name?D.name:"animation_"+E;return new Kt(Xa,void 0,pe)})},de.prototype.loadNode=function(E){var S=this.json,D=this.extensions,R=this,U=S.nodes[E],G=U.name?R.createUniqueName(U.name):"";return function(){var x=[];return U.mesh!==void 0&&x.push(R.getDependency("mesh",U.mesh).then(function(_){var L=R._getNodeRef(R.meshCache,U.mesh,_);return U.weights!==void 0&&L.traverse(function(F){if(!!F.isMesh)for(var O=0,b=U.weights.length;O<b;O++)F.morphTargetInfluences[O]=U.weights[O]}),L})),U.camera!==void 0&&x.push(R.getDependency("camera",U.camera).then(function(_){return R._getNodeRef(R.cameraCache,U.camera,_)})),R._invokeAll(function(_){return _.createNodeAttachment&&_.createNodeAttachment(E)}).forEach(function(_){x.push(_)}),Promise.all(x)}().then(function(x){var _;if(U.isBone===!0?_=new ga:x.length>1?_=new Sn:x.length===1?_=x[0]:_=new be,_!==x[0])for(var L=0,F=x.length;L<F;L++)_.add(x[L]);if(U.name&&(_.userData.name=U.name,_.name=G),ne(_,U),U.extensions&&$(D,_,U),U.matrix!==void 0){var O=new Le;O.fromArray(U.matrix),_.applyMatrix4(O)}else U.translation!==void 0&&_.position.fromArray(U.translation),U.rotation!==void 0&&_.quaternion.fromArray(U.rotation),U.scale!==void 0&&_.scale.fromArray(U.scale);return R.associations.set(_,{type:"nodes",index:E}),_})},de.prototype.loadScene=function(){function E(S,D,R,U){var G=R.nodes[S];return U.getDependency("node",S).then(function(x){if(G.skin===void 0)return x;var _;return U.getDependency("skin",G.skin).then(function(L){_=L;for(var F=[],O=0,b=_.joints.length;O<b;O++)F.push(U.getDependency("node",_.joints[O]));return Promise.all(F)}).then(function(L){return x.traverse(function(F){if(!!F.isMesh){for(var O=[],b=[],w=0,V=L.length;w<V;w++){var k=L[w];if(k){O.push(k);var C=new Le;_.inverseBindMatrices!==void 0&&C.fromArray(_.inverseBindMatrices.array,w*16),b.push(C)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',_.joints[w])}F.bind(new va(O,b),F.matrixWorld)}}),x})}).then(function(x){D.add(x);var _=[];if(G.children)for(var L=G.children,F=0,O=L.length;F<O;F++){var b=L[F];_.push(E(b,x,R,U))}return Promise.all(_)})}return function(D){var R=this.json,U=this.extensions,G=this.json.scenes[D],x=this,_=new Sn;G.name&&(_.name=x.createUniqueName(G.name)),ne(_,G),G.extensions&&$(U,_,G);for(var L=G.nodes||[],F=[],O=0,b=L.length;O<b;O++)F.push(E(L[O],_,R,x));return Promise.all(F).then(function(){return _})}}(),e}(),Ht=function(e){He.call(this,e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}};Ht.prototype=Object.assign(Object.create(He.prototype),{constructor:Ht,setDecoderPath:function(e){return this.decoderPath=e,this},setDecoderConfig:function(e){return this.decoderConfig=e,this},setWorkerLimit:function(e){return this.workerLimit=e,this},setVerbosity:function(){console.warn("THREE.DRACOLoader: The .setVerbosity() method has been removed.")},setDrawMode:function(){console.warn("THREE.DRACOLoader: The .setDrawMode() method has been removed.")},setSkipDequantization:function(){console.warn("THREE.DRACOLoader: The .setSkipDequantization() method has been removed.")},load:function(e,t,n,i){var r=new jt(this.manager);r.setPath(this.path),r.setResponseType("arraybuffer"),r.setRequestHeader(this.requestHeader),r.setWithCredentials(this.withCredentials),r.load(e,s=>{var o={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(s,o).then(t).catch(i)},n,i)},decodeDracoFile:function(e,t,n,i){var r={attributeIDs:n||this.defaultAttributeIDs,attributeTypes:i||this.defaultAttributeTypes,useUniqueIDs:!!n};this.decodeGeometry(e,r).then(t)},decodeGeometry:function(e,t){for(var n in t.attributeTypes){var i=t.attributeTypes[n];i.BYTES_PER_ELEMENT!==void 0&&(t.attributeTypes[n]=i.name)}var r=JSON.stringify(t);if(Ht.taskCache.has(e)){var s=Ht.taskCache.get(e);if(s.key===r)return s.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}var o,a=this.workerNextTaskID++,l=e.byteLength,c=this._getWorker(a,l).then(f=>(o=f,new Promise((u,d)=>{o._callbacks[a]={resolve:u,reject:d},o.postMessage({type:"decode",id:a,taskConfig:t,buffer:e},[e])}))).then(f=>this._createGeometry(f.geometry));return c.catch(()=>!0).then(()=>{o&&a&&this._releaseTask(o,a)}),Ht.taskCache.set(e,{key:r,promise:c}),c},_createGeometry:function(e){var t=new Be;e.index&&t.setIndex(new Se(e.index.array,1));for(var n=0;n<e.attributes.length;n++){var i=e.attributes[n],r=i.name,s=i.array,o=i.itemSize;t.setAttribute(r,new Se(s,o))}return t},_loadLibrary:function(e,t){var n=new jt(this.manager);return n.setPath(this.decoderPath),n.setResponseType(t),n.setWithCredentials(this.withCredentials),new Promise((i,r)=>{n.load(e,i,void 0,r)})},preload:function(){return this._initDecoder(),this},_initDecoder:function(){if(this.decoderPending)return this.decoderPending;var e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",t=[];return e?t.push(this._loadLibrary("draco_decoder.js","text")):(t.push(this._loadLibrary("draco_wasm_wrapper.js","text")),t.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(t).then(n=>{var i=n[0];e||(this.decoderConfig.wasmBinary=n[1]);var r=Ht.DRACOWorker.toString(),s=["/* draco decoder */",i,"","/* worker */",r.substring(r.indexOf("{")+1,r.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([s]))}),this.decoderPending},_getWorker:function(e,t){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){var n=new Worker(this.workerSourceURL);n._callbacks={},n._taskCosts={},n._taskLoad=0,n.postMessage({type:"init",decoderConfig:this.decoderConfig}),n.onmessage=function(r){var s=r.data;switch(s.type){case"decode":n._callbacks[s.id].resolve(s);break;case"error":n._callbacks[s.id].reject(s);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+s.type+'"')}},this.workerPool.push(n)}else this.workerPool.sort(function(i,r){return i._taskLoad>r._taskLoad?-1:1});var n=this.workerPool[this.workerPool.length-1];return n._taskCosts[e]=t,n._taskLoad+=t,n})},_releaseTask:function(e,t){e._taskLoad-=e._taskCosts[t],delete e._callbacks[t],delete e._taskCosts[t]},debug:function(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))},dispose:function(){for(var e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}});Ht.DRACOWorker=function(){var e,t;onmessage=function(o){var a=o.data;switch(a.type){case"init":e=a.decoderConfig,t=new Promise(function(f){e.onModuleLoaded=function(u){f({draco:u})},DracoDecoderModule(e)});break;case"decode":var l=a.buffer,c=a.taskConfig;t.then(f=>{var u=f.draco,d=new u.Decoder,h=new u.DecoderBuffer;h.Init(new Int8Array(l),l.byteLength);try{var p=n(u,d,h,c),v=p.attributes.map(y=>y.array.buffer);p.index&&v.push(p.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:p},v)}catch(y){console.error(y),self.postMessage({type:"error",id:a.id,error:y.message})}finally{u.destroy(h),u.destroy(d)}});break}};function n(o,a,l,c){var f=c.attributeIDs,u=c.attributeTypes,d,h,p=a.GetEncodedGeometryType(l);if(p===o.TRIANGULAR_MESH)d=new o.Mesh,h=a.DecodeBufferToMesh(l,d);else if(p===o.POINT_CLOUD)d=new o.PointCloud,h=a.DecodeBufferToPointCloud(l,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!h.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+h.error_msg());var v={index:null,attributes:[]};for(var y in f){var m=self[u[y]],g,T;if(c.useUniqueIDs)T=f[y],g=a.GetAttributeByUniqueId(d,T);else{if(T=a.GetAttributeId(d,o[f[y]]),T===-1)continue;g=a.GetAttribute(d,T)}v.attributes.push(r(o,a,d,y,m,g))}return p===o.TRIANGULAR_MESH&&(v.index=i(o,a,d)),o.destroy(d),v}function i(o,a,l){var c=l.num_faces(),f=c*3,u=f*4,d=o._malloc(u);a.GetTrianglesUInt32Array(l,u,d);var h=new Uint32Array(o.HEAPF32.buffer,d,f).slice();return o._free(d),{array:h,itemSize:1}}function r(o,a,l,c,f,u){var d=u.num_components(),h=l.num_points(),p=h*d,v=p*f.BYTES_PER_ELEMENT,y=s(o,f),m=o._malloc(v);a.GetAttributeDataArrayForAllPoints(l,u,y,v,m);var g=new f(o.HEAPF32.buffer,m,p).slice();return o._free(m),{name:c,array:g,itemSize:d}}function s(o,a){switch(a){case Float32Array:return o.DT_FLOAT32;case Int8Array:return o.DT_INT8;case Int16Array:return o.DT_INT16;case Int32Array:return o.DT_INT32;case Uint8Array:return o.DT_UINT8;case Uint16Array:return o.DT_UINT16;case Uint32Array:return o.DT_UINT32}}};Ht.taskCache=new WeakMap;Ht.setDecoderPath=function(){console.warn("THREE.DRACOLoader: The .setDecoderPath() method has been removed. Use instance methods.")};Ht.setDecoderConfig=function(){console.warn("THREE.DRACOLoader: The .setDecoderConfig() method has been removed. Use instance methods.")};Ht.releaseDecoderModule=function(){console.warn("THREE.DRACOLoader: The .releaseDecoderModule() method has been removed. Use instance methods.")};Ht.getDecoderModule=function(){console.warn("THREE.DRACOLoader: The .getDecoderModule() method has been removed. Use instance methods.")};var Ir,Ea;class SM{constructor(t=0,n=0,i=""){Ja(this,Ir,0);Ja(this,Ea,new wi);this.num=t,this.range=n,this.particle=null,this.texture=i,this.texturesMaps=[],this.position=null,this.gen()}gen(){const{num:t,range:n,texture:i}=this,r=new Be,s=new Gn({size:6,transparent:!0,opacity:.6,depthWrite:!1,vertexColors:!0,map:co(this,Ea).load(i),blending:ic}),o=[],a=[];for(let l=0;l<t;l++){const c=new xe,f={h:0,s:0,l:0};c.getHSL(f),c.setHSL(f.h,f.s,f.l*Math.random()),a.push(c.r,c.g,c.b),o.push(Ee.randFloatSpread(n*2),Ee.randFloatSpread(n*2),Ee.randFloatSpread(n*2))}this.position=new Ie(o,3),r.setAttribute("position",this.position),r.setAttribute("color",new Ie(a,3)),this.particle=new ya(r,s)}snowing(t=0,n=0){if(Za(this,Ir,co(this,Ir)+1),n>0){if(co(this,Ir)<n*60)return;Za(this,Ir,0)}const{position:i,range:r}=this;for(let s=0;s<i.count;s++){let o=i.getX(s),a=i.getY(s),l=i.getZ(s);o-=t,a-=t,l-=t,o<-r&&(o=r),a<-r&&(a=r),l<-r&&(l=r),i.setX(s,o),i.setY(s,a),i.setZ(s,l)}i.needsUpdate=!0}}Ir=new WeakMap,Ea=new WeakMap;const TM="0x282828",EM=-1,AM=.2,Fi=3,Pd=1,LM=3,$o=1;class CM{constructor(t){this.config={isMobile:!1},this.modelPath=t,this.score=0,this.size={width:window.innerWidth,height:window.innerHeight},this.scene=new ap,this.snow=new SM(1e4,100,"./textures/snow.png"),this.scene.add(this.snow.particle),this.camera=new Qs(this.size.width/-80,this.size.width/80,this.size.height/80,this.size.height/-80,0,5e3),this.cameraPos={current:new z(0,0,0),next:new z},this.renderer=new ao({antialias:!0}),this.renderer.outputEncoding=Us,this.model=null;const i=new wi().load("./textures/bg2.jpg");i.wrapS=i.wrapT=Un,i.repeat.set(50,50);var r=new zw(this.size.width,this.size.height),s=new Yi({map:i}),o=new rt(r,s);o.receiveShadow=!0,o.rotation.x=-.5*Math.PI,o.position.x=0,o.position.y=-1,o.position.z=0,this.plane=o,this.scene.add(this.plane),this.scene.background=new xe(255),this.cubes=[],this.cubeStat={nextDir:""},this.jumperStat={ready:!1,xSpeed:0,ySpeed:0},this.falledStat={location:-1,distance:0},this.fallingStat={speed:.2,end:!1},this.combo=0}init(){this._checkUserAgent(),this._setCamera(),this._setRenderer(),this._setLight(),this._createCube(),this._createCube(),this._createJumper(),this._updateCamera();var t=this,n=t.config.isMobile?{down:"touchstart",up:"touchend"}:{down:"mousedown",up:"mouseup"},i=document.querySelector("canvas");i.addEventListener(n.down,function(){t._handleMousedown()}),i.addEventListener(n.up,function(r){t._handleMouseup()}),window.addEventListener("resize",function(){t._handleWindowResize()})}restart(){this.score=0,this.cameraPos={current:new z(0,0,0),next:new z},this.fallingStat={speed:.2,end:!1};for(var t=this.cubes.length,n=0;n<t;n++)this.scene.remove(this.cubes.pop());this.scene.remove(this.jumper),this.successCallback(this.score),this._createCube(),this._createCube(),this._createJumper(),this._updateCamera()}addSuccessFn(t){this.successCallback=t}addFailedFn(t){this.failedCallback=t}_checkUserAgent(){var t=navigator.userAgent;(t.match(/Android/i)||t.match(/webOS/i)||t.match(/iPhone/i)||t.match(/iPad/i)||t.match(/iPod/i)||t.match(/BlackBerry/i))&&(this.config.isMobile=!0)}_createHelpers(){var t=new bM(10);this.scene.add(t);var n=new _M(this.directionalLight,5);this.scene.add(n)}_handleWindowResize(){this._setSize(),this.camera.left=this.size.width/-80,this.camera.right=this.size.width/80,this.camera.top=this.size.height/80,this.camera.bottom=this.size.height/-80,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.size.width,this.size.height),this._render()}_handleMousedown(){var t=this;function n(){!t.jumperStat.ready&&t.jumper.scale.y>=.5&&(t.jumper.scale.y-=.01,t.jumperStat.xSpeed+=.004,t.jumperStat.ySpeed+=.008,t.jumperStat.yTimes=(1-t.jumper.scale.y)/.01,t.mouseDownFrameHandler=requestAnimationFrame(n)),t._render(t.scene,t.camera)}n()}_handleMouseup(){var t=this;t.jumperStat.ready=!0,cancelAnimationFrame(t.mouseDownFrameHandler);var n;function i(){t.jumperStat.ySpeed>0||t.jumper.position.y>=1?(t.jumperStat.yTimes/2,t.cubeStat.nextDir==="left"?t.jumper.position.x-=t.jumperStat.xSpeed:t.jumper.position.z-=t.jumperStat.xSpeed,t.jumper.position.y+=t.jumperStat.ySpeed,t.jumper.scale.y<1&&(t.jumper.scale.y+=.01),t.jumperStat.ySpeed-=.01,t._render(t.scene,t.camera),n=requestAnimationFrame(i)):(cancelAnimationFrame(n),r())}function r(){if(t.jumperStat.ready=!1,t.jumperStat.xSpeed=0,t.jumperStat.ySpeed=0,t.jumper.position.y=.5,t.jumper.rotation.z=0,t.jumper.rotation.x=0,t._checkInCube(),t.falledStat.location===1){var s=new Audio("./audio/jump.mp3");s.volume=.75,s.loop=!1,s.play(),t.score+=Math.pow(2,t.combo),t._createCube(),t._updateCamera(),t.successCallback&&t.successCallback(t.score)}else t._falling()}i()}_fallingRotate(t){var n=this,i=n.falledStat.distance-Fi/2,r="z",s=n.jumper.rotation[r]+.1,o=n.jumper.rotation[r]<Math.PI/2,a=EM+$o/2+i;if(t==="rightTop")r="x",s=n.jumper.rotation[r]-.1,o=n.jumper.rotation[r]>-Math.PI/2,n.jumper.translate.z=i;else if(t==="rightBottom")r="x",s=n.jumper.rotation[r]+.1,o=n.jumper.rotation[r]<Math.PI/2,n.jumper.translate.z=-i;else if(t==="leftBottom")r="z",s=n.jumper.rotation[r]-.1,o=n.jumper.rotation[r]>-Math.PI/2,n.jumper.translate.x=-i;else if(t==="leftTop")r="z",s=n.jumper.rotation[r]+.1,o=n.jumper.rotation[r]<Math.PI/2,n.jumper.translate.x=i;else if(t==="none")o=!1,a=n.config.ground;else throw Error("Arguments Error");n.fallingStat.end?n.failedCallback&&n.failedCallback():(o?n.jumper.rotation[r]=s:n.jumper.position.y>a?n.jumper.position.y-=AM:n.fallingStat.end=!0,n._render(),requestAnimationFrame(function(){n._falling()}))}_falling(){var t=this;t.falledStat.location==0?t._fallingRotate("none"):t.falledStat.location===-10?t.cubeStat.nextDir=="left"?t._fallingRotate("leftTop"):t._fallingRotate("rightTop"):t.falledStat.location===10&&(t.cubeStat.nextDir=="left"?t.jumper.position.x<t.cubes[t.cubes.length-1].position.x?t._fallingRotate("leftTop"):t._fallingRotate("leftBottom"):t.jumper.position.z<t.cubes[t.cubes.length-1].position.z?t._fallingRotate("rightTop"):t._fallingRotate("rightBottom"))}_checkInCube(){if(this.cubes.length>1){var t={x:this.jumper.position.x,z:this.jumper.position.z},n={x:this.cubes[this.cubes.length-1-1].position.x,z:this.cubes[this.cubes.length-1-1].position.z},i={x:this.cubes[this.cubes.length-1].position.x,z:this.cubes[this.cubes.length-1].position.z},r,s;this.cubeStat.nextDir==="left"?(r=Math.abs(t.x-n.x),s=Math.abs(t.x-i.x)):(r=Math.abs(t.z-n.z),s=Math.abs(t.z-i.z));var o=Fi/2+$o/2,a=0;r<o?(this.falledStat.distance=r,a=r<Fi/2?-1:-10):s<o?(this.falledStat.distance=s,a=s<Fi/2?1:10,t.x==i.x&&t.z==i.z?this.combo++:this.combo=0):a=0,this.falledStat.location=a}}_updateCameraPos(){var t=this.cubes.length-1,n={x:this.cubes[t].position.x,z:this.cubes[t].position.z},i={x:this.cubes[t-1].position.x,z:this.cubes[t-1].position.z},r=new z;r.x=(n.x+i.x)/2,r.y=0,r.z=(n.z+i.z)/2,this.cameraPos.next=r}_updateCamera(){var t=this,n={x:t.cameraPos.current.x,y:t.cameraPos.current.y,z:t.cameraPos.current.z},i={x:t.cameraPos.next.x,y:t.cameraPos.next.y,z:t.cameraPos.next.z};(n.x>i.x||n.z>i.z)&&(t.cameraPos.current.x-=.1,t.cameraPos.current.z-=.1,t.cameraPos.current.x-t.cameraPos.next.x<.05&&(t.cameraPos.current.x=t.cameraPos.next.x),t.cameraPos.current.z-t.cameraPos.next.z<.05&&(t.cameraPos.current.z=t.cameraPos.next.z),t.camera.lookAt(new z(n.x,0,n.z)),t._render(),requestAnimationFrame(function(){t._updateCamera()}))}async _createJumper(){var t=this;let n=new Ht;n.setDecoderPath("./draco/gltf/"),n.setDecoderConfig({type:"js"});let i=new MM;i.setDRACOLoader(i),console.log(1111);var r=new Promise((a,l)=>{i.load(this.modelPath,c=>{c.scene.traverse(h=>{h.castShadow=!0}),c.scene.scale.set(2.2,2.2,2.2),c.scene.position.set(0,0,0),c.scene.rotation.y=Math.PI/-2;const f=c.animations[0],u=new Bc(c.scene);u.timeScale=1/5,u.clipAction(f).play(),c.scene,a(c.scene)})});this.model=await r;var s=new Sn;s.add(this.model),s.position.y=3,s.position.x=$o/2,s.position.z=$o/2,this.jumper=s,this.scene.add(this.jumper),this.directionalLight.target=this.jumper;function o(){t.jumper.position.y>1&&(t.jumper.position.y-=.1,t._render(t.scene,t.camera),requestAnimationFrame(function(){o()}))}o()}_createCube(){var t=this._createGeometry(),n=this._createMaterial()(),i=new rt(t.geometry,n.material);i.castShadow=!0,i.receiveShadow=!0,this.cubes.length&&(this.cubeStat.nextDir=Math.random()>.5?"left":"right",i.position.x=this.cubes[this.cubes.length-1].position.x,i.position.y=this.cubes[this.cubes.length-1].position.y,i.position.z=this.cubes[this.cubes.length-1].position.z,this.cubeStat.nextDir==="left"?i.position.x=this.cubes[this.cubes.length-1].position.x-4*Math.random()-6:i.position.z=this.cubes[this.cubes.length-1].position.z-4*Math.random()-6),this.cubes.push(i),this.cubes.length>6&&this.scene.remove(this.cubes.shift()),this.scene.add(i),this.cubes.length>1&&this._updateCameraPos()}_render(){this.renderer.render(this.scene,this.camera),this.snow.snowing(.3,.03)}_setLight(){var t=new Nc(16777215,.3);this.scene.add(t),this.directionalLight=new Ma(16777215,10),this.directionalLight.distance=0,this.directionalLight.position.set(60,50,40),this.directionalLight.castShadow=!0,this.directionalLight.intensity=.5,this.scene.add(this.directionalLight)}_setCamera(){this.camera.position.set(100,100,100),this.camera.lookAt(this.cameraPos.current)}_setRenderer(){this.renderer.setSize(this.size.width,this.size.height),this.renderer.setClearColor(TM),this.renderer.shadowMap.enabled=!0,document.body.appendChild(this.renderer.domElement)}_setSize(){this.size.width=window.innerWidth,this.size.height=window.innerHeight}_createMaterial(){this.config;var t=[n(),n(),n(),i(),i(),i()];return function(r){return r==null&&(r=Math.floor(Math.random()*t.length)),t[r]};function n(){var r=new wi().load("./textures/ice.png");return r.wrapS=r.wrapT=Un,r.repeat.set(1,1),{material:new Pt({map:r}),type:"Chess"}}function i(){var r=new wi().load("./textures/box.jpg");return r.wrapS=r.wrapT=Un,r.repeat.set(1,1),{material:new Pt({map:r}),type:"Chess"}}}_createGeometry(){var t={};return Math.random()>.5?(t.geometry=new gw(Fi/2,Fi/2,Pd,40),t.type="CylinderGeometry"):(t.geometry=new pw(Fi,Pd,LM),t.type="CubeGeometry"),t}}var PM=!1;/*!
  * pinia v2.0.33
  * (c) 2023 Eduardo San Martin Morote
  * @license MIT
  */let bp;const ja=e=>bp=e,wp=Symbol();function Uc(e){return e&&typeof e=="object"&&Object.prototype.toString.call(e)==="[object Object]"&&typeof e.toJSON!="function"}var Ps;(function(e){e.direct="direct",e.patchObject="patch object",e.patchFunction="patch function"})(Ps||(Ps={}));function RM(){const e=$d(!0),t=e.run(()=>it({}));let n=[],i=[];const r=Dr({install(s){ja(r),r._a=s,s.provide(wp,r),s.config.globalProperties.$pinia=r,i.forEach(o=>n.push(o)),i=[]},use(s){return!this._a&&!PM?i.push(s):n.push(s),this},_p:n,_a:null,_e:e,_s:new Map,state:t});return r}const Mp=()=>{};function Rd(e,t,n,i=Mp){e.push(t);const r=()=>{const s=e.indexOf(t);s>-1&&(e.splice(s,1),i())};return!n&&em()&&tm(r),r}function gr(e,...t){e.slice().forEach(n=>{n(...t)})}function Hc(e,t){e instanceof Map&&t instanceof Map&&t.forEach((n,i)=>e.set(i,n)),e instanceof Set&&t instanceof Set&&t.forEach(e.add,e);for(const n in t){if(!t.hasOwnProperty(n))continue;const i=t[n],r=e[n];Uc(r)&&Uc(i)&&e.hasOwnProperty(n)&&!et(i)&&!vi(i)?e[n]=Hc(r,i):e[n]=i}return e}const IM=Symbol();function OM(e){return!Uc(e)||!e.hasOwnProperty(IM)}const{assign:ui}=Object;function NM(e){return!!(et(e)&&e.effect)}function DM(e,t,n,i){const{state:r,actions:s,getters:o}=t,a=n.state.value[e];let l;function c(){a||(n.state.value[e]=r?r():{});const f=Rm(n.state.value[e]);return ui(f,s,Object.keys(o||{}).reduce((u,d)=>(u[d]=Dr(Ha(()=>{ja(n);const h=n._s.get(e);return o[d].call(h,h)})),u),{}))}return l=Sp(e,c,t,n,i,!0),l}function Sp(e,t,n={},i,r,s){let o;const a=ui({actions:{}},n),l={deep:!0};let c,f,u=Dr([]),d=Dr([]),h;const p=i.state.value[e];!s&&!p&&(i.state.value[e]={}),it({});let v;function y(N){let B;c=f=!1,typeof N=="function"?(N(i.state.value[e]),B={type:Ps.patchFunction,storeId:e,events:h}):(Hc(i.state.value[e],N),B={type:Ps.patchObject,payload:N,storeId:e,events:h});const W=v=Symbol();iu().then(()=>{v===W&&(c=!0)}),f=!0,gr(u,B,i.state.value[e])}const m=s?function(){const{state:B}=n,W=B?B():{};this.$patch(te=>{ui(te,W)})}:Mp;function g(){o.stop(),u=[],d=[],i._s.delete(e)}function T(N,B){return function(){ja(i);const W=Array.from(arguments),te=[],H=[];function j(q){te.push(q)}function Y(q){H.push(q)}gr(d,{args:W,name:N,store:A,after:j,onError:Y});let X;try{X=B.apply(this&&this.$id===e?this:A,W)}catch(q){throw gr(H,q),q}return X instanceof Promise?X.then(q=>(gr(te,q),q)).catch(q=>(gr(H,q),Promise.reject(q))):(gr(te,X),X)}}const P={_p:i,$id:e,$onAction:Rd.bind(null,d),$patch:y,$reset:m,$subscribe(N,B={}){const W=Rd(u,N,B.detached,()=>te()),te=o.run(()=>xs(()=>i.state.value[e],H=>{(B.flush==="sync"?f:c)&&N({storeId:e,type:Ps.direct,events:h},H)},ui({},l,B)));return W},$dispose:g},A=Ra(P);i._s.set(e,A);const M=i._e.run(()=>(o=$d(),o.run(()=>t())));for(const N in M){const B=M[N];if(et(B)&&!NM(B)||vi(B))s||(p&&OM(B)&&(et(B)?B.value=p[N]:Hc(B,p[N])),i.state.value[e][N]=B);else if(typeof B=="function"){const W=T(N,B);M[N]=W,a.actions[N]=B}}return ui(A,M),ui(Ue(A),M),Object.defineProperty(A,"$state",{get:()=>i.state.value[e],set:N=>{y(B=>{ui(B,N)})}}),i._p.forEach(N=>{ui(A,o.run(()=>N({store:A,app:i._a,pinia:i,options:a})))}),p&&s&&n.hydrate&&n.hydrate(A.$state,p),c=!0,f=!0,A}function Tp(e,t,n){let i,r;const s=typeof t=="function";typeof e=="string"?(i=e,r=s?n:t):(r=e,i=e.id);function o(a,l){const c=Fh();return a=a||c&&ys(wp,null),a&&ja(a),a=bp,a._s.has(i)||(s?Sp(i,t,r,a):DM(i,r,a)),a._s.get(i)}return o.$id=i,o}const FM=Tp("storeApp",{state(){return{themeType:"light",bgm:"",score:0}},getters:{getThemeType:e=>e.themeType,getBgm:e=>e.bgm,getScore:e=>e.score},actions:{setThemeType(e){this.themeType=e},setBgm(e){this.bgm=e},setScore(e){this.score=e}},persist:{enabled:!0,strategies:[{storage:sessionStorage,paths:["themeType"]},{storage:sessionStorage,paths:["bgm"]}]}}),BM=Tp("storeUser",{state(){return{name:"kids",age:18,accessToken:"abcdefg",account:"",chainId:Number({VITE_VERSION:"1.0.0",BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0}.VITE_APP_CHAINID),accounts:[],address:"",walletConnector:null,connected:!1,token:""}},getters:{getaccount:e=>e.account,getchainId:e=>e.chainId,getaccounts:e=>e.accounts,getaddress:e=>e.address,getwalletConnector:e=>e.walletConnector,getconnected:e=>e.connected,gettoken:e=>e.token},actions:{setAccount(e){this.account=e},setToken(e){this.token=e},setChainId(e){this.account=e},setAccounts(e){this.accounts=e},setAddress(e){this.address=e},setWalletConnector(e){this.walletConnector=e},setConnected(e){this.connected=e}},persist:{enabled:!0,strategies:[{storage:sessionStorage,paths:["name","age"]},{storage:localStorage,paths:["accessToken"]}]}});function zM(){return{useAppStore:FM(),useUserStore:BM()}}function Id(e){return e!==null&&typeof e=="object"&&"constructor"in e&&e.constructor===Object}function bu(e={},t={}){Object.keys(t).forEach(n=>{typeof e[n]>"u"?e[n]=t[n]:Id(t[n])&&Id(e[n])&&Object.keys(t[n]).length>0&&bu(e[n],t[n])})}const Ep={body:{},addEventListener(){},removeEventListener(){},activeElement:{blur(){},nodeName:""},querySelector(){return null},querySelectorAll(){return[]},getElementById(){return null},createEvent(){return{initEvent(){}}},createElement(){return{children:[],childNodes:[],style:{},setAttribute(){},getElementsByTagName(){return[]}}},createElementNS(){return{}},importNode(){return null},location:{hash:"",host:"",hostname:"",href:"",origin:"",pathname:"",protocol:"",search:""}};function $i(){const e=typeof document<"u"?document:{};return bu(e,Ep),e}const UM={document:Ep,navigator:{userAgent:""},location:{hash:"",host:"",hostname:"",href:"",origin:"",pathname:"",protocol:"",search:""},history:{replaceState(){},pushState(){},go(){},back(){}},CustomEvent:function(){return this},addEventListener(){},removeEventListener(){},getComputedStyle(){return{getPropertyValue(){return""}}},Image(){},Date(){},screen:{},setTimeout(){},clearTimeout(){},matchMedia(){return{}},requestAnimationFrame(e){return typeof setTimeout>"u"?(e(),null):setTimeout(e,0)},cancelAnimationFrame(e){typeof setTimeout>"u"||clearTimeout(e)}};function Yt(){const e=typeof window<"u"?window:{};return bu(e,UM),e}function HM(e){const t=e;Object.keys(t).forEach(n=>{try{t[n]=null}catch{}try{delete t[n]}catch{}})}function kc(e,t=0){return setTimeout(e,t)}function eo(){return Date.now()}function kM(e){const t=Yt();let n;return t.getComputedStyle&&(n=t.getComputedStyle(e,null)),!n&&e.currentStyle&&(n=e.currentStyle),n||(n=e.style),n}function GM(e,t="x"){const n=Yt();let i,r,s;const o=kM(e);return n.WebKitCSSMatrix?(r=o.transform||o.webkitTransform,r.split(",").length>6&&(r=r.split(", ").map(a=>a.replace(",",".")).join(", ")),s=new n.WebKitCSSMatrix(r==="none"?"":r)):(s=o.MozTransform||o.OTransform||o.MsTransform||o.msTransform||o.transform||o.getPropertyValue("transform").replace("translate(","matrix(1, 0, 0, 1,"),i=s.toString().split(",")),t==="x"&&(n.WebKitCSSMatrix?r=s.m41:i.length===16?r=parseFloat(i[12]):r=parseFloat(i[4])),t==="y"&&(n.WebKitCSSMatrix?r=s.m42:i.length===16?r=parseFloat(i[13]):r=parseFloat(i[5])),r||0}function Ko(e){return typeof e=="object"&&e!==null&&e.constructor&&Object.prototype.toString.call(e).slice(8,-1)==="Object"}function VM(e){return typeof window<"u"&&typeof window.HTMLElement<"u"?e instanceof HTMLElement:e&&(e.nodeType===1||e.nodeType===11)}function Ut(...e){const t=Object(e[0]),n=["__proto__","constructor","prototype"];for(let i=1;i<e.length;i+=1){const r=e[i];if(r!=null&&!VM(r)){const s=Object.keys(Object(r)).filter(o=>n.indexOf(o)<0);for(let o=0,a=s.length;o<a;o+=1){const l=s[o],c=Object.getOwnPropertyDescriptor(r,l);c!==void 0&&c.enumerable&&(Ko(t[l])&&Ko(r[l])?r[l].__swiper__?t[l]=r[l]:Ut(t[l],r[l]):!Ko(t[l])&&Ko(r[l])?(t[l]={},r[l].__swiper__?t[l]=r[l]:Ut(t[l],r[l])):t[l]=r[l])}}}return t}function Qo(e,t,n){e.style.setProperty(t,n)}function Ap({swiper:e,targetPosition:t,side:n}){const i=Yt(),r=-e.translate;let s=null,o;const a=e.params.speed;e.wrapperEl.style.scrollSnapType="none",i.cancelAnimationFrame(e.cssModeFrameID);const l=t>r?"next":"prev",c=(u,d)=>l==="next"&&u>=d||l==="prev"&&u<=d,f=()=>{o=new Date().getTime(),s===null&&(s=o);const u=Math.max(Math.min((o-s)/a,1),0),d=.5-Math.cos(u*Math.PI)/2;let h=r+d*(t-r);if(c(h,t)&&(h=t),e.wrapperEl.scrollTo({[n]:h}),c(h,t)){e.wrapperEl.style.overflow="hidden",e.wrapperEl.style.scrollSnapType="",setTimeout(()=>{e.wrapperEl.style.overflow="",e.wrapperEl.scrollTo({[n]:h})}),i.cancelAnimationFrame(e.cssModeFrameID);return}e.cssModeFrameID=i.requestAnimationFrame(f)};f()}function wu(e){return e.querySelector(".swiper-slide-transform")||e.shadowEl&&e.shadowEl.querySelector(".swiper-slide-transform")||e}function zn(e,t=""){return[...e.children].filter(n=>n.matches(t))}function Lp(e,t=[]){const n=document.createElement(e);return n.classList.add(...Array.isArray(t)?t:[t]),n}function WM(e,t){const n=[];for(;e.previousElementSibling;){const i=e.previousElementSibling;t?i.matches(t)&&n.push(i):n.push(i),e=i}return n}function jM(e,t){const n=[];for(;e.nextElementSibling;){const i=e.nextElementSibling;t?i.matches(t)&&n.push(i):n.push(i),e=i}return n}function pi(e,t){return Yt().getComputedStyle(e,null).getPropertyValue(t)}function Od(e){let t=e,n;if(t){for(n=0;(t=t.previousSibling)!==null;)t.nodeType===1&&(n+=1);return n}}function qM(e,t){const n=[];let i=e.parentElement;for(;i;)t?i.matches(t)&&n.push(i):n.push(i),i=i.parentElement;return n}function XM(e,t){function n(i){i.target===e&&(t.call(e,i),e.removeEventListener("transitionend",n))}t&&e.addEventListener("transitionend",n)}function Nd(e,t,n){const i=Yt();return n?e[t==="width"?"offsetWidth":"offsetHeight"]+parseFloat(i.getComputedStyle(e,null).getPropertyValue(t==="width"?"margin-right":"margin-top"))+parseFloat(i.getComputedStyle(e,null).getPropertyValue(t==="width"?"margin-left":"margin-bottom")):e.offsetWidth}let Fl;function YM(){const e=Yt(),t=$i();return{smoothScroll:t.documentElement&&"scrollBehavior"in t.documentElement.style,touch:!!("ontouchstart"in e||e.DocumentTouch&&t instanceof e.DocumentTouch)}}function Cp(){return Fl||(Fl=YM()),Fl}let Bl;function JM({userAgent:e}={}){const t=Cp(),n=Yt(),i=n.navigator.platform,r=e||n.navigator.userAgent,s={ios:!1,android:!1},o=n.screen.width,a=n.screen.height,l=r.match(/(Android);?[\s\/]+([\d.]+)?/);let c=r.match(/(iPad).*OS\s([\d_]+)/);const f=r.match(/(iPod)(.*OS\s([\d_]+))?/),u=!c&&r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),d=i==="Win32";let h=i==="MacIntel";const p=["1024x1366","1366x1024","834x1194","1194x834","834x1112","1112x834","768x1024","1024x768","820x1180","1180x820","810x1080","1080x810"];return!c&&h&&t.touch&&p.indexOf(`${o}x${a}`)>=0&&(c=r.match(/(Version)\/([\d.]+)/),c||(c=[0,1,"13_0_0"]),h=!1),l&&!d&&(s.os="android",s.android=!0),(c||u||f)&&(s.os="ios",s.ios=!0),s}function ZM(e={}){return Bl||(Bl=JM(e)),Bl}let zl;function $M(){const e=Yt();let t=!1;function n(){const i=e.navigator.userAgent.toLowerCase();return i.indexOf("safari")>=0&&i.indexOf("chrome")<0&&i.indexOf("android")<0}if(n()){const i=String(e.navigator.userAgent);if(i.includes("Version/")){const[r,s]=i.split("Version/")[1].split(" ")[0].split(".").map(o=>Number(o));t=r<16||r===16&&s<2}}return{isSafari:t||n(),needPerspectiveFix:t,isWebView:/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent)}}function KM(){return zl||(zl=$M()),zl}function QM({swiper:e,on:t,emit:n}){const i=Yt();let r=null,s=null;const o=()=>{!e||e.destroyed||!e.initialized||(n("beforeResize"),n("resize"))},a=()=>{!e||e.destroyed||!e.initialized||(r=new ResizeObserver(f=>{s=i.requestAnimationFrame(()=>{const{width:u,height:d}=e;let h=u,p=d;f.forEach(({contentBoxSize:v,contentRect:y,target:m})=>{m&&m!==e.el||(h=y?y.width:(v[0]||v).inlineSize,p=y?y.height:(v[0]||v).blockSize)}),(h!==u||p!==d)&&o()})}),r.observe(e.el))},l=()=>{s&&i.cancelAnimationFrame(s),r&&r.unobserve&&e.el&&(r.unobserve(e.el),r=null)},c=()=>{!e||e.destroyed||!e.initialized||n("orientationchange")};t("init",()=>{if(e.params.resizeObserver&&typeof i.ResizeObserver<"u"){a();return}i.addEventListener("resize",o),i.addEventListener("orientationchange",c)}),t("destroy",()=>{l(),i.removeEventListener("resize",o),i.removeEventListener("orientationchange",c)})}function eS({swiper:e,extendParams:t,on:n,emit:i}){const r=[],s=Yt(),o=(c,f={})=>{const u=s.MutationObserver||s.WebkitMutationObserver,d=new u(h=>{if(e.__preventObserver__)return;if(h.length===1){i("observerUpdate",h[0]);return}const p=function(){i("observerUpdate",h[0])};s.requestAnimationFrame?s.requestAnimationFrame(p):s.setTimeout(p,0)});d.observe(c,{attributes:typeof f.attributes>"u"?!0:f.attributes,childList:typeof f.childList>"u"?!0:f.childList,characterData:typeof f.characterData>"u"?!0:f.characterData}),r.push(d)},a=()=>{if(!!e.params.observer){if(e.params.observeParents){const c=qM(e.el);for(let f=0;f<c.length;f+=1)o(c[f])}o(e.el,{childList:e.params.observeSlideChildren}),o(e.wrapperEl,{attributes:!1})}},l=()=>{r.forEach(c=>{c.disconnect()}),r.splice(0,r.length)};t({observer:!1,observeParents:!1,observeSlideChildren:!1}),n("init",a),n("destroy",l)}const tS={on(e,t,n){const i=this;if(!i.eventsListeners||i.destroyed||typeof t!="function")return i;const r=n?"unshift":"push";return e.split(" ").forEach(s=>{i.eventsListeners[s]||(i.eventsListeners[s]=[]),i.eventsListeners[s][r](t)}),i},once(e,t,n){const i=this;if(!i.eventsListeners||i.destroyed||typeof t!="function")return i;function r(...s){i.off(e,r),r.__emitterProxy&&delete r.__emitterProxy,t.apply(i,s)}return r.__emitterProxy=t,i.on(e,r,n)},onAny(e,t){const n=this;if(!n.eventsListeners||n.destroyed||typeof e!="function")return n;const i=t?"unshift":"push";return n.eventsAnyListeners.indexOf(e)<0&&n.eventsAnyListeners[i](e),n},offAny(e){const t=this;if(!t.eventsListeners||t.destroyed||!t.eventsAnyListeners)return t;const n=t.eventsAnyListeners.indexOf(e);return n>=0&&t.eventsAnyListeners.splice(n,1),t},off(e,t){const n=this;return!n.eventsListeners||n.destroyed||!n.eventsListeners||e.split(" ").forEach(i=>{typeof t>"u"?n.eventsListeners[i]=[]:n.eventsListeners[i]&&n.eventsListeners[i].forEach((r,s)=>{(r===t||r.__emitterProxy&&r.__emitterProxy===t)&&n.eventsListeners[i].splice(s,1)})}),n},emit(...e){const t=this;if(!t.eventsListeners||t.destroyed||!t.eventsListeners)return t;let n,i,r;return typeof e[0]=="string"||Array.isArray(e[0])?(n=e[0],i=e.slice(1,e.length),r=t):(n=e[0].events,i=e[0].data,r=e[0].context||t),i.unshift(r),(Array.isArray(n)?n:n.split(" ")).forEach(o=>{t.eventsAnyListeners&&t.eventsAnyListeners.length&&t.eventsAnyListeners.forEach(a=>{a.apply(r,[o,...i])}),t.eventsListeners&&t.eventsListeners[o]&&t.eventsListeners[o].forEach(a=>{a.apply(r,i)})}),t}};function nS(){const e=this;let t,n;const i=e.el;typeof e.params.width<"u"&&e.params.width!==null?t=e.params.width:t=i.clientWidth,typeof e.params.height<"u"&&e.params.height!==null?n=e.params.height:n=i.clientHeight,!(t===0&&e.isHorizontal()||n===0&&e.isVertical())&&(t=t-parseInt(pi(i,"padding-left")||0,10)-parseInt(pi(i,"padding-right")||0,10),n=n-parseInt(pi(i,"padding-top")||0,10)-parseInt(pi(i,"padding-bottom")||0,10),Number.isNaN(t)&&(t=0),Number.isNaN(n)&&(n=0),Object.assign(e,{width:t,height:n,size:e.isHorizontal()?t:n}))}function iS(){const e=this;function t(H){return e.isHorizontal()?H:{width:"height","margin-top":"margin-left","margin-bottom ":"margin-right","margin-left":"margin-top","margin-right":"margin-bottom","padding-left":"padding-top","padding-right":"padding-bottom",marginRight:"marginBottom"}[H]}function n(H,j){return parseFloat(H.getPropertyValue(t(j))||0)}const i=e.params,{wrapperEl:r,slidesEl:s,size:o,rtlTranslate:a,wrongRTL:l}=e,c=e.virtual&&i.virtual.enabled,f=c?e.virtual.slides.length:e.slides.length,u=zn(s,`.${e.params.slideClass}, swiper-slide`),d=c?e.virtual.slides.length:u.length;let h=[];const p=[],v=[];let y=i.slidesOffsetBefore;typeof y=="function"&&(y=i.slidesOffsetBefore.call(e));let m=i.slidesOffsetAfter;typeof m=="function"&&(m=i.slidesOffsetAfter.call(e));const g=e.snapGrid.length,T=e.slidesGrid.length;let P=i.spaceBetween,A=-y,M=0,N=0;if(typeof o>"u")return;typeof P=="string"&&P.indexOf("%")>=0&&(P=parseFloat(P.replace("%",""))/100*o),e.virtualSize=-P,u.forEach(H=>{a?H.style.marginLeft="":H.style.marginRight="",H.style.marginBottom="",H.style.marginTop=""}),i.centeredSlides&&i.cssMode&&(Qo(r,"--swiper-centered-offset-before",""),Qo(r,"--swiper-centered-offset-after",""));const B=i.grid&&i.grid.rows>1&&e.grid;B&&e.grid.initSlides(d);let W;const te=i.slidesPerView==="auto"&&i.breakpoints&&Object.keys(i.breakpoints).filter(H=>typeof i.breakpoints[H].slidesPerView<"u").length>0;for(let H=0;H<d;H+=1){W=0;let j;if(u[H]&&(j=u[H]),B&&e.grid.updateSlide(H,j,d,t),!(u[H]&&pi(j,"display")==="none")){if(i.slidesPerView==="auto"){te&&(u[H].style[t("width")]="");const Y=getComputedStyle(j),X=j.style.transform,q=j.style.webkitTransform;if(X&&(j.style.transform="none"),q&&(j.style.webkitTransform="none"),i.roundLengths)W=e.isHorizontal()?Nd(j,"width",!0):Nd(j,"height",!0);else{const $=n(Y,"width"),ne=n(Y,"padding-left"),oe=n(Y,"padding-right"),fe=n(Y,"margin-left"),ge=n(Y,"margin-right"),he=Y.getPropertyValue("box-sizing");if(he&&he==="border-box")W=$+fe+ge;else{const{clientWidth:de,offsetWidth:Me}=j;W=$+ne+oe+fe+ge+(Me-de)}}X&&(j.style.transform=X),q&&(j.style.webkitTransform=q),i.roundLengths&&(W=Math.floor(W))}else W=(o-(i.slidesPerView-1)*P)/i.slidesPerView,i.roundLengths&&(W=Math.floor(W)),u[H]&&(u[H].style[t("width")]=`${W}px`);u[H]&&(u[H].swiperSlideSize=W),v.push(W),i.centeredSlides?(A=A+W/2+M/2+P,M===0&&H!==0&&(A=A-o/2-P),H===0&&(A=A-o/2-P),Math.abs(A)<1/1e3&&(A=0),i.roundLengths&&(A=Math.floor(A)),N%i.slidesPerGroup===0&&h.push(A),p.push(A)):(i.roundLengths&&(A=Math.floor(A)),(N-Math.min(e.params.slidesPerGroupSkip,N))%e.params.slidesPerGroup===0&&h.push(A),p.push(A),A=A+W+P),e.virtualSize+=W+P,M=W,N+=1}}if(e.virtualSize=Math.max(e.virtualSize,o)+m,a&&l&&(i.effect==="slide"||i.effect==="coverflow")&&(r.style.width=`${e.virtualSize+i.spaceBetween}px`),i.setWrapperSize&&(r.style[t("width")]=`${e.virtualSize+i.spaceBetween}px`),B&&e.grid.updateWrapperSize(W,h,t),!i.centeredSlides){const H=[];for(let j=0;j<h.length;j+=1){let Y=h[j];i.roundLengths&&(Y=Math.floor(Y)),h[j]<=e.virtualSize-o&&H.push(Y)}h=H,Math.floor(e.virtualSize-o)-Math.floor(h[h.length-1])>1&&h.push(e.virtualSize-o)}if(c&&i.loop){const H=v[0]+P;if(i.slidesPerGroup>1){const j=Math.ceil((e.virtual.slidesBefore+e.virtual.slidesAfter)/i.slidesPerGroup),Y=H*i.slidesPerGroup;for(let X=0;X<j;X+=1)h.push(h[h.length-1]+Y)}for(let j=0;j<e.virtual.slidesBefore+e.virtual.slidesAfter;j+=1)i.slidesPerGroup===1&&h.push(h[h.length-1]+H),p.push(p[p.length-1]+H),e.virtualSize+=H}if(h.length===0&&(h=[0]),i.spaceBetween!==0){const H=e.isHorizontal()&&a?"marginLeft":t("marginRight");u.filter((j,Y)=>!i.cssMode||i.loop?!0:Y!==u.length-1).forEach(j=>{j.style[H]=`${P}px`})}if(i.centeredSlides&&i.centeredSlidesBounds){let H=0;v.forEach(Y=>{H+=Y+(i.spaceBetween?i.spaceBetween:0)}),H-=i.spaceBetween;const j=H-o;h=h.map(Y=>Y<0?-y:Y>j?j+m:Y)}if(i.centerInsufficientSlides){let H=0;if(v.forEach(j=>{H+=j+(i.spaceBetween?i.spaceBetween:0)}),H-=i.spaceBetween,H<o){const j=(o-H)/2;h.forEach((Y,X)=>{h[X]=Y-j}),p.forEach((Y,X)=>{p[X]=Y+j})}}if(Object.assign(e,{slides:u,snapGrid:h,slidesGrid:p,slidesSizesGrid:v}),i.centeredSlides&&i.cssMode&&!i.centeredSlidesBounds){Qo(r,"--swiper-centered-offset-before",`${-h[0]}px`),Qo(r,"--swiper-centered-offset-after",`${e.size/2-v[v.length-1]/2}px`);const H=-e.snapGrid[0],j=-e.slidesGrid[0];e.snapGrid=e.snapGrid.map(Y=>Y+H),e.slidesGrid=e.slidesGrid.map(Y=>Y+j)}if(d!==f&&e.emit("slidesLengthChange"),h.length!==g&&(e.params.watchOverflow&&e.checkOverflow(),e.emit("snapGridLengthChange")),p.length!==T&&e.emit("slidesGridLengthChange"),i.watchSlidesProgress&&e.updateSlidesOffset(),!c&&!i.cssMode&&(i.effect==="slide"||i.effect==="fade")){const H=`${i.containerModifierClass}backface-hidden`,j=e.el.classList.contains(H);d<=i.maxBackfaceHiddenSlides?j||e.el.classList.add(H):j&&e.el.classList.remove(H)}}function rS(e){const t=this,n=[],i=t.virtual&&t.params.virtual.enabled;let r=0,s;typeof e=="number"?t.setTransition(e):e===!0&&t.setTransition(t.params.speed);const o=a=>i?t.getSlideIndexByData(a):t.slides[a];if(t.params.slidesPerView!=="auto"&&t.params.slidesPerView>1)if(t.params.centeredSlides)(t.visibleSlides||[]).forEach(a=>{n.push(a)});else for(s=0;s<Math.ceil(t.params.slidesPerView);s+=1){const a=t.activeIndex+s;if(a>t.slides.length&&!i)break;n.push(o(a))}else n.push(o(t.activeIndex));for(s=0;s<n.length;s+=1)if(typeof n[s]<"u"){const a=n[s].offsetHeight;r=a>r?a:r}(r||r===0)&&(t.wrapperEl.style.height=`${r}px`)}function sS(){const e=this,t=e.slides,n=e.isElement?e.isHorizontal()?e.wrapperEl.offsetLeft:e.wrapperEl.offsetTop:0;for(let i=0;i<t.length;i+=1)t[i].swiperSlideOffset=(e.isHorizontal()?t[i].offsetLeft:t[i].offsetTop)-n}function oS(e=this&&this.translate||0){const t=this,n=t.params,{slides:i,rtlTranslate:r,snapGrid:s}=t;if(i.length===0)return;typeof i[0].swiperSlideOffset>"u"&&t.updateSlidesOffset();let o=-e;r&&(o=e),i.forEach(a=>{a.classList.remove(n.slideVisibleClass)}),t.visibleSlidesIndexes=[],t.visibleSlides=[];for(let a=0;a<i.length;a+=1){const l=i[a];let c=l.swiperSlideOffset;n.cssMode&&n.centeredSlides&&(c-=i[0].swiperSlideOffset);const f=(o+(n.centeredSlides?t.minTranslate():0)-c)/(l.swiperSlideSize+n.spaceBetween),u=(o-s[0]+(n.centeredSlides?t.minTranslate():0)-c)/(l.swiperSlideSize+n.spaceBetween),d=-(o-c),h=d+t.slidesSizesGrid[a];(d>=0&&d<t.size-1||h>1&&h<=t.size||d<=0&&h>=t.size)&&(t.visibleSlides.push(l),t.visibleSlidesIndexes.push(a),i[a].classList.add(n.slideVisibleClass)),l.progress=r?-f:f,l.originalProgress=r?-u:u}}function aS(e){const t=this;if(typeof e>"u"){const f=t.rtlTranslate?-1:1;e=t&&t.translate&&t.translate*f||0}const n=t.params,i=t.maxTranslate()-t.minTranslate();let{progress:r,isBeginning:s,isEnd:o,progressLoop:a}=t;const l=s,c=o;if(i===0)r=0,s=!0,o=!0;else{r=(e-t.minTranslate())/i;const f=Math.abs(e-t.minTranslate())<1,u=Math.abs(e-t.maxTranslate())<1;s=f||r<=0,o=u||r>=1,f&&(r=0),u&&(r=1)}if(n.loop){const f=t.getSlideIndexByData(0),u=t.getSlideIndexByData(t.slides.length-1),d=t.slidesGrid[f],h=t.slidesGrid[u],p=t.slidesGrid[t.slidesGrid.length-1],v=Math.abs(e);v>=d?a=(v-d)/p:a=(v+p-h)/p,a>1&&(a-=1)}Object.assign(t,{progress:r,progressLoop:a,isBeginning:s,isEnd:o}),(n.watchSlidesProgress||n.centeredSlides&&n.autoHeight)&&t.updateSlidesProgress(e),s&&!l&&t.emit("reachBeginning toEdge"),o&&!c&&t.emit("reachEnd toEdge"),(l&&!s||c&&!o)&&t.emit("fromEdge"),t.emit("progress",r)}function lS(){const e=this,{slides:t,params:n,slidesEl:i,activeIndex:r}=e,s=e.virtual&&n.virtual.enabled,o=l=>zn(i,`.${n.slideClass}${l}, swiper-slide${l}`)[0];t.forEach(l=>{l.classList.remove(n.slideActiveClass,n.slideNextClass,n.slidePrevClass)});let a;if(s)if(n.loop){let l=r-e.virtual.slidesBefore;l<0&&(l=e.virtual.slides.length+l),l>=e.virtual.slides.length&&(l-=e.virtual.slides.length),a=o(`[data-swiper-slide-index="${l}"]`)}else a=o(`[data-swiper-slide-index="${r}"]`);else a=t[r];if(a){a.classList.add(n.slideActiveClass);let l=jM(a,`.${n.slideClass}, swiper-slide`)[0];n.loop&&!l&&(l=t[0]),l&&l.classList.add(n.slideNextClass);let c=WM(a,`.${n.slideClass}, swiper-slide`)[0];n.loop&&!c===0&&(c=t[t.length-1]),c&&c.classList.add(n.slidePrevClass)}e.emitSlidesClasses()}function cS(e){const{slidesGrid:t,params:n}=e,i=e.rtlTranslate?e.translate:-e.translate;let r;for(let s=0;s<t.length;s+=1)typeof t[s+1]<"u"?i>=t[s]&&i<t[s+1]-(t[s+1]-t[s])/2?r=s:i>=t[s]&&i<t[s+1]&&(r=s+1):i>=t[s]&&(r=s);return n.normalizeSlideIndex&&(r<0||typeof r>"u")&&(r=0),r}function uS(e){const t=this,n=t.rtlTranslate?t.translate:-t.translate,{snapGrid:i,params:r,activeIndex:s,realIndex:o,snapIndex:a}=t;let l=e,c;const f=d=>{let h=d-t.virtual.slidesBefore;return h<0&&(h=t.virtual.slides.length+h),h>=t.virtual.slides.length&&(h-=t.virtual.slides.length),h};if(typeof l>"u"&&(l=cS(t)),i.indexOf(n)>=0)c=i.indexOf(n);else{const d=Math.min(r.slidesPerGroupSkip,l);c=d+Math.floor((l-d)/r.slidesPerGroup)}if(c>=i.length&&(c=i.length-1),l===s){c!==a&&(t.snapIndex=c,t.emit("snapIndexChange")),t.params.loop&&t.virtual&&t.params.virtual.enabled&&(t.realIndex=f(l));return}let u;t.virtual&&r.virtual.enabled&&r.loop?u=f(l):t.slides[l]?u=parseInt(t.slides[l].getAttribute("data-swiper-slide-index")||l,10):u=l,Object.assign(t,{snapIndex:c,realIndex:u,previousIndex:s,activeIndex:l}),t.emit("activeIndexChange"),t.emit("snapIndexChange"),o!==u&&t.emit("realIndexChange"),(t.initialized||t.params.runCallbacksOnInit)&&t.emit("slideChange")}function fS(e){const t=this,n=t.params,i=e.closest(`.${n.slideClass}, swiper-slide`);let r=!1,s;if(i){for(let o=0;o<t.slides.length;o+=1)if(t.slides[o]===i){r=!0,s=o;break}}if(i&&r)t.clickedSlide=i,t.virtual&&t.params.virtual.enabled?t.clickedIndex=parseInt(i.getAttribute("data-swiper-slide-index"),10):t.clickedIndex=s;else{t.clickedSlide=void 0,t.clickedIndex=void 0;return}n.slideToClickedSlide&&t.clickedIndex!==void 0&&t.clickedIndex!==t.activeIndex&&t.slideToClickedSlide()}const dS={updateSize:nS,updateSlides:iS,updateAutoHeight:rS,updateSlidesOffset:sS,updateSlidesProgress:oS,updateProgress:aS,updateSlidesClasses:lS,updateActiveIndex:uS,updateClickedSlide:fS};function hS(e=this.isHorizontal()?"x":"y"){const t=this,{params:n,rtlTranslate:i,translate:r,wrapperEl:s}=t;if(n.virtualTranslate)return i?-r:r;if(n.cssMode)return r;let o=GM(s,e);return i&&(o=-o),o||0}function pS(e,t){const n=this,{rtlTranslate:i,params:r,wrapperEl:s,progress:o}=n;let a=0,l=0;const c=0;n.isHorizontal()?a=i?-e:e:l=e,r.roundLengths&&(a=Math.floor(a),l=Math.floor(l)),r.cssMode?s[n.isHorizontal()?"scrollLeft":"scrollTop"]=n.isHorizontal()?-a:-l:r.virtualTranslate||(s.style.transform=`translate3d(${a}px, ${l}px, ${c}px)`),n.previousTranslate=n.translate,n.translate=n.isHorizontal()?a:l;let f;const u=n.maxTranslate()-n.minTranslate();u===0?f=0:f=(e-n.minTranslate())/u,f!==o&&n.updateProgress(e),n.emit("setTranslate",n.translate,t)}function mS(){return-this.snapGrid[0]}function gS(){return-this.snapGrid[this.snapGrid.length-1]}function vS(e=0,t=this.params.speed,n=!0,i=!0,r){const s=this,{params:o,wrapperEl:a}=s;if(s.animating&&o.preventInteractionOnTransition)return!1;const l=s.minTranslate(),c=s.maxTranslate();let f;if(i&&e>l?f=l:i&&e<c?f=c:f=e,s.updateProgress(f),o.cssMode){const u=s.isHorizontal();if(t===0)a[u?"scrollLeft":"scrollTop"]=-f;else{if(!s.support.smoothScroll)return Ap({swiper:s,targetPosition:-f,side:u?"left":"top"}),!0;a.scrollTo({[u?"left":"top"]:-f,behavior:"smooth"})}return!0}return t===0?(s.setTransition(0),s.setTranslate(f),n&&(s.emit("beforeTransitionStart",t,r),s.emit("transitionEnd"))):(s.setTransition(t),s.setTranslate(f),n&&(s.emit("beforeTransitionStart",t,r),s.emit("transitionStart")),s.animating||(s.animating=!0,s.onTranslateToWrapperTransitionEnd||(s.onTranslateToWrapperTransitionEnd=function(d){!s||s.destroyed||d.target===this&&(s.wrapperEl.removeEventListener("transitionend",s.onTranslateToWrapperTransitionEnd),s.onTranslateToWrapperTransitionEnd=null,delete s.onTranslateToWrapperTransitionEnd,n&&s.emit("transitionEnd"))}),s.wrapperEl.addEventListener("transitionend",s.onTranslateToWrapperTransitionEnd))),!0}const yS={getTranslate:hS,setTranslate:pS,minTranslate:mS,maxTranslate:gS,translateTo:vS};function xS(e,t){const n=this;n.params.cssMode||(n.wrapperEl.style.transitionDuration=`${e}ms`),n.emit("setTransition",e,t)}function Pp({swiper:e,runCallbacks:t,direction:n,step:i}){const{activeIndex:r,previousIndex:s}=e;let o=n;if(o||(r>s?o="next":r<s?o="prev":o="reset"),e.emit(`transition${i}`),t&&r!==s){if(o==="reset"){e.emit(`slideResetTransition${i}`);return}e.emit(`slideChangeTransition${i}`),o==="next"?e.emit(`slideNextTransition${i}`):e.emit(`slidePrevTransition${i}`)}}function _S(e=!0,t){const n=this,{params:i}=n;i.cssMode||(i.autoHeight&&n.updateAutoHeight(),Pp({swiper:n,runCallbacks:e,direction:t,step:"Start"}))}function bS(e=!0,t){const n=this,{params:i}=n;n.animating=!1,!i.cssMode&&(n.setTransition(0),Pp({swiper:n,runCallbacks:e,direction:t,step:"End"}))}const wS={setTransition:xS,transitionStart:_S,transitionEnd:bS};function MS(e=0,t=this.params.speed,n=!0,i,r){typeof e=="string"&&(e=parseInt(e,10));const s=this;let o=e;o<0&&(o=0);const{params:a,snapGrid:l,slidesGrid:c,previousIndex:f,activeIndex:u,rtlTranslate:d,wrapperEl:h,enabled:p}=s;if(s.animating&&a.preventInteractionOnTransition||!p&&!i&&!r)return!1;const v=Math.min(s.params.slidesPerGroupSkip,o);let y=v+Math.floor((o-v)/s.params.slidesPerGroup);y>=l.length&&(y=l.length-1);const m=-l[y];if(a.normalizeSlideIndex)for(let T=0;T<c.length;T+=1){const P=-Math.floor(m*100),A=Math.floor(c[T]*100),M=Math.floor(c[T+1]*100);typeof c[T+1]<"u"?P>=A&&P<M-(M-A)/2?o=T:P>=A&&P<M&&(o=T+1):P>=A&&(o=T)}if(s.initialized&&o!==u&&(!s.allowSlideNext&&m<s.translate&&m<s.minTranslate()||!s.allowSlidePrev&&m>s.translate&&m>s.maxTranslate()&&(u||0)!==o))return!1;o!==(f||0)&&n&&s.emit("beforeSlideChangeStart"),s.updateProgress(m);let g;if(o>u?g="next":o<u?g="prev":g="reset",d&&-m===s.translate||!d&&m===s.translate)return s.updateActiveIndex(o),a.autoHeight&&s.updateAutoHeight(),s.updateSlidesClasses(),a.effect!=="slide"&&s.setTranslate(m),g!=="reset"&&(s.transitionStart(n,g),s.transitionEnd(n,g)),!1;if(a.cssMode){const T=s.isHorizontal(),P=d?m:-m;if(t===0){const A=s.virtual&&s.params.virtual.enabled;A&&(s.wrapperEl.style.scrollSnapType="none",s._immediateVirtual=!0),A&&!s._cssModeVirtualInitialSet&&s.params.initialSlide>0?(s._cssModeVirtualInitialSet=!0,requestAnimationFrame(()=>{h[T?"scrollLeft":"scrollTop"]=P})):h[T?"scrollLeft":"scrollTop"]=P,A&&requestAnimationFrame(()=>{s.wrapperEl.style.scrollSnapType="",s._immediateVirtual=!1})}else{if(!s.support.smoothScroll)return Ap({swiper:s,targetPosition:P,side:T?"left":"top"}),!0;h.scrollTo({[T?"left":"top"]:P,behavior:"smooth"})}return!0}return s.setTransition(t),s.setTranslate(m),s.updateActiveIndex(o),s.updateSlidesClasses(),s.emit("beforeTransitionStart",t,i),s.transitionStart(n,g),t===0?s.transitionEnd(n,g):s.animating||(s.animating=!0,s.onSlideToWrapperTransitionEnd||(s.onSlideToWrapperTransitionEnd=function(P){!s||s.destroyed||P.target===this&&(s.wrapperEl.removeEventListener("transitionend",s.onSlideToWrapperTransitionEnd),s.onSlideToWrapperTransitionEnd=null,delete s.onSlideToWrapperTransitionEnd,s.transitionEnd(n,g))}),s.wrapperEl.addEventListener("transitionend",s.onSlideToWrapperTransitionEnd)),!0}function SS(e=0,t=this.params.speed,n=!0,i){typeof e=="string"&&(e=parseInt(e,10));const r=this;let s=e;return r.params.loop&&(r.virtual&&r.params.virtual.enabled?s=s+r.virtual.slidesBefore:s=r.getSlideIndexByData(s)),r.slideTo(s,t,n,i)}function TS(e=this.params.speed,t=!0,n){const i=this,{enabled:r,params:s,animating:o}=i;if(!r)return i;let a=s.slidesPerGroup;s.slidesPerView==="auto"&&s.slidesPerGroup===1&&s.slidesPerGroupAuto&&(a=Math.max(i.slidesPerViewDynamic("current",!0),1));const l=i.activeIndex<s.slidesPerGroupSkip?1:a,c=i.virtual&&s.virtual.enabled;if(s.loop){if(o&&!c&&s.loopPreventsSliding)return!1;i.loopFix({direction:"next"}),i._clientLeft=i.wrapperEl.clientLeft}return s.rewind&&i.isEnd?i.slideTo(0,e,t,n):i.slideTo(i.activeIndex+l,e,t,n)}function ES(e=this.params.speed,t=!0,n){const i=this,{params:r,snapGrid:s,slidesGrid:o,rtlTranslate:a,enabled:l,animating:c}=i;if(!l)return i;const f=i.virtual&&r.virtual.enabled;if(r.loop){if(c&&!f&&r.loopPreventsSliding)return!1;i.loopFix({direction:"prev"}),i._clientLeft=i.wrapperEl.clientLeft}const u=a?i.translate:-i.translate;function d(m){return m<0?-Math.floor(Math.abs(m)):Math.floor(m)}const h=d(u),p=s.map(m=>d(m));let v=s[p.indexOf(h)-1];if(typeof v>"u"&&r.cssMode){let m;s.forEach((g,T)=>{h>=g&&(m=T)}),typeof m<"u"&&(v=s[m>0?m-1:m])}let y=0;if(typeof v<"u"&&(y=o.indexOf(v),y<0&&(y=i.activeIndex-1),r.slidesPerView==="auto"&&r.slidesPerGroup===1&&r.slidesPerGroupAuto&&(y=y-i.slidesPerViewDynamic("previous",!0)+1,y=Math.max(y,0))),r.rewind&&i.isBeginning){const m=i.params.virtual&&i.params.virtual.enabled&&i.virtual?i.virtual.slides.length-1:i.slides.length-1;return i.slideTo(m,e,t,n)}return i.slideTo(y,e,t,n)}function AS(e=this.params.speed,t=!0,n){const i=this;return i.slideTo(i.activeIndex,e,t,n)}function LS(e=this.params.speed,t=!0,n,i=.5){const r=this;let s=r.activeIndex;const o=Math.min(r.params.slidesPerGroupSkip,s),a=o+Math.floor((s-o)/r.params.slidesPerGroup),l=r.rtlTranslate?r.translate:-r.translate;if(l>=r.snapGrid[a]){const c=r.snapGrid[a],f=r.snapGrid[a+1];l-c>(f-c)*i&&(s+=r.params.slidesPerGroup)}else{const c=r.snapGrid[a-1],f=r.snapGrid[a];l-c<=(f-c)*i&&(s-=r.params.slidesPerGroup)}return s=Math.max(s,0),s=Math.min(s,r.slidesGrid.length-1),r.slideTo(s,e,t,n)}function CS(){const e=this,{params:t,slidesEl:n}=e,i=t.slidesPerView==="auto"?e.slidesPerViewDynamic():t.slidesPerView;let r=e.clickedIndex,s;const o=e.isElement?"swiper-slide":`.${t.slideClass}`;if(t.loop){if(e.animating)return;s=parseInt(e.clickedSlide.getAttribute("data-swiper-slide-index"),10),t.centeredSlides?r<e.loopedSlides-i/2||r>e.slides.length-e.loopedSlides+i/2?(e.loopFix(),r=e.getSlideIndex(zn(n,`${o}[data-swiper-slide-index="${s}"]`)[0]),kc(()=>{e.slideTo(r)})):e.slideTo(r):r>e.slides.length-i?(e.loopFix(),r=e.getSlideIndex(zn(n,`${o}[data-swiper-slide-index="${s}"]`)[0]),kc(()=>{e.slideTo(r)})):e.slideTo(r)}else e.slideTo(r)}const PS={slideTo:MS,slideToLoop:SS,slideNext:TS,slidePrev:ES,slideReset:AS,slideToClosest:LS,slideToClickedSlide:CS};function RS(e){const t=this,{params:n,slidesEl:i}=t;if(!n.loop||t.virtual&&t.params.virtual.enabled)return;zn(i,`.${n.slideClass}, swiper-slide`).forEach((s,o)=>{s.setAttribute("data-swiper-slide-index",o)}),t.loopFix({slideRealIndex:e,direction:n.centeredSlides?void 0:"next"})}function IS({slideRealIndex:e,slideTo:t=!0,direction:n,setTranslate:i,activeSlideIndex:r,byController:s,byMousewheel:o}={}){const a=this;if(!a.params.loop)return;a.emit("beforeLoopFix");const{slides:l,allowSlidePrev:c,allowSlideNext:f,slidesEl:u,params:d}=a;if(a.allowSlidePrev=!0,a.allowSlideNext=!0,a.virtual&&d.virtual.enabled){t&&(!d.centeredSlides&&a.snapIndex===0?a.slideTo(a.virtual.slides.length,0,!1,!0):d.centeredSlides&&a.snapIndex<d.slidesPerView?a.slideTo(a.virtual.slides.length+a.snapIndex,0,!1,!0):a.snapIndex===a.snapGrid.length-1&&a.slideTo(a.virtual.slidesBefore,0,!1,!0)),a.allowSlidePrev=c,a.allowSlideNext=f,a.emit("loopFix");return}const h=d.slidesPerView==="auto"?a.slidesPerViewDynamic():Math.ceil(parseFloat(d.slidesPerView,10));let p=d.loopedSlides||h;p%d.slidesPerGroup!==0&&(p+=d.slidesPerGroup-p%d.slidesPerGroup),a.loopedSlides=p;const v=[],y=[];let m=a.activeIndex;typeof r>"u"?r=a.getSlideIndex(a.slides.filter(M=>M.classList.contains(d.slideActiveClass))[0]):m=r;const g=n==="next"||!n,T=n==="prev"||!n;let P=0,A=0;if(r<p){P=Math.max(p-r,d.slidesPerGroup);for(let M=0;M<p-r;M+=1){const N=M-Math.floor(M/l.length)*l.length;v.push(l.length-N-1)}}else if(r>a.slides.length-p*2){A=Math.max(r-(a.slides.length-p*2),d.slidesPerGroup);for(let M=0;M<A;M+=1){const N=M-Math.floor(M/l.length)*l.length;y.push(N)}}if(T&&v.forEach(M=>{u.prepend(a.slides[M])}),g&&y.forEach(M=>{u.append(a.slides[M])}),a.recalcSlides(),d.watchSlidesProgress&&a.updateSlidesOffset(),t){if(v.length>0&&T)if(typeof e>"u"){const M=a.slidesGrid[m],B=a.slidesGrid[m+P]-M;o?a.setTranslate(a.translate-B):(a.slideTo(m+P,0,!1,!0),i&&(a.touches[a.isHorizontal()?"startX":"startY"]+=B))}else i&&a.slideToLoop(e,0,!1,!0);else if(y.length>0&&g)if(typeof e>"u"){const M=a.slidesGrid[m],B=a.slidesGrid[m-A]-M;o?a.setTranslate(a.translate-B):(a.slideTo(m-A,0,!1,!0),i&&(a.touches[a.isHorizontal()?"startX":"startY"]+=B))}else a.slideToLoop(e,0,!1,!0)}if(a.allowSlidePrev=c,a.allowSlideNext=f,a.controller&&a.controller.control&&!s){const M={slideRealIndex:e,slideTo:!1,direction:n,setTranslate:i,activeSlideIndex:r,byController:!0};Array.isArray(a.controller.control)?a.controller.control.forEach(N=>{!N.destroyed&&N.params.loop&&N.loopFix(M)}):a.controller.control instanceof a.constructor&&a.controller.control.params.loop&&a.controller.control.loopFix(M)}a.emit("loopFix")}function OS(){const e=this,{params:t,slidesEl:n}=e;if(!t.loop||e.virtual&&e.params.virtual.enabled)return;e.recalcSlides();const i=[];e.slides.forEach(r=>{const s=typeof r.swiperSlideIndex>"u"?r.getAttribute("data-swiper-slide-index")*1:r.swiperSlideIndex;i[s]=r}),e.slides.forEach(r=>{r.removeAttribute("data-swiper-slide-index")}),i.forEach(r=>{n.append(r)}),e.recalcSlides(),e.slideTo(e.realIndex,0)}const NS={loopCreate:RS,loopFix:IS,loopDestroy:OS};function DS(e){const t=this;if(!t.params.simulateTouch||t.params.watchOverflow&&t.isLocked||t.params.cssMode)return;const n=t.params.touchEventsTarget==="container"?t.el:t.wrapperEl;t.isElement&&(t.__preventObserver__=!0),n.style.cursor="move",n.style.cursor=e?"grabbing":"grab",t.isElement&&requestAnimationFrame(()=>{t.__preventObserver__=!1})}function FS(){const e=this;e.params.watchOverflow&&e.isLocked||e.params.cssMode||(e.isElement&&(e.__preventObserver__=!0),e[e.params.touchEventsTarget==="container"?"el":"wrapperEl"].style.cursor="",e.isElement&&requestAnimationFrame(()=>{e.__preventObserver__=!1}))}const BS={setGrabCursor:DS,unsetGrabCursor:FS};function zS(e,t=this){function n(i){if(!i||i===$i()||i===Yt())return null;i.assignedSlot&&(i=i.assignedSlot);const r=i.closest(e);return!r&&!i.getRootNode?null:r||n(i.getRootNode().host)}return n(t)}function US(e){const t=this,n=$i(),i=Yt(),r=t.touchEventsData;r.evCache.push(e);const{params:s,touches:o,enabled:a}=t;if(!a||!s.simulateTouch&&e.pointerType==="mouse"||t.animating&&s.preventInteractionOnTransition)return;!t.animating&&s.cssMode&&s.loop&&t.loopFix();let l=e;l.originalEvent&&(l=l.originalEvent);let c=l.target;if(s.touchEventsTarget==="wrapper"&&!t.wrapperEl.contains(c)||"which"in l&&l.which===3||"button"in l&&l.button>0||r.isTouched&&r.isMoved)return;const f=!!s.noSwipingClass&&s.noSwipingClass!=="",u=e.composedPath?e.composedPath():e.path;f&&l.target&&l.target.shadowRoot&&u&&(c=u[0]);const d=s.noSwipingSelector?s.noSwipingSelector:`.${s.noSwipingClass}`,h=!!(l.target&&l.target.shadowRoot);if(s.noSwiping&&(h?zS(d,c):c.closest(d))){t.allowClick=!0;return}if(s.swipeHandler&&!c.closest(s.swipeHandler))return;o.currentX=l.pageX,o.currentY=l.pageY;const p=o.currentX,v=o.currentY,y=s.edgeSwipeDetection||s.iOSEdgeSwipeDetection,m=s.edgeSwipeThreshold||s.iOSEdgeSwipeThreshold;if(y&&(p<=m||p>=i.innerWidth-m))if(y==="prevent")e.preventDefault();else return;Object.assign(r,{isTouched:!0,isMoved:!1,allowTouchCallbacks:!0,isScrolling:void 0,startMoving:void 0}),o.startX=p,o.startY=v,r.touchStartTime=eo(),t.allowClick=!0,t.updateSize(),t.swipeDirection=void 0,s.threshold>0&&(r.allowThresholdMove=!1);let g=!0;c.matches(r.focusableElements)&&(g=!1,c.nodeName==="SELECT"&&(r.isTouched=!1)),n.activeElement&&n.activeElement.matches(r.focusableElements)&&n.activeElement!==c&&n.activeElement.blur();const T=g&&t.allowTouchMove&&s.touchStartPreventDefault;(s.touchStartForcePreventDefault||T)&&!c.isContentEditable&&l.preventDefault(),t.params.freeMode&&t.params.freeMode.enabled&&t.freeMode&&t.animating&&!s.cssMode&&t.freeMode.onTouchStart(),t.emit("touchStart",l)}function HS(e){const t=$i(),n=this,i=n.touchEventsData,{params:r,touches:s,rtlTranslate:o,enabled:a}=n;if(!a||!r.simulateTouch&&e.pointerType==="mouse")return;let l=e;if(l.originalEvent&&(l=l.originalEvent),!i.isTouched){i.startMoving&&i.isScrolling&&n.emit("touchMoveOpposite",l);return}const c=i.evCache.findIndex(M=>M.pointerId===l.pointerId);c>=0&&(i.evCache[c]=l);const f=i.evCache.length>1?i.evCache[0]:l,u=f.pageX,d=f.pageY;if(l.preventedByNestedSwiper){s.startX=u,s.startY=d;return}if(!n.allowTouchMove){l.target.matches(i.focusableElements)||(n.allowClick=!1),i.isTouched&&(Object.assign(s,{startX:u,startY:d,prevX:n.touches.currentX,prevY:n.touches.currentY,currentX:u,currentY:d}),i.touchStartTime=eo());return}if(r.touchReleaseOnEdges&&!r.loop){if(n.isVertical()){if(d<s.startY&&n.translate<=n.maxTranslate()||d>s.startY&&n.translate>=n.minTranslate()){i.isTouched=!1,i.isMoved=!1;return}}else if(u<s.startX&&n.translate<=n.maxTranslate()||u>s.startX&&n.translate>=n.minTranslate())return}if(t.activeElement&&l.target===t.activeElement&&l.target.matches(i.focusableElements)){i.isMoved=!0,n.allowClick=!1;return}if(i.allowTouchCallbacks&&n.emit("touchMove",l),l.targetTouches&&l.targetTouches.length>1)return;s.currentX=u,s.currentY=d;const h=s.currentX-s.startX,p=s.currentY-s.startY;if(n.params.threshold&&Math.sqrt(h**2+p**2)<n.params.threshold)return;if(typeof i.isScrolling>"u"){let M;n.isHorizontal()&&s.currentY===s.startY||n.isVertical()&&s.currentX===s.startX?i.isScrolling=!1:h*h+p*p>=25&&(M=Math.atan2(Math.abs(p),Math.abs(h))*180/Math.PI,i.isScrolling=n.isHorizontal()?M>r.touchAngle:90-M>r.touchAngle)}if(i.isScrolling&&n.emit("touchMoveOpposite",l),typeof i.startMoving>"u"&&(s.currentX!==s.startX||s.currentY!==s.startY)&&(i.startMoving=!0),i.isScrolling||n.zoom&&n.params.zoom&&n.params.zoom.enabled&&i.evCache.length>1){i.isTouched=!1;return}if(!i.startMoving)return;n.allowClick=!1,!r.cssMode&&l.cancelable&&l.preventDefault(),r.touchMoveStopPropagation&&!r.nested&&l.stopPropagation();let v=n.isHorizontal()?h:p,y=n.isHorizontal()?s.currentX-s.previousX:s.currentY-s.previousY;r.oneWayMovement&&(v=Math.abs(v)*(o?1:-1),y=Math.abs(y)*(o?1:-1)),s.diff=v,v*=r.touchRatio,o&&(v=-v,y=-y);const m=n.touchesDirection;n.swipeDirection=v>0?"prev":"next",n.touchesDirection=y>0?"prev":"next";const g=n.params.loop&&!r.cssMode;if(!i.isMoved){if(g&&n.loopFix({direction:n.swipeDirection}),i.startTranslate=n.getTranslate(),n.setTransition(0),n.animating){const M=new window.CustomEvent("transitionend",{bubbles:!0,cancelable:!0});n.wrapperEl.dispatchEvent(M)}i.allowMomentumBounce=!1,r.grabCursor&&(n.allowSlideNext===!0||n.allowSlidePrev===!0)&&n.setGrabCursor(!0),n.emit("sliderFirstMove",l)}let T;i.isMoved&&m!==n.touchesDirection&&g&&Math.abs(v)>=1&&(n.loopFix({direction:n.swipeDirection,setTranslate:!0}),T=!0),n.emit("sliderMove",l),i.isMoved=!0,i.currentTranslate=v+i.startTranslate;let P=!0,A=r.resistanceRatio;if(r.touchReleaseOnEdges&&(A=0),v>0?(g&&!T&&i.currentTranslate>(r.centeredSlides?n.minTranslate()-n.size/2:n.minTranslate())&&n.loopFix({direction:"prev",setTranslate:!0,activeSlideIndex:0}),i.currentTranslate>n.minTranslate()&&(P=!1,r.resistance&&(i.currentTranslate=n.minTranslate()-1+(-n.minTranslate()+i.startTranslate+v)**A))):v<0&&(g&&!T&&i.currentTranslate<(r.centeredSlides?n.maxTranslate()+n.size/2:n.maxTranslate())&&n.loopFix({direction:"next",setTranslate:!0,activeSlideIndex:n.slides.length-(r.slidesPerView==="auto"?n.slidesPerViewDynamic():Math.ceil(parseFloat(r.slidesPerView,10)))}),i.currentTranslate<n.maxTranslate()&&(P=!1,r.resistance&&(i.currentTranslate=n.maxTranslate()+1-(n.maxTranslate()-i.startTranslate-v)**A))),P&&(l.preventedByNestedSwiper=!0),!n.allowSlideNext&&n.swipeDirection==="next"&&i.currentTranslate<i.startTranslate&&(i.currentTranslate=i.startTranslate),!n.allowSlidePrev&&n.swipeDirection==="prev"&&i.currentTranslate>i.startTranslate&&(i.currentTranslate=i.startTranslate),!n.allowSlidePrev&&!n.allowSlideNext&&(i.currentTranslate=i.startTranslate),r.threshold>0)if(Math.abs(v)>r.threshold||i.allowThresholdMove){if(!i.allowThresholdMove){i.allowThresholdMove=!0,s.startX=s.currentX,s.startY=s.currentY,i.currentTranslate=i.startTranslate,s.diff=n.isHorizontal()?s.currentX-s.startX:s.currentY-s.startY;return}}else{i.currentTranslate=i.startTranslate;return}!r.followFinger||r.cssMode||((r.freeMode&&r.freeMode.enabled&&n.freeMode||r.watchSlidesProgress)&&(n.updateActiveIndex(),n.updateSlidesClasses()),n.params.freeMode&&r.freeMode.enabled&&n.freeMode&&n.freeMode.onTouchMove(),n.updateProgress(i.currentTranslate),n.setTranslate(i.currentTranslate))}function kS(e){const t=this,n=t.touchEventsData,i=n.evCache.findIndex(T=>T.pointerId===e.pointerId);if(i>=0&&n.evCache.splice(i,1),["pointercancel","pointerout","pointerleave"].includes(e.type)&&!(e.type==="pointercancel"&&(t.browser.isSafari||t.browser.isWebView)))return;const{params:r,touches:s,rtlTranslate:o,slidesGrid:a,enabled:l}=t;if(!l||!r.simulateTouch&&e.pointerType==="mouse")return;let c=e;if(c.originalEvent&&(c=c.originalEvent),n.allowTouchCallbacks&&t.emit("touchEnd",c),n.allowTouchCallbacks=!1,!n.isTouched){n.isMoved&&r.grabCursor&&t.setGrabCursor(!1),n.isMoved=!1,n.startMoving=!1;return}r.grabCursor&&n.isMoved&&n.isTouched&&(t.allowSlideNext===!0||t.allowSlidePrev===!0)&&t.setGrabCursor(!1);const f=eo(),u=f-n.touchStartTime;if(t.allowClick){const T=c.path||c.composedPath&&c.composedPath();t.updateClickedSlide(T&&T[0]||c.target),t.emit("tap click",c),u<300&&f-n.lastClickTime<300&&t.emit("doubleTap doubleClick",c)}if(n.lastClickTime=eo(),kc(()=>{t.destroyed||(t.allowClick=!0)}),!n.isTouched||!n.isMoved||!t.swipeDirection||s.diff===0||n.currentTranslate===n.startTranslate){n.isTouched=!1,n.isMoved=!1,n.startMoving=!1;return}n.isTouched=!1,n.isMoved=!1,n.startMoving=!1;let d;if(r.followFinger?d=o?t.translate:-t.translate:d=-n.currentTranslate,r.cssMode)return;if(t.params.freeMode&&r.freeMode.enabled){t.freeMode.onTouchEnd({currentPos:d});return}let h=0,p=t.slidesSizesGrid[0];for(let T=0;T<a.length;T+=T<r.slidesPerGroupSkip?1:r.slidesPerGroup){const P=T<r.slidesPerGroupSkip-1?1:r.slidesPerGroup;typeof a[T+P]<"u"?d>=a[T]&&d<a[T+P]&&(h=T,p=a[T+P]-a[T]):d>=a[T]&&(h=T,p=a[a.length-1]-a[a.length-2])}let v=null,y=null;r.rewind&&(t.isBeginning?y=t.params.virtual&&t.params.virtual.enabled&&t.virtual?t.virtual.slides.length-1:t.slides.length-1:t.isEnd&&(v=0));const m=(d-a[h])/p,g=h<r.slidesPerGroupSkip-1?1:r.slidesPerGroup;if(u>r.longSwipesMs){if(!r.longSwipes){t.slideTo(t.activeIndex);return}t.swipeDirection==="next"&&(m>=r.longSwipesRatio?t.slideTo(r.rewind&&t.isEnd?v:h+g):t.slideTo(h)),t.swipeDirection==="prev"&&(m>1-r.longSwipesRatio?t.slideTo(h+g):y!==null&&m<0&&Math.abs(m)>r.longSwipesRatio?t.slideTo(y):t.slideTo(h))}else{if(!r.shortSwipes){t.slideTo(t.activeIndex);return}t.navigation&&(c.target===t.navigation.nextEl||c.target===t.navigation.prevEl)?c.target===t.navigation.nextEl?t.slideTo(h+g):t.slideTo(h):(t.swipeDirection==="next"&&t.slideTo(v!==null?v:h+g),t.swipeDirection==="prev"&&t.slideTo(y!==null?y:h))}}let Dd;function Fd(){const e=this,{params:t,el:n}=e;if(n&&n.offsetWidth===0)return;t.breakpoints&&e.setBreakpoint();const{allowSlideNext:i,allowSlidePrev:r,snapGrid:s}=e,o=e.virtual&&e.params.virtual.enabled;e.allowSlideNext=!0,e.allowSlidePrev=!0,e.updateSize(),e.updateSlides(),e.updateSlidesClasses();const a=o&&t.loop;(t.slidesPerView==="auto"||t.slidesPerView>1)&&e.isEnd&&!e.isBeginning&&!e.params.centeredSlides&&!a?e.slideTo(e.slides.length-1,0,!1,!0):e.params.loop&&!o?e.slideToLoop(e.realIndex,0,!1,!0):e.slideTo(e.activeIndex,0,!1,!0),e.autoplay&&e.autoplay.running&&e.autoplay.paused&&(clearTimeout(Dd),Dd=setTimeout(()=>{e.autoplay&&e.autoplay.running&&e.autoplay.paused&&e.autoplay.resume()},500)),e.allowSlidePrev=r,e.allowSlideNext=i,e.params.watchOverflow&&s!==e.snapGrid&&e.checkOverflow()}function GS(e){const t=this;!t.enabled||t.allowClick||(t.params.preventClicks&&e.preventDefault(),t.params.preventClicksPropagation&&t.animating&&(e.stopPropagation(),e.stopImmediatePropagation()))}function VS(){const e=this,{wrapperEl:t,rtlTranslate:n,enabled:i}=e;if(!i)return;e.previousTranslate=e.translate,e.isHorizontal()?e.translate=-t.scrollLeft:e.translate=-t.scrollTop,e.translate===0&&(e.translate=0),e.updateActiveIndex(),e.updateSlidesClasses();let r;const s=e.maxTranslate()-e.minTranslate();s===0?r=0:r=(e.translate-e.minTranslate())/s,r!==e.progress&&e.updateProgress(n?-e.translate:e.translate),e.emit("setTranslate",e.translate,!1)}const sa=(e,t)=>{if(!e||e.destroyed||!e.params)return;const n=()=>e.isElement?"swiper-slide":`.${e.params.slideClass}`,i=t.closest(n());if(i){const r=i.querySelector(`.${e.params.lazyPreloaderClass}`);r&&r.remove()}};function WS(e){const t=this;sa(t,e.target),t.update()}let Bd=!1;function jS(){}const Rp=(e,t)=>{const n=$i(),{params:i,el:r,wrapperEl:s,device:o}=e,a=!!i.nested,l=t==="on"?"addEventListener":"removeEventListener",c=t;r[l]("pointerdown",e.onTouchStart,{passive:!1}),n[l]("pointermove",e.onTouchMove,{passive:!1,capture:a}),n[l]("pointerup",e.onTouchEnd,{passive:!0}),n[l]("pointercancel",e.onTouchEnd,{passive:!0}),n[l]("pointerout",e.onTouchEnd,{passive:!0}),n[l]("pointerleave",e.onTouchEnd,{passive:!0}),(i.preventClicks||i.preventClicksPropagation)&&r[l]("click",e.onClick,!0),i.cssMode&&s[l]("scroll",e.onScroll),i.updateOnWindowResize?e[c](o.ios||o.android?"resize orientationchange observerUpdate":"resize observerUpdate",Fd,!0):e[c]("observerUpdate",Fd,!0),r[l]("load",e.onLoad,{capture:!0})};function qS(){const e=this,t=$i(),{params:n}=e;e.onTouchStart=US.bind(e),e.onTouchMove=HS.bind(e),e.onTouchEnd=kS.bind(e),n.cssMode&&(e.onScroll=VS.bind(e)),e.onClick=GS.bind(e),e.onLoad=WS.bind(e),Bd||(t.addEventListener("touchstart",jS),Bd=!0),Rp(e,"on")}function XS(){Rp(this,"off")}const YS={attachEvents:qS,detachEvents:XS},zd=(e,t)=>e.grid&&t.grid&&t.grid.rows>1;function JS(){const e=this,{realIndex:t,initialized:n,params:i,el:r}=e,s=i.breakpoints;if(!s||s&&Object.keys(s).length===0)return;const o=e.getBreakpoint(s,e.params.breakpointsBase,e.el);if(!o||e.currentBreakpoint===o)return;const l=(o in s?s[o]:void 0)||e.originalParams,c=zd(e,i),f=zd(e,l),u=i.enabled;c&&!f?(r.classList.remove(`${i.containerModifierClass}grid`,`${i.containerModifierClass}grid-column`),e.emitContainerClasses()):!c&&f&&(r.classList.add(`${i.containerModifierClass}grid`),(l.grid.fill&&l.grid.fill==="column"||!l.grid.fill&&i.grid.fill==="column")&&r.classList.add(`${i.containerModifierClass}grid-column`),e.emitContainerClasses()),["navigation","pagination","scrollbar"].forEach(v=>{const y=i[v]&&i[v].enabled,m=l[v]&&l[v].enabled;y&&!m&&e[v].disable(),!y&&m&&e[v].enable()});const d=l.direction&&l.direction!==i.direction,h=i.loop&&(l.slidesPerView!==i.slidesPerView||d);d&&n&&e.changeDirection(),Ut(e.params,l);const p=e.params.enabled;Object.assign(e,{allowTouchMove:e.params.allowTouchMove,allowSlideNext:e.params.allowSlideNext,allowSlidePrev:e.params.allowSlidePrev}),u&&!p?e.disable():!u&&p&&e.enable(),e.currentBreakpoint=o,e.emit("_beforeBreakpoint",l),h&&n&&(e.loopDestroy(),e.loopCreate(t),e.updateSlides()),e.emit("breakpoint",l)}function ZS(e,t="window",n){if(!e||t==="container"&&!n)return;let i=!1;const r=Yt(),s=t==="window"?r.innerHeight:n.clientHeight,o=Object.keys(e).map(a=>{if(typeof a=="string"&&a.indexOf("@")===0){const l=parseFloat(a.substr(1));return{value:s*l,point:a}}return{value:a,point:a}});o.sort((a,l)=>parseInt(a.value,10)-parseInt(l.value,10));for(let a=0;a<o.length;a+=1){const{point:l,value:c}=o[a];t==="window"?r.matchMedia(`(min-width: ${c}px)`).matches&&(i=l):c<=n.clientWidth&&(i=l)}return i||"max"}const $S={setBreakpoint:JS,getBreakpoint:ZS};function KS(e,t){const n=[];return e.forEach(i=>{typeof i=="object"?Object.keys(i).forEach(r=>{i[r]&&n.push(t+r)}):typeof i=="string"&&n.push(t+i)}),n}function QS(){const e=this,{classNames:t,params:n,rtl:i,el:r,device:s}=e,o=KS(["initialized",n.direction,{"free-mode":e.params.freeMode&&n.freeMode.enabled},{autoheight:n.autoHeight},{rtl:i},{grid:n.grid&&n.grid.rows>1},{"grid-column":n.grid&&n.grid.rows>1&&n.grid.fill==="column"},{android:s.android},{ios:s.ios},{"css-mode":n.cssMode},{centered:n.cssMode&&n.centeredSlides},{"watch-progress":n.watchSlidesProgress}],n.containerModifierClass);t.push(...o),r.classList.add(...t),e.emitContainerClasses()}function eT(){const e=this,{el:t,classNames:n}=e;t.classList.remove(...n),e.emitContainerClasses()}const tT={addClasses:QS,removeClasses:eT};function nT(){const e=this,{isLocked:t,params:n}=e,{slidesOffsetBefore:i}=n;if(i){const r=e.slides.length-1,s=e.slidesGrid[r]+e.slidesSizesGrid[r]+i*2;e.isLocked=e.size>s}else e.isLocked=e.snapGrid.length===1;n.allowSlideNext===!0&&(e.allowSlideNext=!e.isLocked),n.allowSlidePrev===!0&&(e.allowSlidePrev=!e.isLocked),t&&t!==e.isLocked&&(e.isEnd=!1),t!==e.isLocked&&e.emit(e.isLocked?"lock":"unlock")}const iT={checkOverflow:nT},Ud={init:!0,direction:"horizontal",oneWayMovement:!1,touchEventsTarget:"wrapper",initialSlide:0,speed:300,cssMode:!1,updateOnWindowResize:!0,resizeObserver:!0,nested:!1,createElements:!1,enabled:!0,focusableElements:"input, select, option, textarea, button, video, label",width:null,height:null,preventInteractionOnTransition:!1,userAgent:null,url:null,edgeSwipeDetection:!1,edgeSwipeThreshold:20,autoHeight:!1,setWrapperSize:!1,virtualTranslate:!1,effect:"slide",breakpoints:void 0,breakpointsBase:"window",spaceBetween:0,slidesPerView:1,slidesPerGroup:1,slidesPerGroupSkip:0,slidesPerGroupAuto:!1,centeredSlides:!1,centeredSlidesBounds:!1,slidesOffsetBefore:0,slidesOffsetAfter:0,normalizeSlideIndex:!0,centerInsufficientSlides:!1,watchOverflow:!0,roundLengths:!1,touchRatio:1,touchAngle:45,simulateTouch:!0,shortSwipes:!0,longSwipes:!0,longSwipesRatio:.5,longSwipesMs:300,followFinger:!0,allowTouchMove:!0,threshold:5,touchMoveStopPropagation:!1,touchStartPreventDefault:!0,touchStartForcePreventDefault:!1,touchReleaseOnEdges:!1,uniqueNavElements:!0,resistance:!0,resistanceRatio:.85,watchSlidesProgress:!1,grabCursor:!1,preventClicks:!0,preventClicksPropagation:!0,slideToClickedSlide:!1,loop:!1,loopedSlides:null,loopPreventsSliding:!0,rewind:!1,allowSlidePrev:!0,allowSlideNext:!0,swipeHandler:null,noSwiping:!0,noSwipingClass:"swiper-no-swiping",noSwipingSelector:null,passiveListeners:!0,maxBackfaceHiddenSlides:10,containerModifierClass:"swiper-",slideClass:"swiper-slide",slideActiveClass:"swiper-slide-active",slideVisibleClass:"swiper-slide-visible",slideNextClass:"swiper-slide-next",slidePrevClass:"swiper-slide-prev",wrapperClass:"swiper-wrapper",lazyPreloaderClass:"swiper-lazy-preloader",runCallbacksOnInit:!0,_emitClasses:!1};function rT(e,t){return function(i={}){const r=Object.keys(i)[0],s=i[r];if(typeof s!="object"||s===null){Ut(t,i);return}if(["navigation","pagination","scrollbar"].indexOf(r)>=0&&e[r]===!0&&(e[r]={auto:!0}),!(r in e&&"enabled"in s)){Ut(t,i);return}e[r]===!0&&(e[r]={enabled:!0}),typeof e[r]=="object"&&!("enabled"in e[r])&&(e[r].enabled=!0),e[r]||(e[r]={enabled:!1}),Ut(t,i)}}const Ul={eventsEmitter:tS,update:dS,translate:yS,transition:wS,slide:PS,loop:NS,grabCursor:BS,events:YS,breakpoints:$S,checkOverflow:iT,classes:tT},Hl={};class Lt{constructor(...t){let n,i;t.length===1&&t[0].constructor&&Object.prototype.toString.call(t[0]).slice(8,-1)==="Object"?i=t[0]:[n,i]=t,i||(i={}),i=Ut({},i),n&&!i.el&&(i.el=n);const r=$i();if(i.el&&typeof i.el=="string"&&r.querySelectorAll(i.el).length>1){const l=[];return r.querySelectorAll(i.el).forEach(c=>{const f=Ut({},i,{el:c});l.push(new Lt(f))}),l}const s=this;s.__swiper__=!0,s.support=Cp(),s.device=ZM({userAgent:i.userAgent}),s.browser=KM(),s.eventsListeners={},s.eventsAnyListeners=[],s.modules=[...s.__modules__],i.modules&&Array.isArray(i.modules)&&s.modules.push(...i.modules);const o={};s.modules.forEach(l=>{l({params:i,swiper:s,extendParams:rT(i,o),on:s.on.bind(s),once:s.once.bind(s),off:s.off.bind(s),emit:s.emit.bind(s)})});const a=Ut({},Ud,o);return s.params=Ut({},a,Hl,i),s.originalParams=Ut({},s.params),s.passedParams=Ut({},i),s.params&&s.params.on&&Object.keys(s.params.on).forEach(l=>{s.on(l,s.params.on[l])}),s.params&&s.params.onAny&&s.onAny(s.params.onAny),Object.assign(s,{enabled:s.params.enabled,el:n,classNames:[],slides:[],slidesGrid:[],snapGrid:[],slidesSizesGrid:[],isHorizontal(){return s.params.direction==="horizontal"},isVertical(){return s.params.direction==="vertical"},activeIndex:0,realIndex:0,isBeginning:!0,isEnd:!1,translate:0,previousTranslate:0,progress:0,velocity:0,animating:!1,allowSlideNext:s.params.allowSlideNext,allowSlidePrev:s.params.allowSlidePrev,touchEventsData:{isTouched:void 0,isMoved:void 0,allowTouchCallbacks:void 0,touchStartTime:void 0,isScrolling:void 0,currentTranslate:void 0,startTranslate:void 0,allowThresholdMove:void 0,focusableElements:s.params.focusableElements,lastClickTime:eo(),clickTimeout:void 0,velocities:[],allowMomentumBounce:void 0,startMoving:void 0,evCache:[]},allowClick:!0,allowTouchMove:s.params.allowTouchMove,touches:{startX:0,startY:0,currentX:0,currentY:0,diff:0},imagesToLoad:[],imagesLoaded:0}),s.emit("_swiper"),s.params.init&&s.init(),s}getSlideIndex(t){const{slidesEl:n,params:i}=this,r=zn(n,`.${i.slideClass}, swiper-slide`),s=Od(r[0]);return Od(t)-s}getSlideIndexByData(t){return this.getSlideIndex(this.slides.filter(n=>n.getAttribute("data-swiper-slide-index")*1===t)[0])}recalcSlides(){const t=this,{slidesEl:n,params:i}=t;t.slides=zn(n,`.${i.slideClass}, swiper-slide`)}enable(){const t=this;t.enabled||(t.enabled=!0,t.params.grabCursor&&t.setGrabCursor(),t.emit("enable"))}disable(){const t=this;!t.enabled||(t.enabled=!1,t.params.grabCursor&&t.unsetGrabCursor(),t.emit("disable"))}setProgress(t,n){const i=this;t=Math.min(Math.max(t,0),1);const r=i.minTranslate(),o=(i.maxTranslate()-r)*t+r;i.translateTo(o,typeof n>"u"?0:n),i.updateActiveIndex(),i.updateSlidesClasses()}emitContainerClasses(){const t=this;if(!t.params._emitClasses||!t.el)return;const n=t.el.className.split(" ").filter(i=>i.indexOf("swiper")===0||i.indexOf(t.params.containerModifierClass)===0);t.emit("_containerClasses",n.join(" "))}getSlideClasses(t){const n=this;return n.destroyed?"":t.className.split(" ").filter(i=>i.indexOf("swiper-slide")===0||i.indexOf(n.params.slideClass)===0).join(" ")}emitSlidesClasses(){const t=this;if(!t.params._emitClasses||!t.el)return;const n=[];t.slides.forEach(i=>{const r=t.getSlideClasses(i);n.push({slideEl:i,classNames:r}),t.emit("_slideClass",i,r)}),t.emit("_slideClasses",n)}slidesPerViewDynamic(t="current",n=!1){const i=this,{params:r,slides:s,slidesGrid:o,slidesSizesGrid:a,size:l,activeIndex:c}=i;let f=1;if(r.centeredSlides){let u=s[c].swiperSlideSize,d;for(let h=c+1;h<s.length;h+=1)s[h]&&!d&&(u+=s[h].swiperSlideSize,f+=1,u>l&&(d=!0));for(let h=c-1;h>=0;h-=1)s[h]&&!d&&(u+=s[h].swiperSlideSize,f+=1,u>l&&(d=!0))}else if(t==="current")for(let u=c+1;u<s.length;u+=1)(n?o[u]+a[u]-o[c]<l:o[u]-o[c]<l)&&(f+=1);else for(let u=c-1;u>=0;u-=1)o[c]-o[u]<l&&(f+=1);return f}update(){const t=this;if(!t||t.destroyed)return;const{snapGrid:n,params:i}=t;i.breakpoints&&t.setBreakpoint(),[...t.el.querySelectorAll('[loading="lazy"]')].forEach(o=>{o.complete&&sa(t,o)}),t.updateSize(),t.updateSlides(),t.updateProgress(),t.updateSlidesClasses();function r(){const o=t.rtlTranslate?t.translate*-1:t.translate,a=Math.min(Math.max(o,t.maxTranslate()),t.minTranslate());t.setTranslate(a),t.updateActiveIndex(),t.updateSlidesClasses()}let s;t.params.freeMode&&t.params.freeMode.enabled?(r(),t.params.autoHeight&&t.updateAutoHeight()):((t.params.slidesPerView==="auto"||t.params.slidesPerView>1)&&t.isEnd&&!t.params.centeredSlides?s=t.slideTo(t.slides.length-1,0,!1,!0):s=t.slideTo(t.activeIndex,0,!1,!0),s||r()),i.watchOverflow&&n!==t.snapGrid&&t.checkOverflow(),t.emit("update")}changeDirection(t,n=!0){const i=this,r=i.params.direction;return t||(t=r==="horizontal"?"vertical":"horizontal"),t===r||t!=="horizontal"&&t!=="vertical"||(i.el.classList.remove(`${i.params.containerModifierClass}${r}`),i.el.classList.add(`${i.params.containerModifierClass}${t}`),i.emitContainerClasses(),i.params.direction=t,i.slides.forEach(s=>{t==="vertical"?s.style.width="":s.style.height=""}),i.emit("changeDirection"),n&&i.update()),i}changeLanguageDirection(t){const n=this;n.rtl&&t==="rtl"||!n.rtl&&t==="ltr"||(n.rtl=t==="rtl",n.rtlTranslate=n.params.direction==="horizontal"&&n.rtl,n.rtl?(n.el.classList.add(`${n.params.containerModifierClass}rtl`),n.el.dir="rtl"):(n.el.classList.remove(`${n.params.containerModifierClass}rtl`),n.el.dir="ltr"),n.update())}mount(t){const n=this;if(n.mounted)return!0;let i=t||n.params.el;if(typeof i=="string"&&(i=document.querySelector(i)),!i)return!1;i.swiper=n,i.shadowEl&&(n.isElement=!0);const r=()=>`.${(n.params.wrapperClass||"").trim().split(" ").join(".")}`;let o=(()=>i&&i.shadowRoot&&i.shadowRoot.querySelector?i.shadowRoot.querySelector(r()):zn(i,r())[0])();return!o&&n.params.createElements&&(o=Lp("div",n.params.wrapperClass),i.append(o),zn(i,`.${n.params.slideClass}`).forEach(a=>{o.append(a)})),Object.assign(n,{el:i,wrapperEl:o,slidesEl:n.isElement?i:o,mounted:!0,rtl:i.dir.toLowerCase()==="rtl"||pi(i,"direction")==="rtl",rtlTranslate:n.params.direction==="horizontal"&&(i.dir.toLowerCase()==="rtl"||pi(i,"direction")==="rtl"),wrongRTL:pi(o,"display")==="-webkit-box"}),!0}init(t){const n=this;return n.initialized||n.mount(t)===!1||(n.emit("beforeInit"),n.params.breakpoints&&n.setBreakpoint(),n.addClasses(),n.updateSize(),n.updateSlides(),n.params.watchOverflow&&n.checkOverflow(),n.params.grabCursor&&n.enabled&&n.setGrabCursor(),n.params.loop&&n.virtual&&n.params.virtual.enabled?n.slideTo(n.params.initialSlide+n.virtual.slidesBefore,0,n.params.runCallbacksOnInit,!1,!0):n.slideTo(n.params.initialSlide,0,n.params.runCallbacksOnInit,!1,!0),n.params.loop&&n.loopCreate(),n.attachEvents(),[...n.el.querySelectorAll('[loading="lazy"]')].forEach(r=>{r.complete?sa(n,r):r.addEventListener("load",s=>{sa(n,s.target)})}),n.initialized=!0,n.emit("init"),n.emit("afterInit")),n}destroy(t=!0,n=!0){const i=this,{params:r,el:s,wrapperEl:o,slides:a}=i;return typeof i.params>"u"||i.destroyed||(i.emit("beforeDestroy"),i.initialized=!1,i.detachEvents(),r.loop&&i.loopDestroy(),n&&(i.removeClasses(),s.removeAttribute("style"),o.removeAttribute("style"),a&&a.length&&a.forEach(l=>{l.classList.remove(r.slideVisibleClass,r.slideActiveClass,r.slideNextClass,r.slidePrevClass),l.removeAttribute("style"),l.removeAttribute("data-swiper-slide-index")})),i.emit("destroy"),Object.keys(i.eventsListeners).forEach(l=>{i.off(l)}),t!==!1&&(i.el.swiper=null,HM(i)),i.destroyed=!0),null}static extendDefaults(t){Ut(Hl,t)}static get extendedDefaults(){return Hl}static get defaults(){return Ud}static installModule(t){Lt.prototype.__modules__||(Lt.prototype.__modules__=[]);const n=Lt.prototype.__modules__;typeof t=="function"&&n.indexOf(t)<0&&n.push(t)}static use(t){return Array.isArray(t)?(t.forEach(n=>Lt.installModule(n)),Lt):(Lt.installModule(t),Lt)}}Object.keys(Ul).forEach(e=>{Object.keys(Ul[e]).forEach(t=>{Lt.prototype[t]=Ul[e][t]})});Lt.use([QM,eS]);function sT(e){const{effect:t,swiper:n,on:i,setTranslate:r,setTransition:s,overwriteParams:o,perspective:a,recreateShadows:l,getEffectParams:c}=e;i("beforeInit",()=>{if(n.params.effect!==t)return;n.classNames.push(`${n.params.containerModifierClass}${t}`),a&&a()&&n.classNames.push(`${n.params.containerModifierClass}3d`);const u=o?o():{};Object.assign(n.params,u),Object.assign(n.originalParams,u)}),i("setTranslate",()=>{n.params.effect===t&&r()}),i("setTransition",(u,d)=>{n.params.effect===t&&s(d)}),i("transitionEnd",()=>{if(n.params.effect===t&&l){if(!c||!c().slideShadows)return;n.slides.forEach(u=>{u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(d=>d.remove())}),l()}});let f;i("virtualUpdate",()=>{n.params.effect===t&&(n.slides.length||(f=!0),requestAnimationFrame(()=>{f&&n.slides&&n.slides.length&&(r(),f=!1)}))})}function oT(e,t){const n=wu(t);return n!==t&&(n.style.backfaceVisibility="hidden",n.style["-webkit-backface-visibility"]="hidden"),n}function aT({swiper:e,duration:t,transformElements:n,allSlides:i}){const{activeIndex:r}=e,s=o=>o.parentElement?o.parentElement:e.slides.filter(l=>l.shadowEl&&l.shadowEl===o.parentNode)[0];if(e.params.virtualTranslate&&t!==0){let o=!1,a;i?a=n:a=n.filter(l=>{const c=l.classList.contains("swiper-slide-transform")?s(l):l;return e.getSlideIndex(c)===r}),a.forEach(l=>{XM(l,()=>{if(o||!e||e.destroyed)return;o=!0,e.animating=!1;const c=new window.CustomEvent("transitionend",{bubbles:!0,cancelable:!0});e.wrapperEl.dispatchEvent(c)})})}}function lT(e,t,n){const i=`swiper-slide-shadow${n?`-${n}`:""}`,r=wu(t);let s=r.querySelector(`.${i}`);return s||(s=Lp("div",`swiper-slide-shadow${n?`-${n}`:""}`),r.append(s)),s}function cT({swiper:e,extendParams:t,on:n}){t({cardsEffect:{slideShadows:!0,rotate:!0,perSlideRotate:2,perSlideOffset:8}}),sT({effect:"cards",swiper:e,on:n,setTranslate:()=>{const{slides:s,activeIndex:o}=e,a=e.params.cardsEffect,{startTranslate:l,isTouched:c}=e.touchEventsData,f=e.translate;for(let u=0;u<s.length;u+=1){const d=s[u],h=d.progress,p=Math.min(Math.max(h,-4),4);let v=d.swiperSlideOffset;e.params.centeredSlides&&!e.params.cssMode&&(e.wrapperEl.style.transform=`translateX(${e.minTranslate()}px)`),e.params.centeredSlides&&e.params.cssMode&&(v-=s[0].swiperSlideOffset);let y=e.params.cssMode?-v-e.translate:-v,m=0;const g=-100*Math.abs(p);let T=1,P=-a.perSlideRotate*p,A=a.perSlideOffset-Math.abs(p)*.75;const M=e.virtual&&e.params.virtual.enabled?e.virtual.from+u:u,N=(M===o||M===o-1)&&p>0&&p<1&&(c||e.params.cssMode)&&f<l,B=(M===o||M===o+1)&&p<0&&p>-1&&(c||e.params.cssMode)&&f>l;if(N||B){const j=(1-Math.abs((Math.abs(p)-.5)/.5))**.5;P+=-28*p*j,T+=-.5*j,A+=96*j,m=`${-25*j*Math.abs(p)}%`}if(p<0?y=`calc(${y}px + (${A*Math.abs(p)}%))`:p>0?y=`calc(${y}px + (-${A*Math.abs(p)}%))`:y=`${y}px`,!e.isHorizontal()){const j=m;m=y,y=j}const W=p<0?`${1+(1-T)*p}`:`${1-(1-T)*p}`,te=`
        translate3d(${y}, ${m}, ${g}px)
        rotateZ(${a.rotate?P:0}deg)
        scale(${W})
      `;if(a.slideShadows){let j=d.querySelector(".swiper-slide-shadow");j||(j=lT(a,d)),j&&(j.style.opacity=Math.min(Math.max((Math.abs(p)-.5)/.5,0),1))}d.style.zIndex=-Math.abs(Math.round(h))+s.length;const H=oT(a,d);H.style.transform=te}},setTransition:s=>{const o=e.slides.map(a=>wu(a));o.forEach(a=>{a.style.transitionDuration=`${s}ms`,a.querySelectorAll(".swiper-slide-shadow").forEach(l=>{l.style.transitionDuration=`${s}ms`})}),aT({swiper:e,duration:s,transformElements:o})},perspective:()=>!0,overwriteParams:()=>({watchSlidesProgress:!0,virtualTranslate:!e.params.cssMode})})}function Ji(e){return typeof e=="object"&&e!==null&&e.constructor&&Object.prototype.toString.call(e).slice(8,-1)==="Object"}function mi(e,t){const n=["__proto__","constructor","prototype"];Object.keys(t).filter(i=>n.indexOf(i)<0).forEach(i=>{typeof e[i]>"u"?e[i]=t[i]:Ji(t[i])&&Ji(e[i])&&Object.keys(t[i]).length>0?t[i].__swiper__?e[i]=t[i]:mi(e[i],t[i]):e[i]=t[i]})}function Ip(e={}){return e.navigation&&typeof e.navigation.nextEl>"u"&&typeof e.navigation.prevEl>"u"}function Op(e={}){return e.pagination&&typeof e.pagination.el>"u"}function Np(e={}){return e.scrollbar&&typeof e.scrollbar.el>"u"}function Dp(e=""){const t=e.split(" ").map(i=>i.trim()).filter(i=>!!i),n=[];return t.forEach(i=>{n.indexOf(i)<0&&n.push(i)}),n.join(" ")}function uT(e=""){return e?e.includes("swiper-wrapper")?e:`swiper-wrapper ${e}`:"swiper-wrapper"}const Fp=["eventsPrefix","modules","init","_direction","oneWayMovement","touchEventsTarget","initialSlide","_speed","cssMode","updateOnWindowResize","resizeObserver","nested","focusableElements","_enabled","_width","_height","preventInteractionOnTransition","userAgent","url","_edgeSwipeDetection","_edgeSwipeThreshold","_freeMode","_autoHeight","setWrapperSize","virtualTranslate","_effect","breakpoints","_spaceBetween","_slidesPerView","maxBackfaceHiddenSlides","_grid","_slidesPerGroup","_slidesPerGroupSkip","_slidesPerGroupAuto","_centeredSlides","_centeredSlidesBounds","_slidesOffsetBefore","_slidesOffsetAfter","normalizeSlideIndex","_centerInsufficientSlides","_watchOverflow","roundLengths","touchRatio","touchAngle","simulateTouch","_shortSwipes","_longSwipes","longSwipesRatio","longSwipesMs","_followFinger","allowTouchMove","_threshold","touchMoveStopPropagation","touchStartPreventDefault","touchStartForcePreventDefault","touchReleaseOnEdges","uniqueNavElements","_resistance","_resistanceRatio","_watchSlidesProgress","_grabCursor","preventClicks","preventClicksPropagation","_slideToClickedSlide","_loop","loopedSlides","loopPreventsSliding","_rewind","_allowSlidePrev","_allowSlideNext","_swipeHandler","_noSwiping","noSwipingClass","noSwipingSelector","passiveListeners","containerModifierClass","slideClass","slideActiveClass","slideVisibleClass","slideNextClass","slidePrevClass","wrapperClass","lazyPreloaderClass","runCallbacksOnInit","observer","observeParents","observeSlideChildren","a11y","_autoplay","_controller","coverflowEffect","cubeEffect","fadeEffect","flipEffect","creativeEffect","cardsEffect","hashNavigation","history","keyboard","mousewheel","_navigation","_pagination","parallax","_scrollbar","_thumbs","virtual","zoom","control","injectStyles","injectStylesUrls"];function Hd(e={},t=!0){const n={on:{}},i={},r={};mi(n,Lt.defaults),mi(n,Lt.extendedDefaults),n._emitClasses=!0,n.init=!1;const s={},o=Fp.map(l=>l.replace(/_/,"")),a=Object.assign({},e);return Object.keys(a).forEach(l=>{typeof e[l]>"u"||(o.indexOf(l)>=0?Ji(e[l])?(n[l]={},r[l]={},mi(n[l],e[l]),mi(r[l],e[l])):(n[l]=e[l],r[l]=e[l]):l.search(/on[A-Z]/)===0&&typeof e[l]=="function"?t?i[`${l[2].toLowerCase()}${l.substr(3)}`]=e[l]:n.on[`${l[2].toLowerCase()}${l.substr(3)}`]=e[l]:s[l]=e[l])}),["navigation","pagination","scrollbar"].forEach(l=>{n[l]===!0&&(n[l]={}),n[l]===!1&&delete n[l]}),{params:n,passedParams:r,rest:s,events:i}}function fT({el:e,nextEl:t,prevEl:n,paginationEl:i,scrollbarEl:r,swiper:s},o){Ip(o)&&t&&n&&(s.params.navigation.nextEl=t,s.originalParams.navigation.nextEl=t,s.params.navigation.prevEl=n,s.originalParams.navigation.prevEl=n),Op(o)&&i&&(s.params.pagination.el=i,s.originalParams.pagination.el=i),Np(o)&&r&&(s.params.scrollbar.el=r,s.originalParams.scrollbar.el=r),s.init(e)}function dT(e,t,n,i,r){const s=[];if(!t)return s;const o=l=>{s.indexOf(l)<0&&s.push(l)};if(n&&i){const l=i.map(r),c=n.map(r);l.join("")!==c.join("")&&o("children"),i.length!==n.length&&o("children")}return Fp.filter(l=>l[0]==="_").map(l=>l.replace(/_/,"")).forEach(l=>{if(l in e&&l in t)if(Ji(e[l])&&Ji(t[l])){const c=Object.keys(e[l]),f=Object.keys(t[l]);c.length!==f.length?o(l):(c.forEach(u=>{e[l][u]!==t[l][u]&&o(l)}),f.forEach(u=>{e[l][u]!==t[l][u]&&o(l)}))}else e[l]!==t[l]&&o(l)}),s}function kl(e,t,n){e===void 0&&(e={});const i=[],r={"container-start":[],"container-end":[],"wrapper-start":[],"wrapper-end":[]},s=(o,a)=>{!Array.isArray(o)||o.forEach(l=>{const c=typeof l.type=="symbol";a==="default"&&(a="container-end"),c&&l.children?s(l.children,"default"):l.type&&(l.type.name==="SwiperSlide"||l.type.name==="AsyncComponentWrapper")?i.push(l):r[a]&&r[a].push(l)})};return Object.keys(e).forEach(o=>{if(typeof e[o]!="function")return;const a=e[o]();s(a,o)}),n.value=t.value,t.value=i,{slides:i,slots:r}}function hT({swiper:e,slides:t,passedParams:n,changedParams:i,nextEl:r,prevEl:s,scrollbarEl:o,paginationEl:a}){const l=i.filter(B=>B!=="children"&&B!=="direction"&&B!=="wrapperClass"),{params:c,pagination:f,navigation:u,scrollbar:d,virtual:h,thumbs:p}=e;let v,y,m,g,T,P,A,M;i.includes("thumbs")&&n.thumbs&&n.thumbs.swiper&&c.thumbs&&!c.thumbs.swiper&&(v=!0),i.includes("controller")&&n.controller&&n.controller.control&&c.controller&&!c.controller.control&&(y=!0),i.includes("pagination")&&n.pagination&&(n.pagination.el||a)&&(c.pagination||c.pagination===!1)&&f&&!f.el&&(m=!0),i.includes("scrollbar")&&n.scrollbar&&(n.scrollbar.el||o)&&(c.scrollbar||c.scrollbar===!1)&&d&&!d.el&&(g=!0),i.includes("navigation")&&n.navigation&&(n.navigation.prevEl||s)&&(n.navigation.nextEl||r)&&(c.navigation||c.navigation===!1)&&u&&!u.prevEl&&!u.nextEl&&(T=!0);const N=B=>{!e[B]||(e[B].destroy(),B==="navigation"?(e.isElement&&(e[B].prevEl.remove(),e[B].nextEl.remove()),c[B].prevEl=void 0,c[B].nextEl=void 0,e[B].prevEl=void 0,e[B].nextEl=void 0):(e.isElement&&e[B].el.remove(),c[B].el=void 0,e[B].el=void 0))};i.includes("loop")&&e.isElement&&(c.loop&&!n.loop?P=!0:!c.loop&&n.loop?A=!0:M=!0),l.forEach(B=>{if(Ji(c[B])&&Ji(n[B]))mi(c[B],n[B]);else{const W=n[B];(W===!0||W===!1)&&(B==="navigation"||B==="pagination"||B==="scrollbar")?W===!1&&N(B):c[B]=n[B]}}),l.includes("controller")&&!y&&e.controller&&e.controller.control&&c.controller&&c.controller.control&&(e.controller.control=c.controller.control),i.includes("children")&&t&&h&&c.virtual.enabled&&(h.slides=t,h.update(!0)),i.includes("children")&&t&&c.loop&&(M=!0),v&&p.init()&&p.update(!0),y&&(e.controller.control=c.controller.control),m&&(e.isElement&&(!a||typeof a=="string")&&(a=document.createElement("div"),a.classList.add("swiper-pagination"),e.el.shadowEl.appendChild(a)),a&&(c.pagination.el=a),f.init(),f.render(),f.update()),g&&(e.isElement&&(!o||typeof o=="string")&&(o=document.createElement("div"),o.classList.add("swiper-scrollbar"),e.el.shadowEl.appendChild(o)),o&&(c.scrollbar.el=o),d.init(),d.updateSize(),d.setTranslate()),T&&(e.isElement&&((!r||typeof r=="string")&&(r=document.createElement("div"),r.classList.add("swiper-button-next"),e.el.shadowEl.appendChild(r)),(!s||typeof s=="string")&&(s=document.createElement("div"),s.classList.add("swiper-button-prev"),e.el.shadowEl.appendChild(s))),r&&(c.navigation.nextEl=r),s&&(c.navigation.prevEl=s),u.init(),u.update()),i.includes("allowSlideNext")&&(e.allowSlideNext=n.allowSlideNext),i.includes("allowSlidePrev")&&(e.allowSlidePrev=n.allowSlidePrev),i.includes("direction")&&e.changeDirection(n.direction,!1),(P||M)&&e.loopDestroy(),(A||M)&&e.loopCreate(),e.update()}function pT(e,t,n){if(!n)return null;const i=f=>{let u=f;return f<0?u=t.length+f:u>=t.length&&(u=u-t.length),u},r=e.value.isHorizontal()?{[e.value.rtlTranslate?"right":"left"]:`${n.offset}px`}:{top:`${n.offset}px`},{from:s,to:o}=n,a=e.value.params.loop?-t.length:0,l=e.value.params.loop?t.length*2:t.length,c=[];for(let f=a;f<l;f+=1)f>=s&&f<=o&&c.push(t[i(f)]);return c.map(f=>(f.props||(f.props={}),f.props.style||(f.props.style={}),f.props.swiperRef=e,f.props.style=r,ln(f.type,{...f.props},f.children)))}const mT=e=>{!e||e.destroyed||!e.params.virtual||e.params.virtual&&!e.params.virtual.enabled||(e.updateSlides(),e.updateProgress(),e.updateSlidesClasses(),e.parallax&&e.params.parallax&&e.params.parallax.enabled&&e.parallax.setTranslate())},gT={name:"Swiper",props:{tag:{type:String,default:"div"},wrapperTag:{type:String,default:"div"},modules:{type:Array,default:void 0},init:{type:Boolean,default:void 0},direction:{type:String,default:void 0},oneWayMovement:{type:Boolean,default:void 0},touchEventsTarget:{type:String,default:void 0},initialSlide:{type:Number,default:void 0},speed:{type:Number,default:void 0},cssMode:{type:Boolean,default:void 0},updateOnWindowResize:{type:Boolean,default:void 0},resizeObserver:{type:Boolean,default:void 0},nested:{type:Boolean,default:void 0},focusableElements:{type:String,default:void 0},width:{type:Number,default:void 0},height:{type:Number,default:void 0},preventInteractionOnTransition:{type:Boolean,default:void 0},userAgent:{type:String,default:void 0},url:{type:String,default:void 0},edgeSwipeDetection:{type:[Boolean,String],default:void 0},edgeSwipeThreshold:{type:Number,default:void 0},autoHeight:{type:Boolean,default:void 0},setWrapperSize:{type:Boolean,default:void 0},virtualTranslate:{type:Boolean,default:void 0},effect:{type:String,default:void 0},breakpoints:{type:Object,default:void 0},spaceBetween:{type:[Number,String],default:void 0},slidesPerView:{type:[Number,String],default:void 0},maxBackfaceHiddenSlides:{type:Number,default:void 0},slidesPerGroup:{type:Number,default:void 0},slidesPerGroupSkip:{type:Number,default:void 0},slidesPerGroupAuto:{type:Boolean,default:void 0},centeredSlides:{type:Boolean,default:void 0},centeredSlidesBounds:{type:Boolean,default:void 0},slidesOffsetBefore:{type:Number,default:void 0},slidesOffsetAfter:{type:Number,default:void 0},normalizeSlideIndex:{type:Boolean,default:void 0},centerInsufficientSlides:{type:Boolean,default:void 0},watchOverflow:{type:Boolean,default:void 0},roundLengths:{type:Boolean,default:void 0},touchRatio:{type:Number,default:void 0},touchAngle:{type:Number,default:void 0},simulateTouch:{type:Boolean,default:void 0},shortSwipes:{type:Boolean,default:void 0},longSwipes:{type:Boolean,default:void 0},longSwipesRatio:{type:Number,default:void 0},longSwipesMs:{type:Number,default:void 0},followFinger:{type:Boolean,default:void 0},allowTouchMove:{type:Boolean,default:void 0},threshold:{type:Number,default:void 0},touchMoveStopPropagation:{type:Boolean,default:void 0},touchStartPreventDefault:{type:Boolean,default:void 0},touchStartForcePreventDefault:{type:Boolean,default:void 0},touchReleaseOnEdges:{type:Boolean,default:void 0},uniqueNavElements:{type:Boolean,default:void 0},resistance:{type:Boolean,default:void 0},resistanceRatio:{type:Number,default:void 0},watchSlidesProgress:{type:Boolean,default:void 0},grabCursor:{type:Boolean,default:void 0},preventClicks:{type:Boolean,default:void 0},preventClicksPropagation:{type:Boolean,default:void 0},slideToClickedSlide:{type:Boolean,default:void 0},loop:{type:Boolean,default:void 0},loopedSlides:{type:Number,default:void 0},loopPreventsSliding:{type:Boolean,default:void 0},rewind:{type:Boolean,default:void 0},allowSlidePrev:{type:Boolean,default:void 0},allowSlideNext:{type:Boolean,default:void 0},swipeHandler:{type:Boolean,default:void 0},noSwiping:{type:Boolean,default:void 0},noSwipingClass:{type:String,default:void 0},noSwipingSelector:{type:String,default:void 0},passiveListeners:{type:Boolean,default:void 0},containerModifierClass:{type:String,default:void 0},slideClass:{type:String,default:void 0},slideActiveClass:{type:String,default:void 0},slideVisibleClass:{type:String,default:void 0},slideNextClass:{type:String,default:void 0},slidePrevClass:{type:String,default:void 0},wrapperClass:{type:String,default:void 0},lazyPreloaderClass:{type:String,default:void 0},runCallbacksOnInit:{type:Boolean,default:void 0},observer:{type:Boolean,default:void 0},observeParents:{type:Boolean,default:void 0},observeSlideChildren:{type:Boolean,default:void 0},a11y:{type:[Boolean,Object],default:void 0},autoplay:{type:[Boolean,Object],default:void 0},controller:{type:Object,default:void 0},coverflowEffect:{type:Object,default:void 0},cubeEffect:{type:Object,default:void 0},fadeEffect:{type:Object,default:void 0},flipEffect:{type:Object,default:void 0},creativeEffect:{type:Object,default:void 0},cardsEffect:{type:Object,default:void 0},hashNavigation:{type:[Boolean,Object],default:void 0},history:{type:[Boolean,Object],default:void 0},keyboard:{type:[Boolean,Object],default:void 0},mousewheel:{type:[Boolean,Object],default:void 0},navigation:{type:[Boolean,Object],default:void 0},pagination:{type:[Boolean,Object],default:void 0},parallax:{type:[Boolean,Object],default:void 0},scrollbar:{type:[Boolean,Object],default:void 0},thumbs:{type:Object,default:void 0},virtual:{type:[Boolean,Object],default:void 0},zoom:{type:[Boolean,Object],default:void 0},grid:{type:[Object],default:void 0},freeMode:{type:[Boolean,Object],default:void 0},enabled:{type:Boolean,default:void 0}},emits:["_beforeBreakpoint","_containerClasses","_slideClass","_slideClasses","_swiper","_freeModeNoMomentumRelease","activeIndexChange","afterInit","autoplay","autoplayStart","autoplayStop","autoplayPause","autoplayResume","autoplayTimeLeft","beforeDestroy","beforeInit","beforeLoopFix","beforeResize","beforeSlideChangeStart","beforeTransitionStart","breakpoint","changeDirection","click","disable","doubleTap","doubleClick","destroy","enable","fromEdge","hashChange","hashSet","init","keyPress","lock","loopFix","momentumBounce","navigationHide","navigationShow","navigationPrev","navigationNext","observerUpdate","orientationchange","paginationHide","paginationRender","paginationShow","paginationUpdate","progress","reachBeginning","reachEnd","realIndexChange","resize","scroll","scrollbarDragEnd","scrollbarDragMove","scrollbarDragStart","setTransition","setTranslate","slideChange","slideChangeTransitionEnd","slideChangeTransitionStart","slideNextTransitionEnd","slideNextTransitionStart","slidePrevTransitionEnd","slidePrevTransitionStart","slideResetTransitionStart","slideResetTransitionEnd","sliderMove","sliderFirstMove","slidesLengthChange","slidesGridLengthChange","snapGridLengthChange","snapIndexChange","swiper","tap","toEdge","touchEnd","touchMove","touchMoveOpposite","touchStart","transitionEnd","transitionStart","unlock","update","virtualUpdate","zoomChange"],setup(e,t){let{slots:n,emit:i}=t;const{tag:r,wrapperTag:s}=e,o=it("swiper"),a=it(null),l=it(!1),c=it(!1),f=it(null),u=it(null),d=it(null),h={value:[]},p={value:[]},v=it(null),y=it(null),m=it(null),g=it(null),{params:T,passedParams:P}=Hd(e,!1);kl(n,h,p),d.value=P,p.value=h.value;const A=()=>{kl(n,h,p),l.value=!0};T.onAny=function(B){for(var W=arguments.length,te=new Array(W>1?W-1:0),H=1;H<W;H++)te[H-1]=arguments[H];i(B,...te)},Object.assign(T.on,{_beforeBreakpoint:A,_containerClasses(B,W){o.value=W}});const M={...T};if(delete M.wrapperClass,u.value=new Lt(M),u.value.virtual&&u.value.params.virtual.enabled){u.value.virtual.slides=h.value;const B={cache:!1,slides:h.value,renderExternal:W=>{a.value=W},renderExternalUpdate:!1};mi(u.value.params.virtual,B),mi(u.value.originalParams.virtual,B)}ou(()=>{!c.value&&u.value&&(u.value.emitSlidesClasses(),c.value=!0);const{passedParams:B}=Hd(e,!1),W=dT(B,d.value,h.value,p.value,te=>te.props&&te.props.key);d.value=B,(W.length||l.value)&&u.value&&!u.value.destroyed&&hT({swiper:u.value,slides:h.value,passedParams:B,changedParams:W,nextEl:v.value,prevEl:y.value,scrollbarEl:g.value,paginationEl:m.value}),l.value=!1}),su("swiper",u),xs(a,()=>{iu(()=>{mT(u.value)})}),to(()=>{!f.value||(fT({el:f.value,nextEl:v.value,prevEl:y.value,paginationEl:m.value,scrollbarEl:g.value,swiper:u.value},T),i("swiper",u.value))}),Ba(()=>{u.value&&!u.value.destroyed&&u.value.destroy(!0,!1)});function N(B){return T.virtual?pT(u,B,a.value):(B.forEach((W,te)=>{W.props||(W.props={}),W.props.swiperRef=u,W.props.swiperSlideIndex=te}),B)}return()=>{const{slides:B,slots:W}=kl(n,h,p);return ln(r,{ref:f,class:Dp(o.value)},[W["container-start"],ln(s,{class:uT(T.wrapperClass)},[W["wrapper-start"],N(B),W["wrapper-end"]]),Ip(e)&&[ln("div",{ref:y,class:"swiper-button-prev"}),ln("div",{ref:v,class:"swiper-button-next"})],Np(e)&&ln("div",{ref:g,class:"swiper-scrollbar"}),Op(e)&&ln("div",{ref:m,class:"swiper-pagination"}),W["container-end"]])}}},Gl={name:"SwiperSlide",props:{tag:{type:String,default:"div"},swiperRef:{type:Object,required:!1},swiperSlideIndex:{type:Number,default:void 0,required:!1},zoom:{type:Boolean,default:void 0,required:!1},lazy:{type:Boolean,default:!1,required:!1},virtualIndex:{type:[String,Number],default:void 0}},setup(e,t){let{slots:n}=t,i=!1;const{swiperRef:r}=e,s=it(null),o=it("swiper-slide"),a=it(!1);function l(u,d,h){d===s.value&&(o.value=h)}to(()=>{!r||!r.value||(r.value.on("_slideClass",l),i=!0)}),Sh(()=>{i||!r||!r.value||(r.value.on("_slideClass",l),i=!0)}),ou(()=>{!s.value||!r||!r.value||(typeof e.swiperSlideIndex<"u"&&(s.value.swiperSlideIndex=e.swiperSlideIndex),r.value.destroyed&&o.value!=="swiper-slide"&&(o.value="swiper-slide"))}),Ba(()=>{!r||!r.value||r.value.off("_slideClass",l)});const c=Ha(()=>({isActive:o.value.indexOf("swiper-slide-active")>=0,isVisible:o.value.indexOf("swiper-slide-visible")>=0,isPrev:o.value.indexOf("swiper-slide-prev")>=0,isNext:o.value.indexOf("swiper-slide-next")>=0}));su("swiperSlide",c);const f=()=>{a.value=!0};return()=>ln(e.tag,{class:Dp(`${o.value}`),ref:s,"data-swiper-slide-index":typeof e.virtualIndex>"u"&&r&&r.value&&r.value.params.loop?e.swiperSlideIndex:e.virtualIndex,onLoadCapture:f},e.zoom?ln("div",{class:"swiper-zoom-container","data-swiper-zoom":typeof e.zoom=="number"?e.zoom:void 0},[n.default&&n.default(c.value),e.lazy&&!a.value&&ln("div",{class:"swiper-lazy-preloader"})]):[n.default&&n.default(c.value),e.lazy&&!a.value&&ln("div",{class:"swiper-lazy-preloader"})])}};const vT=(e,t)=>{const n=e.__vccOpts||e;for(const[i,r]of t)n[i]=r;return n},lo=e=>(Gm("data-v-6d607905"),e=e(),Vm(),e),yT={class:"score-panel"},xT={key:0,class:"cl-start-shade"},_T={class:"cl-start-main"},bT=lo(()=>$t("div",{class:"cl-title"}," jump",-1)),wT=lo(()=>$t("img",{src:fv},null,-1)),MT=lo(()=>$t("img",{src:dv},null,-1)),ST=lo(()=>$t("img",{src:hv},null,-1)),TT={key:1,class:"cl-restart"},ET={class:"cl-panel-score"},AT=lo(()=>$t("span",null,"Restart ",-1)),LT=[AT],CT={__name:"App",setup(e){const t=zM(),n=Ha(()=>t.useAppStore.getScore),i=it(0),r=it(0),s=it(""),o=new Audio("./audio/bgm.mp3"),a=new Audio("./audio/fall.mp3");let l;to(()=>{document.addEventListener("contextmenu",function(y){y.preventDefault()})});const c=y=>{s.value="./1.glb"},f=y=>{switch(y.activeIndex){case 0:s.value="./1.glb";break;case 1:s.value="./2.glb";break;case 2:s.value="./3.glb";break;default:s.value="./1.glb";break}},u=y=>{t.useAppStore.setScore(y)},d=()=>{r.value=1,a.volume=.75,a.loop=!1,a.play(),o.pause()},h=()=>{console.log(s.value),l=new CM(s.value),l.init(),l.addSuccessFn(u),l.addFailedFn(d),i.value=1,p()},p=()=>{o.volume=.5,o.play(),o.loop=!0,t.useAppStore.setBgm(o)},v=()=>{l.restart(),r.value=0,o.play()};return(y,m)=>(na(),il(an,null,[$t("div",yT,Su(ci(n)),1),i.value===0?(na(),il("div",xT,[$t("div",_T,[bT,mt(ci(gT),{effect:"cards",grabCursor:!0,modules:ci(cT),onSwiper:c,onSlideChange:f,class:"mySwiper"},{default:ms(()=>[mt(ci(Gl),null,{default:ms(()=>[wT]),_:1}),mt(ci(Gl),null,{default:ms(()=>[MT]),_:1}),mt(ci(Gl),null,{default:ms(()=>[ST]),_:1})]),_:1},8,["modules"]),$t("div",{class:"cl-button",onClick:h},"start")])])):Vu("",!0),r.value===1?(na(),il("div",TT,[$t("div",ET,Su(ci(n)),1),$t("a",{class:"cl-button",onClick:v},LT)])):Vu("",!0)],64))}},PT=vT(CT,[["__scopeId","data-v-6d607905"]]);var Bp={exports:{}};(function(e){(function(){/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */function t(l,c){var f;if(c=c||{},this.trackingClick=!1,this.trackingClickStart=0,this.targetElement=null,this.touchStartX=0,this.touchStartY=0,this.lastTouchIdentifier=0,this.touchBoundary=c.touchBoundary||10,this.layer=l,this.tapDelay=c.tapDelay||200,this.tapTimeout=c.tapTimeout||700,t.notNeeded(l))return;function u(y,m){return function(){return y.apply(m,arguments)}}for(var d=["onMouse","onClick","onTouchStart","onTouchMove","onTouchEnd","onTouchCancel"],h=this,p=0,v=d.length;p<v;p++)h[d[p]]=u(h[d[p]],h);i&&(l.addEventListener("mouseover",this.onMouse,!0),l.addEventListener("mousedown",this.onMouse,!0),l.addEventListener("mouseup",this.onMouse,!0)),l.addEventListener("click",this.onClick,!0),l.addEventListener("touchstart",this.onTouchStart,!1),l.addEventListener("touchmove",this.onTouchMove,!1),l.addEventListener("touchend",this.onTouchEnd,!1),l.addEventListener("touchcancel",this.onTouchCancel,!1),Event.prototype.stopImmediatePropagation||(l.removeEventListener=function(y,m,g){var T=Node.prototype.removeEventListener;y==="click"?T.call(l,y,m.hijacked||m,g):T.call(l,y,m,g)},l.addEventListener=function(y,m,g){var T=Node.prototype.addEventListener;y==="click"?T.call(l,y,m.hijacked||(m.hijacked=function(P){P.propagationStopped||m(P)}),g):T.call(l,y,m,g)}),typeof l.onclick=="function"&&(f=l.onclick,l.addEventListener("click",function(y){f(y)},!1),l.onclick=null)}var n=navigator.userAgent.indexOf("Windows Phone")>=0,i=navigator.userAgent.indexOf("Android")>0&&!n,r=/iP(ad|hone|od)/.test(navigator.userAgent)&&!n,s=r&&/OS 4_\d(_\d)?/.test(navigator.userAgent),o=r&&/OS [6-7]_\d/.test(navigator.userAgent),a=navigator.userAgent.indexOf("BB10")>0;t.prototype.needsClick=function(l){switch(l.nodeName.toLowerCase()){case"button":case"select":case"textarea":if(l.disabled)return!0;break;case"input":if(r&&l.type==="file"||l.disabled)return!0;break;case"label":case"iframe":case"video":return!0}return/\bneedsclick\b/.test(l.className)},t.prototype.needsFocus=function(l){switch(l.nodeName.toLowerCase()){case"textarea":return!0;case"select":return!i;case"input":switch(l.type){case"button":case"checkbox":case"file":case"image":case"radio":case"submit":return!1}return!l.disabled&&!l.readOnly;default:return/\bneedsfocus\b/.test(l.className)}},t.prototype.sendClick=function(l,c){var f,u;document.activeElement&&document.activeElement!==l&&document.activeElement.blur(),u=c.changedTouches[0],f=document.createEvent("MouseEvents"),f.initMouseEvent(this.determineEventType(l),!0,!0,window,1,u.screenX,u.screenY,u.clientX,u.clientY,!1,!1,!1,!1,0,null),f.forwardedTouchEvent=!0,l.dispatchEvent(f)},t.prototype.determineEventType=function(l){return i&&l.tagName.toLowerCase()==="select"?"mousedown":"click"},t.prototype.focus=function(l){var c;r&&l.setSelectionRange&&l.type.indexOf("date")!==0&&l.type!=="time"&&l.type!=="month"?(c=l.value.length,l.setSelectionRange(c,c)):l.focus()},t.prototype.updateScrollParent=function(l){var c,f;if(c=l.fastClickScrollParent,!c||!c.contains(l)){f=l;do{if(f.scrollHeight>f.offsetHeight){c=f,l.fastClickScrollParent=f;break}f=f.parentElement}while(f)}c&&(c.fastClickLastScrollTop=c.scrollTop)},t.prototype.getTargetElementFromEventTarget=function(l){return l.nodeType===Node.TEXT_NODE?l.parentNode:l},t.prototype.onTouchStart=function(l){var c,f,u;if(l.targetTouches.length>1)return!0;if(c=this.getTargetElementFromEventTarget(l.target),f=l.targetTouches[0],r){if(u=window.getSelection(),u.rangeCount&&!u.isCollapsed)return!0;if(!s){if(f.identifier&&f.identifier===this.lastTouchIdentifier)return l.preventDefault(),!1;this.lastTouchIdentifier=f.identifier,this.updateScrollParent(c)}}return this.trackingClick=!0,this.trackingClickStart=l.timeStamp,this.targetElement=c,this.touchStartX=f.pageX,this.touchStartY=f.pageY,l.timeStamp-this.lastClickTime<this.tapDelay&&l.preventDefault(),!0},t.prototype.touchHasMoved=function(l){var c=l.changedTouches[0],f=this.touchBoundary;return Math.abs(c.pageX-this.touchStartX)>f||Math.abs(c.pageY-this.touchStartY)>f},t.prototype.onTouchMove=function(l){return this.trackingClick&&(this.targetElement!==this.getTargetElementFromEventTarget(l.target)||this.touchHasMoved(l))&&(this.trackingClick=!1,this.targetElement=null),!0},t.prototype.findControl=function(l){return l.control!==void 0?l.control:l.htmlFor?document.getElementById(l.htmlFor):l.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea")},t.prototype.onTouchEnd=function(l){var c,f,u,d,h,p=this.targetElement;if(!this.trackingClick)return!0;if(l.timeStamp-this.lastClickTime<this.tapDelay)return this.cancelNextClick=!0,!0;if(l.timeStamp-this.trackingClickStart>this.tapTimeout)return!0;if(this.cancelNextClick=!1,this.lastClickTime=l.timeStamp,f=this.trackingClickStart,this.trackingClick=!1,this.trackingClickStart=0,o&&(h=l.changedTouches[0],p=document.elementFromPoint(h.pageX-window.pageXOffset,h.pageY-window.pageYOffset)||p,p.fastClickScrollParent=this.targetElement.fastClickScrollParent),u=p.tagName.toLowerCase(),u==="label"){if(c=this.findControl(p),c){if(this.focus(p),i)return!1;p=c}}else if(this.needsFocus(p))return l.timeStamp-f>100||r&&window.top!==window&&u==="input"?(this.targetElement=null,!1):(this.focus(p),this.sendClick(p,l),(!r||u!=="select")&&(this.targetElement=null,l.preventDefault()),!1);return r&&!s&&(d=p.fastClickScrollParent,d&&d.fastClickLastScrollTop!==d.scrollTop)?!0:(this.needsClick(p)||(l.preventDefault(),this.sendClick(p,l)),!1)},t.prototype.onTouchCancel=function(){this.trackingClick=!1,this.targetElement=null},t.prototype.onMouse=function(l){return!this.targetElement||l.forwardedTouchEvent||!l.cancelable?!0:!this.needsClick(this.targetElement)||this.cancelNextClick?(l.stopImmediatePropagation?l.stopImmediatePropagation():l.propagationStopped=!0,l.stopPropagation(),l.preventDefault(),!1):!0},t.prototype.onClick=function(l){var c;return this.trackingClick?(this.targetElement=null,this.trackingClick=!1,!0):l.target.type==="submit"&&l.detail===0?!0:(c=this.onMouse(l),c||(this.targetElement=null),c)},t.prototype.destroy=function(){var l=this.layer;i&&(l.removeEventListener("mouseover",this.onMouse,!0),l.removeEventListener("mousedown",this.onMouse,!0),l.removeEventListener("mouseup",this.onMouse,!0)),l.removeEventListener("click",this.onClick,!0),l.removeEventListener("touchstart",this.onTouchStart,!1),l.removeEventListener("touchmove",this.onTouchMove,!1),l.removeEventListener("touchend",this.onTouchEnd,!1),l.removeEventListener("touchcancel",this.onTouchCancel,!1)},t.notNeeded=function(l){var c,f,u,d;if(typeof window.ontouchstart>"u")return!0;if(f=+(/Chrome\/([0-9]+)/.exec(navigator.userAgent)||[,0])[1],f)if(i){if(c=document.querySelector("meta[name=viewport]"),c&&(c.content.indexOf("user-scalable=no")!==-1||f>31&&document.documentElement.scrollWidth<=window.outerWidth))return!0}else return!0;return!!(a&&(u=navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/),u[1]>=10&&u[2]>=3&&(c=document.querySelector("meta[name=viewport]"),c&&(c.content.indexOf("user-scalable=no")!==-1||document.documentElement.scrollWidth<=window.outerWidth)))||l.style.msTouchAction==="none"||l.style.touchAction==="manipulation"||(d=+(/Firefox\/([0-9]+)/.exec(navigator.userAgent)||[,0])[1],d>=27&&(c=document.querySelector("meta[name=viewport]"),c&&(c.content.indexOf("user-scalable=no")!==-1||document.documentElement.scrollWidth<=window.outerWidth)))||l.style.touchAction==="none"||l.style.touchAction==="manipulation")},t.attach=function(l,c){return new t(l,c)},e.exports?(e.exports=t.attach,e.exports.FastClick=t):window.FastClick=t})()})(Bp);const RT=Bp.exports,kd=(e,t)=>{const n=e.storage||sessionStorage,i=e.key||t.$id;if(e.paths){const r=e.paths.reduce((s,o)=>(s[o]=t.$state[o],s),{});n.setItem(i,JSON.stringify(r))}else n.setItem(i,JSON.stringify(t.$state))};var IT=({options:e,store:t})=>{var n,i,r,s;if((n=e.persist)!=null&&n.enabled){const o=[{key:t.$id,storage:sessionStorage}],a=(r=(i=e.persist)==null?void 0:i.strategies)!=null&&r.length?(s=e.persist)==null?void 0:s.strategies:o;a.forEach(l=>{const c=l.storage||sessionStorage,f=l.key||t.$id,u=c.getItem(f);u&&(t.$patch(JSON.parse(u)),kd(l,t))}),t.$subscribe(()=>{a.forEach(l=>{kd(l,t)})})}};RT(document.body);const zp=RM();zp.use(IT);const Up=cv(PT);Up.use(zp);Up.mount("#app");
